<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JJ❤22</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-14T15:48:50.060Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JJZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构之递归</title>
    <link href="http://yoursite.com/2018/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2018/10/14/数据结构之递归/</id>
    <published>2018-10-14T15:12:08.944Z</published>
    <updated>2018-10-14T15:48:50.060Z</updated>
    
    <content type="html"><![CDATA[<p>递归既会出现多次函数调用，会多占用空间也会消耗时间，空间复杂度和时间复杂度都会上升，其他基础知识不再此赘述，主要记录一下几个关键点。</p><a id="more"></a> <h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><h2 id="递归需要注意的问题"><a href="#递归需要注意的问题" class="headerlink" title="递归需要注意的问题"></a>递归需要注意的问题</h2><ol><li>递归代码要警惕堆栈溢出，因为系统栈或者虚拟机栈空间一般都不大。解决方案：可以限制递归调用的最大深度，但是这种方法不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，无法事先计算，所以当最大递归深度比较小，如10、50时，可以使用这种方法。</li><li>递归代码要警惕重复计算。比如f(n)=f(n-1)+f(n-2)，那么f(4)=f(3)+f(2)且f(5)=f(4)+f(3)，则f(3)就被重复计算了两次。此时可以通过散列表为已经求出的f(K)值建立索引K，这样当在后面的递归中用到f(K)时就不需要重复计算了，只需要map.get(n)获取相应值即可。</li><li>谨防脏数据，出现递归死循环。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;递归既会出现多次函数调用，会多占用空间也会消耗时间，空间复杂度和时间复杂度都会上升，其他基础知识不再此赘述，主要记录一下几个关键点。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之队列</title>
    <link href="http://yoursite.com/2018/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/10/14/数据结构之队列/</id>
    <published>2018-10-14T08:22:57.308Z</published>
    <updated>2018-10-14T15:45:34.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h2><p>就像栈有顺序栈和链式栈一样，队列也有顺序的和链式的。</p><a id="more"></a> <p>顺序队列使用head指针指向队头，使用tail指针指向队尾，初始队列的头指针和尾指针指向第0个位置，入队操作时尾指针向后移（相当于尾指针是指向队列尾元素的下一个位置的），出队操作时头指针向后移（相当于头指针是指向队列头元素的位置的），队满的判断条件为 tail == n，队空的判断条件为 head == tail。随着不停地进行入队、出队操作，head 和 tail 都会持续后移，当 tail 移动到最右边，<strong>即使数组中还有空闲空间，也无法往队列里继续添加数据了</strong>，此时可以使用<strong>数据搬移</strong>，一个解决方案就是每进行一次出队操作，就把出队前0位置后面的数据前移一位，但是这样出队操作的时间复杂度会从O(1)变成O(n)；更好的方案是不必要每次出队后都进行一次数据迁移，而是<strong>等到队列没有空闲空间时，再次需要入队时集中触发数据搬移操作即可。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作，将 item 放入队尾 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tail == n 表示队列末尾没有空间了</span></span><br><span class="line">  <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">    <span class="comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 数据搬移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">         items[i-head] = items[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搬移完之后重新更新 head 和 tail</span></span><br><span class="line">    tail -= head;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  items[tail] = item;</span><br><span class="line">  ++tail;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将head到tail之间的数据移动至0到tail-head的位置。此时均摊时间复杂度为O(1)，平均时间复杂度也为O(1)（此处存疑）。</p><p>链式队列类似，不再赘述。</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列<strong>一般都是数组形式的顺序队列</strong>，链式的叫循环链表。</p><p>循环队列队空的判断条件仍为 head == tail，队满的判断条件为(tail+1)%n == head，也正因为这样，当队列满时， tail 指向的位置实际是没有存储数据的，所以会浪费一个数组的存储空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span> &#123;</span></span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">      items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">      n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> boolean <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//出队</span></span><br><span class="line">  <span class="keyword">public</span> String dequeue &#123;</span><br><span class="line">    <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> null;</span><br><span class="line">    String ret = item[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h2><p>阻塞队列其实就是在队列基础上增加了阻塞操作。就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。其实就是一个“生产者 - 消费者模型”。</p><p>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue()上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;顺序队列和链式队列&quot;&gt;&lt;a href=&quot;#顺序队列和链式队列&quot; class=&quot;headerlink&quot; title=&quot;顺序队列和链式队列&quot;&gt;&lt;/a&gt;顺序队列和链式队列&lt;/h2&gt;&lt;p&gt;就像栈有顺序栈和链式栈一样，队列也有顺序的和链式的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ安装</title>
    <link href="http://yoursite.com/2018/10/14/ActiveMQ%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/10/14/ActiveMQ安装/</id>
    <published>2018-10-13T16:32:00.753Z</published>
    <updated>2018-10-13T17:20:27.730Z</updated>
    
    <content type="html"><![CDATA[<p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。MQ: message queue, 顾名思义就是消息队列的意思。因而这个主要是关于消息交互和消息队列的。</p><a id="more"></a><h2 id="下载ActiveMQ"><a href="#下载ActiveMQ" class="headerlink" title="下载ActiveMQ"></a>下载ActiveMQ</h2><p>去官方网站下载：<a href="http://activemq.apache.org/" target="_blank" rel="noopener">http://activemq.apache.org/</a></p><p>下载之前注意查看版本对应的JDK要求，并在本机配置好；可以在官网release底下找到要求的最低版本，此处放出部分版本号。</p><table><thead><tr><th>MQ版本号</th><th>Build-Jdk</th><th>依赖JDK</th></tr></thead><tbody><tr><td>apache-activemq-5.11.0</td><td>1.7.0_60</td><td>1.7+</td></tr><tr><td>apache-activemq-5.12.0</td><td>1.7.0_80</td><td>1.7+</td></tr><tr><td>apache-activemq-5.13.0</td><td>1.7.0_80</td><td>1.7+</td></tr><tr><td>apache-activemq-5.14.0</td><td>1.7.0_80</td><td>1.7+</td></tr><tr><td>apache-activemq-5.15.0</td><td>1.8.0_112</td><td>1.8+</td></tr></tbody></table><h2 id="运行ActiveMQ"><a href="#运行ActiveMQ" class="headerlink" title="运行ActiveMQ"></a>运行ActiveMQ</h2><p>解压文件夹后进入bin目录，双击activemq.bat就可以启动ActiveMQ了</p><p><strong>此处我出现了一个问题</strong>，双击bat文件后出现控制台闪现后消失的现象，<strong>解决方案</strong>如下：</p><ol><li>windows系统，在bin文件夹下打开cmd命令行，输入 activemq-admin.bat start。  </li><li>大约是JDK版本问题，引起了闪退。</li></ol><p>我是使用了第一个方法解决的。</p><p>出错时显示如下：</p><p><img src="\uploads\ActiveMQ安装\ActiveMQ安装-1.png" alt="出错图"></p><p>解决后显示如下：</p><p><img src="\uploads\ActiveMQ安装\ActiveMQ安装-2.png" alt="解决图"></p><p>启动ActiveMQ以后，登陆：<a href="http://localhost:8161/admin/" target="_blank" rel="noopener">http://localhost:8161/admin/</a> ,账户和密码都是admin，正常显示如下：</p><p><img src="\uploads\ActiveMQ安装\ActiveMQ安装-3.png" alt="正常运行"></p><p>至此安装结束，可以创建queue了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。MQ: message queue, 顾名思义就是消息队列的意思。因而这个主要是关于消息交互和消息队列的。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之堆栈</title>
    <link href="http://yoursite.com/2018/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%A0%88/"/>
    <id>http://yoursite.com/2018/10/11/数据结构之堆栈/</id>
    <published>2018-10-11T15:24:13.330Z</published>
    <updated>2018-10-14T08:26:40.717Z</updated>
    
    <content type="html"><![CDATA[<p>关于堆栈的基础知识此处不做赘述。主要写一下今天学习数据结构的堆栈时看到的一个问题：</p><h2 id="JVM的堆栈和数据结构的堆栈一样么"><a href="#JVM的堆栈和数据结构的堆栈一样么" class="headerlink" title="JVM的堆栈和数据结构的堆栈一样么"></a>JVM的堆栈和数据结构的堆栈一样么</h2><p>第一反应肯定还是不一样的，但是具体为什么不一样好像也不知道个所以然。。于是上网查了查，此处引用一篇资料，希望有所帮助。<br><a id="more"></a></p><p>JVM中的stack和heap与数据结构中所说的stack和heap是一个概念吗-CSDN论坛<br><a href="https://bbs.csdn.net/topics/330120842" target="_blank" rel="noopener">https://bbs.csdn.net/topics/330120842</a></p><p><a href="https://blog.csdn.net/weixin_41856078/article/details/79725852" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41856078/article/details/79725852</a></p><p>JVM中的stack和heap的实现方法与特性和普通的数据结构是一样，概念上应该是一致的。只是实现层次不同，实现方式上肯定比一般的实现要复杂点，只是对外的操作肯定一致。</p><p><strong>数据结构中的堆栈</strong>：是两种特殊的数据结构，都是对数据项按序排列的数据结构，对管理数据的一种手段和方法。可以用来存放数据和地址，栈只能在一端（栈顶）对数据项进行插入和删除。</p><p><strong>内存中的堆栈</strong>：是确切存在的物理结构，是用来存放不同数据的内存空间。内存中的栈，是由系统自动分配和释放的，是由高地址向低地址扩展的数据机构，是一段连续的内存区域，是对数据结构中的栈这种手段的实现。栈的顶地址和最大容量是系统预先设定好的，在程序编译时，它就是一个确定的常数，但注意并不是所有用到栈技术的区域都是栈区，虽然目前是这样，这是概念定义的准确性问题。 内存中堆，一般用来动态分配内存的，它的实现跟操作系统和编译器有关，一般内存中的堆貌似是用链表实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于堆栈的基础知识此处不做赘述。主要写一下今天学习数据结构的堆栈时看到的一个问题：&lt;/p&gt;
&lt;h2 id=&quot;JVM的堆栈和数据结构的堆栈一样么&quot;&gt;&lt;a href=&quot;#JVM的堆栈和数据结构的堆栈一样么&quot; class=&quot;headerlink&quot; title=&quot;JVM的堆栈和数据结构的堆栈一样么&quot;&gt;&lt;/a&gt;JVM的堆栈和数据结构的堆栈一样么&lt;/h2&gt;&lt;p&gt;第一反应肯定还是不一样的，但是具体为什么不一样好像也不知道个所以然。。于是上网查了查，此处引用一篇资料，希望有所帮助。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆栈" scheme="http://yoursite.com/tags/%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之数组</title>
    <link href="http://yoursite.com/2018/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/10/09/数据结构之数组/</id>
    <published>2018-10-09T01:48:20.831Z</published>
    <updated>2018-10-14T08:27:49.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h2><p>数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><a id="more"></a> <ul><li><p>线性表</p><p>就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向，除了数组，链表、队列、栈等也是线性表结构（ 线性表是一种<strong>逻辑结构</strong>，而顺序表、链表等是<strong>存储结构</strong> ）。</p></li><li><p>非线性表</p><p>如二叉树、堆、图等，数据之间并不是简单的前后关系。</p></li></ul><hr><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><p>大多数会说链表适合插入、删除，时间复杂度为O(1)；数组适合查找，查找时间复杂度为O(1)。<strong>这是不准确的！</strong></p><p>数组适合查找，但是查找的时间复杂度并不是O(1)，即便是排序好的数组，用二分查找，时间复杂度也是O(log n)。所以正确的表述是，<strong>数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</strong></p><hr><h2 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h2><p>数组为了保持内存数据连续性，会导致插入、删除操作比较低效。</p><ul><li><p>插入</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第K个位置。<strong>在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为O(1)。</strong></p></li><li><p>删除</p><p>如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。我们可以<strong>将多次删除操作集中在一起执行</strong>。比如可以先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，从而可以大大减少删除操作导致的数据搬移。JVM标记清除垃圾回收算法就用了类似的思想。</p></li></ul><hr><h2 id="为什么大多数编程语言中，数组从0开始编号"><a href="#为什么大多数编程语言中，数组从0开始编号" class="headerlink" title="为什么大多数编程语言中，数组从0开始编号"></a>为什么大多数编程语言中，数组从0开始编号</h2><p>从数组的存储结构来看，<strong>下标</strong>准确说就是<strong>偏移</strong>。如果下标从0开始，那么</p><center>a[k]_address = base_address + k * type_size</center><p>若下标从1开始，则会变成</p><center>a[k]_address = base_address + (k-1) * type_size</center><p>那么每次随机访问数组元素时就多了一次减法运算，对于CPU来说，就是多了一次减法指令。</p><p>数组作为基础的数据结构，通过下标随机访问又是非常基础的操作，效率的优化就需要尽可能做到极致，所以选择了从0开始编号。另一方面，从历史角度来看，由于C语言设计用0作为数组下标，而后的java、javaScript等高级语言都是效仿了C语言，也为了减少C语言程序员学习java的学习成本。但比如Matlab就不是从0开始，Python支持负数下标。</p><hr><h2 id="使用容器还是数组"><a href="#使用容器还是数组" class="headerlink" title="使用容器还是数组"></a>使用容器还是数组</h2><p>比如C++的Vector或者Java的ArrayList等属于容器类，一般来说容器类相比数组会消耗一定的性能（比如动态扩容时往往是重新申请一个更大的空间，将数据拷贝进去，而拷贝操作十分耗时）。不过对于业务开发，直接用容器类就够了，比较省时省力，但如果是底层开发，性能需要尽量优化，则数组可能更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是数组&quot;&gt;&lt;a href=&quot;#什么是数组&quot; class=&quot;headerlink&quot; title=&quot;什么是数组&quot;&gt;&lt;/a&gt;什么是数组&lt;/h2&gt;&lt;p&gt;数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="http://yoursite.com/2018/10/08/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2018/10/08/两数之和/</id>
    <published>2018-10-08T12:52:24.054Z</published>
    <updated>2018-10-14T08:28:41.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（简单）"><a href="#题目（简单）" class="headerlink" title="题目（简单）"></a>题目（简单）</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br><a id="more"></a><br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><pre><code>class Solution {public int[] twoSum(int[] nums, int target) {    for(int i=0;i&lt;nums.length;++i)    {        int T = target - nums[i];        for(int j=i+1;j&lt;nums.length;++j)        {            if(nums[j] == T)              return new int[]{i, j};  //不需要提前申请，直接可以返回        }    }    throw new IllegalArgumentException(&quot;No two sum solution&quot;); //抛出错误  }}</code></pre><h3 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1.暴力解法"></a>1.暴力解法</h3><p>暴力法很简单。遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。<br>​    <pre><code>public int[] twoSum(int[] nums, int target) {<br>​    for (int i = 0; i &lt; nums.length; i++) {<br>​        for (int j = i + 1; j &lt; nums.length; j++) {<br>​            if (nums[j] == target - nums[i]) {<br>​                return new int[] { i, j };<br>​            }<br>​        }<br>​    }<br>​    throw new IllegalArgumentException(“No two sum solution”);<br>}</code></pre></p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n<sup>2</sup>)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n)的时间。因此时间复杂度为 O(n<sup>2</sup>)。</li><li>空间复杂度：O(1)。</li></ul><h3 id="2-两遍哈希表"><a href="#2-两遍哈希表" class="headerlink" title="2.两遍哈希表"></a>2.两遍哈希表</h3><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。<br>通过以空间换取速度的方式，我们可以将查找时间从O(n)降低到O(1)。哈希表正是为此目的而构建的，它支持以<strong>近似</strong>恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。<br>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是nums[i]本身！<br>​    <pre><code>public int[] twoSum(int[] nums, int target) {<br>​    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br>​    for (int i = 0; i &lt; nums.length; i++) {<br>​        map.put(nums[i], i);<br>​    }<br>​    for (int i = 0; i &lt; nums.length; i++) {<br>​        int complement = target - nums[i];<br>​        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {  //containsKey方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false<br>​            return new int[] { i, map.get(complement) };<br>​        }<br>​    }<br>​    throw new IllegalArgumentException(“No two sum solution”);<br>}</code></pre></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，我们把包含有n个元素的列表遍历两次。由于哈希表将查找时间缩短到O(1) ，所以时间复杂度为O(n)。</li><li>空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 </li></ul><h3 id="3-一遍哈希表"><a href="#3-一遍哈希表" class="headerlink" title="3.一遍哈希表"></a>3.一遍哈希表</h3><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。<br>​    <pre><code>public int[] twoSum(int[] nums, int target) {<br>​    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br>​    for (int i = 0; i &lt; nums.length; i++) {<br>​        int complement = target - nums[i];<br>​        if (map.containsKey(complement)) {<br>​            return new int[] { map.get(complement), i };<br>​        }<br>​        map.put(nums[i], i);<br>​    }<br>​    throw new IllegalArgumentException(“No two sum solution”);<br>}</code></pre></p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费O(1)的时间。</li><li>空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（简单）&quot;&gt;&lt;a href=&quot;#题目（简单）&quot; class=&quot;headerlink&quot; title=&quot;题目（简单）&quot;&gt;&lt;/a&gt;题目（简单）&lt;/h2&gt;&lt;p&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&lt;br&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Next主题如何添加打赏功能</title>
    <link href="http://yoursite.com/2018/10/03/Hexo%20Next%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2018/10/03/Hexo Next主题如何添加打赏功能/</id>
    <published>2018-10-03T12:16:19.735Z</published>
    <updated>2018-10-03T13:14:51.779Z</updated>
    
    <content type="html"><![CDATA[<p>最近搭建博客时想要添加个打赏功能，虽然好像一般也没人打赏= = 但是咱们是那种见钱眼开的人么？不是！所以————<br>咱们还是添加一个吧！<br><a id="more"></a></p><hr><p>在网上查了些资料，有的方法试了发现没成功，可能因为主题不一样的原因，由于我使用的Next主题，所以先把Next主题下的添加打赏方法写出来。</p><h2 id="基于Next主题"><a href="#基于Next主题" class="headerlink" title="基于Next主题"></a>基于Next主题</h2><h3 id="1-准备支付宝和微信二维码"><a href="#1-准备支付宝和微信二维码" class="headerlink" title="1.准备支付宝和微信二维码"></a>1.准备支付宝和微信二维码</h3><p>&ensp;&ensp;首先得准备支付宝和微信的收款二维码（直接打开相应软件，到收款功能处保存二维码即可），然后将对应图片放在<strong>next\source\images</strong>路径下，并命名为<strong>wechatpay.jpg</strong>和<strong>alipay.jpg</strong>（文件名称随意，不过后面会用到，当然你用PNG格式也是可以的）</p><h3 id="2-在-config-yml中添加图片路径"><a href="#2-在-config-yml中添加图片路径" class="headerlink" title="2.在_config.yml中添加图片路径"></a>2.在_config.yml中添加图片路径</h3><p>&ensp;&ensp;注意此处<strong>_config.yml</strong>是<strong>主题配置文件</strong>，不要弄错了。打开后找到如下属性,并配置路径:</p><pre><code>**reward_comment:** 坚持原创技术分享，您的支持将鼓励我继续创作！**wechatpay:** /images/wechatpay.jpg**alipay:** /images/alipay.jpg</code></pre><h3 id="3-修复闪动bug"><a href="#3-修复闪动bug" class="headerlink" title="3.修复闪动bug"></a>3.修复闪动bug</h3><p>修改next/source/css/_common/components/post/post-reward.styl，注释wechat:hover和alipay:hover</p><pre><code>/* 注释文字闪动函数#wechat:hover p{animation: roll 0.1s infinite linear;-webkit-animation: roll 0.1s infinite linear;-moz-animation: roll 0.1s infinite linear;}#alipay:hover p{animation: roll 0.1s infinite linear;-webkit-animation: roll 0.1s infinite linear;-moz-animation: roll 0.1s infinite linear;}*/ </code></pre><h3 id="4-效果"><a href="#4-效果" class="headerlink" title="4.效果"></a>4.效果</h3><p><img src="/uploads/donate.jpg" alt="打赏"></p><h2 id="基于其他主题"><a href="#基于其他主题" class="headerlink" title="基于其他主题"></a>基于其他主题</h2><p>其他主题的我没有尝试，此处转载一个链接，里面有关于打赏实现的方法，希望能有帮助：<a href="https://blog.csdn.net/l_201607/article/details/81097278" target="_blank" rel="noopener">https://blog.csdn.net/l_201607/article/details/81097278</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近搭建博客时想要添加个打赏功能，虽然好像一般也没人打赏= = 但是咱们是那种见钱眼开的人么？不是！所以————&lt;br&gt;咱们还是添加一个吧！&lt;br&gt;
    
    </summary>
    
      <category term="Hexo静态博客" scheme="http://yoursite.com/categories/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的广义定义和狭义定义</title>
    <link href="http://yoursite.com/2018/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B9%BF%E4%B9%89%E5%AE%9A%E4%B9%89%E5%92%8C%E7%8B%AD%E4%B9%89%E5%AE%9A%E4%B9%89/"/>
    <id>http://yoursite.com/2018/10/03/数据结构的广义定义和狭义定义/</id>
    <published>2018-10-03T08:24:22.000Z</published>
    <updated>2018-10-09T02:49:30.981Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了关于数据结构的课程，打算重温一下数据结构的知识，正好又新搭建了个人博客，打算把学习过程中的一些知识点记录下来，方便以后温习。部分内容是直接copy的课程内容，如有侵权，请联系博主删除。<br><a id="more"></a> </p><h2 id="广义定义"><a href="#广义定义" class="headerlink" title="广义定义"></a>广义定义</h2><p>指一组数据结构的存储结构。算法就是操作数据的一组方法。</p><h2 id="狭义定义"><a href="#狭义定义" class="headerlink" title="狭义定义"></a>狭义定义</h2><p>指某些著名的数据结构和算法，如队列、栈、堆、二分查找、动态规划等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了关于数据结构的课程，打算重温一下数据结构的知识，正好又新搭建了个人博客，打算把学习过程中的一些知识点记录下来，方便以后温习。部分内容是直接copy的课程内容，如有侵权，请联系博主删除。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置文件 subtile和description内容如何换行</title>
    <link href="http://yoursite.com/2018/10/01/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20subtile%E5%92%8Cdescription%E5%86%85%E5%AE%B9%E5%A6%82%E4%BD%95%E6%8D%A2%E8%A1%8C/"/>
    <id>http://yoursite.com/2018/10/01/Hexo配置文件 subtile和description内容如何换行/</id>
    <published>2018-10-01T14:59:22.000Z</published>
    <updated>2018-10-03T12:19:19.522Z</updated>
    
    <content type="html"><![CDATA[<p>配置Hexo个人博客时，站点配置文件<strong>_config.yml</strong>中个人信息可能需要换行，此时只需要在换行位置加上换行符即可。具体方法如下：<br><a id="more"></a> </p><h2 id="使用-lt-br-实现换行"><a href="#使用-lt-br-实现换行" class="headerlink" title="使用&lt;br>实现换行"></a>使用&lt;br>实现换行</h2><pre><code># Sitetitle: JJ❤22subtitle:description: QQ:339003672&lt;br&gt;WeChat:Zhang_junj #分行keywords:author: JJZhanglanguage: zh-Hanstimezone:</code></pre><p>直接在换行位置加入<strong>&lt;br></strong>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;配置Hexo个人博客时，站点配置文件&lt;strong&gt;_config.yml&lt;/strong&gt;中个人信息可能需要换行，此时只需要在换行位置加上换行符即可。具体方法如下：&lt;br&gt;
    
    </summary>
    
      <category term="Hexo静态博客" scheme="http://yoursite.com/categories/Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="个人博客" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
