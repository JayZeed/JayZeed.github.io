<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JJ❤22</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-11T04:51:37.804Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JJZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode————不用加减乘除做加法</title>
    <link href="http://yoursite.com/2019/02/11/LeetCode%E2%80%94%E2%80%94%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/11/LeetCode——不用加减乘除做加法/</id>
    <published>2019-02-11T02:37:22.000Z</published>
    <updated>2019-02-11T04:51:37.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p>解法一：投机取巧，用 += 运算符</p><p>解法二：用异或(^)表示加法，按位与(&amp;)表示进位，当进位为0时表示得到最后结果</p><p>例如： 5+7=12，三步走</p><ol><li>第一步：相加各位的值，不算进位，得到2。</li><li>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</li><li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>) &#123; <span class="comment">//只有进位为0才能停止</span></span><br><span class="line">            <span class="keyword">int</span> temp = num1 ^ num2; <span class="comment">//求异或，得到无进位的和</span></span><br><span class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>; <span class="comment">//左移位，表示进位</span></span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。&lt;/p&gt;
&lt;p&gt;解法一：投机取巧，用 += 运
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>谈谈HTTP协议中的短轮询、长轮询、长连接和短连接[转]</title>
    <link href="http://yoursite.com/2019/02/03/%E8%B0%88%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%5B%E8%BD%AC%5D/"/>
    <id>http://yoursite.com/2019/02/03/谈谈HTTP协议中的短轮询、长轮询、长连接和短连接[转]/</id>
    <published>2019-02-03T13:26:00.551Z</published>
    <updated>2019-02-18T08:23:49.967Z</updated>
    
    <content type="html"><![CDATA[<p>引言</p><p>最近刚到公司不到一个月，正处于熟悉项目和源码的阶段，因此最近经常会看一些源码。在研究一个项目的时候，源码里面用到了HTTP的长轮询。由于之前没太接触过，因此LZ便趁着这个机会，好好了解了一下HTTP的长长短短。</p><p>了解的方式主要都是LZ在网络上获取的，这里只是谈一下LZ对于这四种叫法最直观的理解。如果你之前不懂的话，可以帮你普及一下，如果你之前就懂得话，可以互相对照一下。</p><a id="more"></a><h3 id="以前的误解"><a href="#以前的误解" class="headerlink" title="以前的误解"></a>以前的误解</h3><p>很久之前LZ就听说过长连接的说法，而且还知道HTTP1.0协议不支持长连接，从HTTP1.1协议以后，连接默认都是长连接。但LZ终究觉得对于长连接一直懵懵懂懂的，有种抓不到关键点的感觉。</p><p>今天LZ通过一番研究，终于明白了这其中的奥秘。而之前，LZ也看过长连接相关的内容，但一直都是云里雾里的。这次之所以能在这么短的时间里搞清楚，和LZ自己技术的沉淀密不可分。因此，这里LZ借着这个机会，再次强调一下，千万不要试图去研究你研究了很久都整不明白的东西，或许是你的层次不到，也或许是你从未在实际的应用场景接触过，这种情况下你去研究，只会事倍功半，徒劳一番罢了。</p><p>回到正题，既然说是误解，那么LZ的误解到底是什么？</p><p>那就是LZ一直认为，HTTP连接分为长连接和短连接，而我们现在常用的都是HTTP1.1，因此我们用的都是长连接。</p><p>这句话其实只对了一半，我们现如今的HTTP协议，大部分都是1.1的，因此我们平时用的基本上都是长连接。但是前半句是不对的，HTTP协议根本没有长短连接这一说，也正因为误解了这个，导致LZ对于长连接一直不明不白，始终不得其要领，具体下面一段会说到。</p><p>网络上很多文章都是误人子弟，根本没有说明白这个概念。这里LZ要强调一下，<strong>HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了</strong>，或者更准确的说，是本次HTTP请求就结束了，根本没有长连接这一说。那么自然也就没有短连接这一说了。</p><p>之所以网络上说HTTP分为长连接和短连接，其实本质上是说的TCP连接。<strong>TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说</strong>。</p><p>其实知道了以后，会觉得这很好理解。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。</p><p>一个形象的例子就是，拿你在网上购物来说，HTTP协议是指的那个快递单，你寄件的时候填的单子就像是发了一个HTTP请求，等货物运到地方了，快递员会根据你发的请求把货物送给相应的收货人。而TCP协议就是中间运货的那个大货车，也可能是火车或者飞机，但不管是什么，它是负责运输的，因此必须要有路，不管是地上还是天上。那么这个路就是所谓的TCP连接，也就是一个双向的数据通道。</p><p>因此，LZ现在甚至觉得，“HTTP连接”这个词就不应该出现，它只是一个应用层的协议，根本就没有所谓的连接这一说，就像FTP也是应用层的协议，但是你有听说过FTP连接吗？（恩，好像是听过，-_-，但你现在知道了，其实所谓的FTP连接，严格来说，依旧是TCP连接）</p><p>实际上，说HTTP请求和HTTP响应会更准确一些，而HTTP请求和HTTP响应，都是通过TCP连接这个通道来回传输的。</p><p><strong>不管怎么说，一定要务必记住，长连接是指的TCP连接，而不是HTTP连接。</strong></p><h3 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h3><p>之前LZ一直对一件事有些模糊不清，首先是怎么样就算是把HTTP变成长连接了，是不是只要设置Connection为keep-alive就算是了？</p><p>如果是的话，那都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接，但是长连接不是一般用于交互比较频繁的应用吗？像我们这种普通的Web应用，比如博客园这种，或者我的个人博客这种，长连接有什么用？</p><p>如果有用那用处到底是什么，我们又不是客户端与服务器交互频繁的那种应用（毕竟你打开网页肯定要半天才打开另外一个吧），如果没用的话，那到底应不应该把Connection为keep-alive这个header值给改掉，从而改成短连接？</p><p>这个疑问，在LZ明白了长连接其实是指的TCP连接之后，基本上就明白了。而这个疑问，也正是LZ在“以前的误解”那一段所提到的，那个因为误解导致LZ一直搞不明白的问题。</p><p>为什么解决了上面那个误解之后，前面所说的这些疑问LZ都明白了？</p><p>因为长连接意味着连接会被复用，毕竟一直保持着连接不就是为了重复使用嘛。但如果长连接是指的HTTP的话，那就是说HTTP连接可以被重复利用，这个话听起来就感觉很别扭。之所以觉得别扭，其实就是LZ的一种直觉，没什么理论依据。而这种别扭的根源就在于，之前一直没有融会贯通的感觉，所以总感觉缺少点什么。不过这点疑惑，并没有影响LZ的工作，因此也就没深究过。</p><p>但现在好了，明白了长连接实际上是指的TCP连接，LZ瞬间自己就想明白了上面的那些问题。</p><p>第一个问题是，是不是只要设置Connection为keep-alive就算是长连接了？</p><p>当然是的，但要服务器和客户端都设置。</p><p>第二个问题是，我们平时用的是不是长连接？</p><p>这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）</p><p>第三个问题，也是LZ之前最想不明白的问题，那就是我们这种普通的Web应用（比如博客园，我的个人博客这种）用长连接有啥好处？需不需要关掉长连接而使用短连接？</p><p>这个问题LZ现在终于明白了，问题的答案是好处还是有的。</p><p>好处是什么？</p><p>首先，刚才已经说了，长连接是为了复用，这个在之前LZ就明白。那既然长连接是指的TCP连接，也就是说复用的是TCP连接。那这就很好解释了，也就是说，长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。</p><p>比如你请求了博客园的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源就不用LZ去说了吧。</p><p>但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。</p><p>这样一解释，就很明白了，不知道大家看了这些解释感觉如何，反正LZ在自己想明白以后，有种豁然开朗的感觉。</p><p>另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。</p><p>这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？</p><h3 id="长轮询和短轮询"><a href="#长轮询和短轮询" class="headerlink" title="长轮询和短轮询"></a>长轮询和短轮询</h3><p>前面基本上LZ已经把长短连接说的差不多了，接下来说说长短轮询，今天也正是为了研究长短轮询，LZ才顺便研究了下长短连接这回事。</p><p>短轮询相信大家都不难理解，比如你现在要做一个电商中商品详情的页面，这个详情界面中有一个字段是库存量（相信这个大家都不陌生，随便打开淘宝或者京东都能找到这种页面）。而这个库存量需要实时的变化，保持和服务器里实际的库存一致。</p><p>这个时候，你会怎么做？</p><p>最简单的一种方式，就是你用JS写个死循环，不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。</p><p>这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。</p><p>那怎么办呢？</p><p>长轮询这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。</p><p>而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。</p><p>这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。</p><p>但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。</p><p>因此，从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。之所以举这个例子，只是因为大家肯定都会网购，所以这个例子比较通俗一点。</p><p>哪怕轮询解决不了获取库存这个问题，但只要大家明白了长短轮询的区别，这就足够了。实际上，据LZ自己平日里购物的观察，那个库存量应该是不会变的，这个例子纯属LZ个人的意淫，-_-。</p><h3 id="长短轮询和长短连接的区别"><a href="#长短轮询和长短连接的区别" class="headerlink" title="长短轮询和长短连接的区别"></a>长短轮询和长短连接的区别</h3><p>这里简单说一下它们的区别，LZ这里只说最根本的区别。</p><p>第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。</p><p>第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>好了，本文就到此为止吧。LZ写这篇文章，主要也是为了避免自己遗忘。说实话，写到最后了，LZ感觉对于它们的理解又进了一步，这就是写博客的好处吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引言&lt;/p&gt;
&lt;p&gt;最近刚到公司不到一个月，正处于熟悉项目和源码的阶段，因此最近经常会看一些源码。在研究一个项目的时候，源码里面用到了HTTP的长轮询。由于之前没太接触过，因此LZ便趁着这个机会，好好了解了一下HTTP的长长短短。&lt;/p&gt;
&lt;p&gt;了解的方式主要都是LZ在网络上获取的，这里只是谈一下LZ对于这四种叫法最直观的理解。如果你之前不懂的话，可以帮你普及一下，如果你之前就懂得话，可以互相对照一下。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——父子类的加载执行顺序</title>
    <link href="http://yoursite.com/2019/02/03/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E7%88%B6%E5%AD%90%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/03/JAVA笔记—父子类的加载执行顺序/</id>
    <published>2019-02-03T02:59:26.620Z</published>
    <updated>2019-02-03T03:40:45.233Z</updated>
    
    <content type="html"><![CDATA[<p><strong>类的加载顺序</strong></p><ul><li>（1）父类静态代码块（包括静态初始化块，静态属性，但不包括静态方法）</li><li>（2）子类静态代码块（包括静态初始化块，静态属性，但不包括静态方法）</li><li>（3）父类非静态代码块（包括非静态初始化块，非静态属性）</li><li>（4）父类构造函数</li><li>（5）子类非静态代码块（包括非静态初始化块，非静态属性）</li><li>（6）子类构造函数</li></ul><p><strong>类的执行顺序</strong></p><ul><li>（1）父类静态变量和静态代码块（先声明的先执行）</li><li>（2）子类静态变量和静态代码块（先声明的先执行）</li><li>（3）父类的非静态属性（变量）和非静态代码块（先声明的先执行）</li><li>（4）父类构造函数</li><li>（5）子类的非静态属性（变量）和非静态代码块（先声明的先执行）</li><li>（6）子类构造函数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;类的加载顺序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（1）父类静态代码块（包括静态初始化块，静态属性，但不包括静态方法）&lt;/li&gt;
&lt;li&gt;（2）子类静态代码块（包括静态初始化块，静态属性，但不包括静态方法）&lt;/li&gt;
&lt;li&gt;（3）父类非静态代码块（
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——JVM内存区域划分[转载]</title>
    <link href="http://yoursite.com/2019/01/29/JAVA%E7%AC%94%E8%AE%B0%E2%80%94JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%5B%E8%BD%AC%5D/"/>
    <id>http://yoursite.com/2019/01/29/JAVA笔记—JVM内存区域划分[转]/</id>
    <published>2019-01-29T09:50:32.492Z</published>
    <updated>2019-01-29T12:11:29.954Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到一个JVM的比较有意思的帖子，比较形象生动，此处记录一下。</p><p>JVM内存区域划分Eden Space、Survivor Space、Tenured Gen，Perm Gen解释 - kaixinmao1987 - 博客园<br><a href="https://www.cnblogs.com/kxm87/p/7205414.html" target="_blank" rel="noopener">https://www.cnblogs.com/kxm87/p/7205414.html</a></p><p>[译]GC专家系列1：理解Java垃圾回收 - 牧曦之晨 - SegmentFault 思否<br><a href="https://segmentfault.com/a/1190000004233812" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004233812</a></p><hr><p>jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。<a id="more"></a></p><p>HotSpot虚拟机GC算法采用分代收集算法：</p><p>1、一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。</p><p>2、并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。</p><p>3、进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。</p><p>分区的目的：新生区由于对象产生的比较多并且大都是朝生夕灭的，所以直接采用标记-清理算法。而养老区生命力很强，则采用复制算法，针对不同情况使用不同算法。</p><p>非heap区域中Perm Gen中放着类、方法的定义，jvm Stack区域放着方法参数、局域变量等的引用，方法执行顺序按照栈的先入后出方式。</p><p>以上转自：<a href="http://lhc1986.iteye.com/blog/1421832" target="_blank" rel="noopener">http://lhc1986.iteye.com/blog/1421832</a></p><p>以下转自：<a href="http://www.cnblogs.com/xhr8334/archive/2011/12/01/2270994.html" target="_blank" rel="noopener">http://www.cnblogs.com/xhr8334/archive/2011/12/01/2270994.html</a></p><p>JVM在程序运行过程当中，会创建大量的对象，这些对象，大部分是短周期的对象，小部分是长周期的对象，对于短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉，对于长周期对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测。为解决这种矛盾，Sun JVM的内存管理采用分代的策略。</p><p>​      1）年轻代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）。当对象在堆创建时，将进入年轻代的Eden Space。垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制到Old Gen。同时，在扫描Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个持久化对象，则将其移到Old Gen。扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色（即下次垃圾回收时会扫描Eden Space和BSuvivor Space。这么做主要是为了减少内存碎片的产生。</p><p>​      我们可以看到：Young Gen垃圾回收时，采用将存活对象复制到到空的Suvivor Space的方式来确保尽量不存在内存碎片，采用空间换时间的方式来加速内存中不再被持有的对象尽快能够得到回收。<br>​      2）年老代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。<br>​      3）持久代(Perm Gen)：持久代主要存放类定义、字节码和常量等很少会变更的信息。</p><p><img src="\uploads\JAVA笔记\2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看到一个JVM的比较有意思的帖子，比较形象生动，此处记录一下。&lt;/p&gt;
&lt;p&gt;JVM内存区域划分Eden Space、Survivor Space、Tenured Gen，Perm Gen解释 - kaixinmao1987 - 博客园&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/kxm87/p/7205414.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/kxm87/p/7205414.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[译]GC专家系列1：理解Java垃圾回收 - 牧曦之晨 - SegmentFault 思否&lt;br&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000004233812&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000004233812&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——String中的intern()方法[转载]</title>
    <link href="http://yoursite.com/2019/01/25/JAVA%E7%AC%94%E8%AE%B0%E2%80%94String%E4%B8%AD%E7%9A%84intern()%E6%96%B9%E6%B3%95%5B%E8%BD%AC%5D/"/>
    <id>http://yoursite.com/2019/01/25/JAVA笔记—String中的intern()方法[转]/</id>
    <published>2019-01-24T17:38:42.684Z</published>
    <updated>2019-01-29T12:11:03.593Z</updated>
    
    <content type="html"><![CDATA[<p>文章是转载的网上一篇博客，感觉写的比较清楚</p><p>对String中intern()方法的认识 - 董_不懂的博客 - CSDN博客<br><a href="https://blog.csdn.net/believesoul/article/details/79588305" target="_blank" rel="noopener">https://blog.csdn.net/believesoul/article/details/79588305</a></p><hr><p>最近在看字符串相关知识的时候，又看到了关于字符串创建方式和是否相等的相关问题，回忆起之前碰到的一个String中的intern()方法，它是一个本地方法（由Java语言外的语言编写），因此在jdk1.8源码中没有其实现，不过有一段描述，讲述了它的作用。<br>intern()方法的描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment"> * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment"> * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment"> * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment"> * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment"> * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java™ Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment"> *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>归纳一下的话，它的作用在<strong>jdk1.7之后</strong>是查看常量池中是否存在和调用方法的字符串内容一样的字符串，如果有的话，就返回该常量池中的字符串，若没有的话，就在常量池中写入一个堆中该字符串对象的一个引用，指向堆中的该对象，并返回该引用。<br>用代码说话吧，注释中有我对intern()方法的理解，过程中查阅了部分源码和相关博客，如果有谬误，请大家指出，互相交流学习，共同进步。 </p><p><strong>intern方法的测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        <span class="comment">// 第一次，创建了两个对象，一个是堆中的string对象，一个是常量池中的"abc"</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        <span class="comment">// 第二次，创建一个对象，堆中的另外一个string对象</span></span><br><span class="line">        System.out.println(a.intern() == b.intern());<span class="comment">// true</span></span><br><span class="line">        System.out.println(a.intern() == b);<span class="comment">// false</span></span><br><span class="line">        System.out.println(a.intern() == a);<span class="comment">// false</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * intern方法会到常量池中查找是否存在该对象，如果存在，返回该对象。不存在的话就创建该对象并返回该对象(jdk1.6),(jdk1.7)</span></span><br><span class="line"><span class="comment">         * 会在常量池中存一个指向堆中的那个对象的引用。 不存在往往是String s3 = new String("1") + new</span></span><br><span class="line"><span class="comment">         * String("1");这种形式，会在堆中有一个s3指向的11的对象和常量池中的1对象</span></span><br><span class="line"><span class="comment">         * 在这里就是体现的堆中的内存地址不一样，但对应的同一个常量池中的string 第一个比较时常量池中的该对象和自身比较</span></span><br><span class="line"><span class="comment">         * 下面两个比较则是常量池中的对象和堆中的两个对象进行比较</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String poolstr = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">// 直接从字符串常量池中获取</span></span><br><span class="line">        System.out.println(a.intern() == poolstr);<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.intern() == poolstr);<span class="comment">// true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里新声明并赋值了一个poolstr，值为常量池中的字符串"abc",将它和a.intern()和b.inten()比较就是和自身比较</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">        System.out.println(str.intern() == str);<span class="comment">// true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * str创建了3个对象，在堆中有一个"ab"，在常量池中有一个"a"和"b" 比较str.intern()和str会得到true</span></span><br><span class="line"><span class="comment">         * 在jdk1.7之后，会在常量池中存一个指向堆中的那个对象的引用。</span></span><br><span class="line"><span class="comment">         * 调用str.intern()会在常量池中存储一个指向堆中"ab"的引用，也就是说它和堆中的对象实际是等价的，因此==时返回true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String strtwo = <span class="string">"ab"</span>;</span><br><span class="line">        System.out.println(strtwo == str);<span class="comment">// true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 常量池中已存在ab，所以会直接将strtwo指向常量池中的"ab",即堆中str对象的引用，因此相等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有提到一个new String（“”）会创建几个对象，一般就是一个或两个，主要是看常量池中是否已经有了该字符串，在上述代码在也有所提及。<br>对于每一个比较语句我都做了自己的理解的标注，比较通俗易懂，仔细看一下就能理解intern方法的作用，另外附上一篇博文，是一篇讲述intern方法的实现原理的博文，对我理解intern方法有很大帮助，感兴趣的朋友可以看一下。<br>Java技术——你真的了解String类的intern()方法吗<br>其中提到了jdk1.7将常量池从方法区中转移到堆中对intern()方法的影响，非常清晰的描述了差别，配合本博文实例更适宜使用，本博文更多的从实现角度来解析intern()方法，希望对您有所帮助<br>如有谬误，敬请指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章是转载的网上一篇博客，感觉写的比较清楚&lt;/p&gt;
&lt;p&gt;对String中intern()方法的认识 - 董_不懂的博客 - CSDN博客&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/believesoul/article/details/79588305&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/believesoul/article/details/79588305&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最近在看字符串相关知识的时候，又看到了关于字符串创建方式和是否相等的相关问题，回忆起之前碰到的一个String中的intern()方法，它是一个本地方法（由Java语言外的语言编写），因此在jdk1.8源码中没有其实现，不过有一段描述，讲述了它的作用。&lt;br&gt;intern()方法的描述&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Returns a canonical representation for the string object.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * A pool of strings, initially empty, is maintained privately by the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * class &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; String&amp;#125;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * When the intern method is invoked, if the pool already contains a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * string equal to this &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; String&amp;#125; object as determined by&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * the &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; #equals(Object)&amp;#125; method, then the string from the pool is&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * returned. Otherwise, this &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; String&amp;#125; object is added to the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * pool and a reference to this &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; String&amp;#125; object is returned.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * It follows that for any two strings &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; s&amp;#125; and &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; t&amp;#125;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; s.intern() == t.intern()&amp;#125; is &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; true&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * if and only if &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; s.equals(t)&amp;#125; is &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; true&amp;#125;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * All literal strings and string-valued constant expressions are&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * interned. String literals are defined in section 3.10.5 of the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;cite&amp;gt;The Java™ Language Specification&amp;lt;/cite&amp;gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;  a string that has the same contents as this string, but is&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *          guaranteed to be from a pool of unique strings.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;intern&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="常量池" scheme="http://yoursite.com/tags/%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ在windows配置安装</title>
    <link href="http://yoursite.com/2019/01/11/RocketMQ%E5%9C%A8windows%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/01/11/RocketMQ在windows配置安装/</id>
    <published>2019-01-11T05:37:22.000Z</published>
    <updated>2019-01-11T05:44:31.849Z</updated>
    
    <content type="html"><![CDATA[<p>配置过程不麻烦，就是有点小插曲</p><p>教程参考： <a href="https://yq.aliyun.com/articles/656078" target="_blank" rel="noopener">https://yq.aliyun.com/articles/656078</a>   </p><p>​           <a href="https://www.jianshu.com/p/4a275e779afa" target="_blank" rel="noopener">https://www.jianshu.com/p/4a275e779afa</a></p><p><strong>注意：</strong>过程中需要对JVM configuration 修改一下 内存 ： 修改<strong>runserver.sh</strong>和<strong>runbroker.sh</strong>，两个分别对应nameserver和broker的配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="string">"JAVA_OPT=%JAVA_OPT% -server -Xms2g -Xmx2g -Xmn1g"</span></span><br></pre></td></tr></table></figure><p>另外 如果启动broker出现找不到XXXXX主类的错误，把 %CLASSPATH% 加上双引号，修改为 “%CLASSPATH%” 就可以了</p><p><a href="https://blog.csdn.net/lvwenzhuye/article/details/81483479" target="_blank" rel="noopener">https://blog.csdn.net/lvwenzhuye/article/details/81483479</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;配置过程不麻烦，就是有点小插曲&lt;/p&gt;
&lt;p&gt;教程参考： &lt;a href=&quot;https://yq.aliyun.com/articles/656078&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://yq.aliyun.com/article
      
    
    </summary>
    
      <category term="RocketMQ" scheme="http://yoursite.com/categories/RocketMQ/"/>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>大数据——hashMap put函数 重复插入相同(key,value)的问题</title>
    <link href="http://yoursite.com/2018/12/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94hashMap%E7%9A%84put%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/12/28/大数据——hashMap的put重复插入问题/</id>
    <published>2018-12-27T16:31:26.088Z</published>
    <updated>2018-12-27T16:42:56.566Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">writer = SequenceFile.createWriter(fs, conf, path, key.getClass(), value.getClass());</span><br><span class="line"><span class="keyword">for</span>(File dir:dirs)&#123;</span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line"><span class="comment">//key：目录名+":"+文件名</span></span><br><span class="line">key.set(dir.getName() + <span class="string">":"</span> + file.getName());</span><br><span class="line"><span class="comment">//value：文件内容</span></span><br><span class="line">value.set(fileToString(file));</span><br><span class="line">fileContents.put(key, value); <span class="comment">//////////////////////////A</span></span><br><span class="line">fileContents.put(<span class="keyword">new</span> Text(dir.getName() + <span class="string">":"</span> + file.getName()), <span class="keyword">new</span> Text(fileToString(file))); <span class="comment">/////////////////////////////B</span></span><br><span class="line">writer.append(key, value);</span><br><span class="line"><span class="comment">//System.out.println(key + "\t" + value);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">IOUtils.closeStream(writer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天做基于hadoop的朴素贝叶斯文档分类时，遇到一个问题：注意代码块中的A和B，最开始使用A时我发现hashMap内存储的都是同一个(key，value)对，改成B就可以了，目测应该是key和value对数据引用后，修改key和value导致hash值变化了。</p><p>具体类比资料：hashmap出现重复key的情况 - qq_29909965的博客 - CSDN博客<br><a href="https://blog.csdn.net/qq_29909965/article/details/78358066" target="_blank" rel="noopener">https://blog.csdn.net/qq_29909965/article/details/78358066</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——类的访问权限</title>
    <link href="http://yoursite.com/2018/12/17/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2018/12/17/JAVA笔记—类的访问权限/</id>
    <published>2018-12-17T01:35:12.815Z</published>
    <updated>2018-12-17T01:38:50.758Z</updated>
    
    <content type="html"><![CDATA[<p><img src="\uploads\JAVA笔记\1.png" alt="1"></p><p>如果一个类的成员没有任何权限修饰，那么它门就是缺省包访问权限，用friendly来表示，注意friendly不是Java中的关键字，这里是个人喜欢的方式用它表示而已。同一个包内其它类可以访问，但包外就不可以。对于同一个文件夹下的、没有用package的classes，Java会自动将这些classes初见为隶属于该目录的default package，可以相互调用class中的friendly成员。</p><p>如以下两个class分别在同一个文件夹的两个文件中，虽然没有引入package，但隶属于相同的default package。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sundae</span></span>&#123;</span><br><span class="line">　　 <span class="comment">//以下两个方法缺省为friendly</span></span><br><span class="line">　　 Sundae()&#123;&#125;</span><br><span class="line">　　 <span class="function">Void <span class="title">f</span><span class="params">()</span> </span>&#123;System.out.println(“Sundae.f()”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">　　 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　 Sundae x = <span class="keyword">new</span> Sundae();</span><br><span class="line">　　 x.f();</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类来说：同一个包中的类可以用。总之，类只可以声明为public或者friendly。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;\uploads\JAVA笔记\1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果一个类的成员没有任何权限修饰，那么它门就是缺省包访问权限，用friendly来表示，注意friendly不是Java中的关键字，这里是个人喜欢的方式用它表示而已。同一个包内
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————9.回文数</title>
    <link href="http://yoursite.com/2018/12/16/LeetCode%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://yoursite.com/2018/12/16/LeetCode——回文数/</id>
    <published>2018-12-16T06:50:22.000Z</published>
    <updated>2018-12-16T08:07:43.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（简单）"><a href="#题目（简单）" class="headerlink" title="题目（简单）"></a><strong>题目（简单）</strong></h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p>输入: 10</p><p>输出: false</p><p>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h4 id="方法：反转一半数字"><a href="#方法：反转一半数字" class="headerlink" title="方法：反转一半数字"></a>方法：反转一半数字</h4><p><strong>思路</strong></p><p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p><p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。 但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。</p><p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><p>例如，输入 <code>1221</code>，我们可以将数字“12<strong>21</strong>”的后半部分从“<strong>21</strong>”反转为“<strong>12</strong>”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 <code>1221</code> 是回文。</p><p>让我们看看如何将这个想法转化为一个算法。</p><p><strong>算法</strong></p><p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 <code>-</code> 不等于 <code>3</code>。所以我们可以对所有负数返回 false。</p><p>现在，让我们来考虑如何反转后半部分的数字。 对于数字 <code>1221</code>，如果执行 <code>1221 % 10</code>，我们将得到最后一位数字 <code>1</code>，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 <code>1221</code> 中移除，<code>1221 / 10 = 122</code>，再求出上一步结果除以10的余数，<code>122 % 10 = 2</code>，就可以得到倒数第二位数字。如果我们把最后一位数字乘以10，再加上倒数第二位数字，<code>1 * 10 + 2 = 12</code>，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。</p><p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> bool <span class="title">IsPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log<sub>10</sub>(n)， 对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(log<sub>10</sub>(n)。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目（简单）&quot;&gt;&lt;a href=&quot;#题目（简单）&quot; class=&quot;headerlink&quot; title=&quot;题目（简单）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（简单）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————7.整数反转</title>
    <link href="http://yoursite.com/2018/12/07/LeetCode%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/12/07/LeetCode——整数反转/</id>
    <published>2018-12-06T16:37:22.000Z</published>
    <updated>2018-12-06T17:42:55.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（简单）"><a href="#题目（简单）" class="headerlink" title="题目（简单）"></a><strong>题目（简单）</strong></h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，<strong>如果反转后整数溢出那么就返回 0。</strong><a id="more"></a></p><hr><p>题目很明确，很自然的想法就是通过除法和取余逐位取出，再依次乘10加余数达到反向效果，但是也有一点就是<strong>做乘法时可能会出现溢出的情况</strong>。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>反转整数的方法可以与反转字符串进行类比。</p><p>我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。</p><p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop operation:</span></span><br><span class="line">pop = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push operation:</span></span><br><span class="line">temp = rev * <span class="number">10</span> + pop;</span><br><span class="line">rev = temp;</span><br></pre></td></tr></table></figure><p>但是，这种方法很危险，因为当 temp=rev⋅10+pop 时会导致溢出。</p><p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p><p>为了便于解释，我们假设 rev 是正数。</p><p><img src="\uploads\LeetCode\2.png" alt="2"></p><p>这里要补充两点：</p><p>1.显然因为top只能是处于0~9的个位数字，所以若rev·10+top溢出，那么rev&gt;=INTMAX/10必然成立。</p><p>2.若rev==INTMAX/10，若pop&gt;7(假设为8)，那么反转前肯定是8xxxxxxxx，显然超出了Int的范围，所以top&lt;=7一定成立的。</p><p>当 rev 为负时可以应用类似的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> X =x;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">X = -x;</span><br><span class="line"><span class="keyword">int</span> rev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(X&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> end = X%<span class="number">10</span>;</span><br><span class="line">        X = X/<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(rev&gt;<span class="number">214748364</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rev = rev*<span class="number">10</span>+end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">        rev = -rev;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE/<span class="number">10</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE/<span class="number">10</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(log<sub>10</sub>(n))，因为每次都通过除以10取出尾数位。</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（简单）&quot;&gt;&lt;a href=&quot;#题目（简单）&quot; class=&quot;headerlink&quot; title=&quot;题目（简单）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（简单）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; &lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: -123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，&lt;strong&gt;如果反转后整数溢出那么就返回 0。&lt;/strong&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————5.最长回文子串(常考)</title>
    <link href="http://yoursite.com/2018/12/06/LeetCode%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/12/06/LeetCode——最长回文子串/</id>
    <published>2018-12-06T09:37:22.000Z</published>
    <updated>2018-12-06T15:41:19.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（中等）"><a href="#题目（中等）" class="headerlink" title="题目（中等）"></a><strong>题目（中等）</strong></h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><a id="more"></a> <hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><h3 id="1-最大公共子串法"><a href="#1-最大公共子串法" class="headerlink" title="1.最大公共子串法"></a>1.最大公共子串法</h3><p>第一个比较容易的想法可能就是 把字符串S反转过来，记为S’，先使用<strong>动态规划方法</strong>找到S与S’之间的最长公共子串，即所求的最长回文子串。</p><p>例如，S = “caba” , S’ = “abac”, S 以及 S’ 之间的最长公共子串为 “aba”，恰恰是答案。</p><p>让我们尝试一下这个例子：S = “abacdfgdcaba” , S’ = “abacdgfdcaba”, S 以及 S’之间的最长公共子串为 “abacd”，显然，这不是回文。</p><p>我们可以看到，当 S 的其他部分中存在非回文子串的反向副本时(即例子中的abacd和dcaba)，最长公共子串法就会失败。为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要<strong>检查子串的索引是否与反向子串的原始索引相同</strong>。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。</p><p>这里要解释一下上面加粗的那句，即判断条件，比如”caba”这个串，反转找到的最长公共子串是”aba”，它在”cab<strong>a</strong>“的结束索引为<strong>3</strong>（不是1是因为最长公共子串找到的索引是<strong>结束索引</strong>）；在反向串”ab<strong>a</strong>c”中的<strong>结束索引</strong>为<strong>2</strong>，我们要找的<strong>原始索引</strong>就是在反向串中的<strong>反向索引</strong>，即”aba”的<strong>开始索引</strong>（串长 4-1-<strong>结束索引2</strong>=4-1-2=<strong>1</strong>）加上该最大公共子串长度3再减1（即<strong>1</strong>+3-1=<strong>3</strong>）因为反向索引<strong>3</strong>和原串的索引<strong>3</strong>相等，所以认定这是个回文串，而不是反向副本；再比如”abacdfgdcaba”，找到的公共子串”abacd”的<strong>结束索引</strong>为<strong>4</strong>，<strong>开始索引</strong>=12-1-4=7，又因为最大公共子串长为5，所以反向串中的<strong>原始索引</strong>就为7+5-1=11，这与原串的结束索引4不等，所以这是个反向副本，而不是回文数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line">   <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        String s1 = s;</span><br><span class="line">        String s2 = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">        String str=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l1 = s1.length();</span><br><span class="line"><span class="keyword">int</span> l2 = s2.length();</span><br><span class="line"><span class="keyword">int</span> max_index1[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">int</span> max_index2[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> array[][] = <span class="keyword">new</span> <span class="keyword">int</span>[l1][l2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;s.length();++t)</span><br><span class="line">&#123;</span><br><span class="line">max_index1[t] = -<span class="number">1</span>;</span><br><span class="line">max_index2[t] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;l2;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">array[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">array[i][j] = array[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(array[i][j] &gt; max_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r_index2 = s.length()-j-<span class="number">1</span>;  <span class="comment">//判断是否是回文而不是反向副本</span></span><br><span class="line"><span class="keyword">if</span>(i == r_index2+array[i][j]-<span class="number">1</span>)  <span class="comment">//判断是否是回文而不是反向副本</span></span><br><span class="line">&#123;</span><br><span class="line">max_len = array[i][j];</span><br><span class="line">max_index1[<span class="number">0</span>] = i;</span><br><span class="line">max_index2[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;s.length();++t)</span><br><span class="line">&#123;</span><br><span class="line">max_index1[t] = -<span class="number">1</span>;</span><br><span class="line">max_index2[t] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">array[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(max_index1[<span class="number">0</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">str = (s1.substring(max_index1[<span class="number">0</span>]-max_len+<span class="number">1</span>,max_index1[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line">System.out.print(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：因为是动态规划，所以是O(n<sup>2</sup>)。</p><p>空间复杂度：因为用了空间换时间，所以是O(n<sup>2</sup>)。其实还可以通过<strong>把Array二维数组转换为一维</strong>，因为每次循环都是固定i，内部循环j，而第3行的数据其实只用到之前第2行的数据，不需要第1行的，所以每次用一维数组重复利用，做数据更新就可以了。这样空间复杂度就缩小到了O(n)。</p><h3 id="2-暴力法"><a href="#2-暴力法" class="headerlink" title="2.暴力法"></a>2.暴力法</h3><p>很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。但是暴力法面对比如”zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz”这样的超长回文串，就会因为时间开销太大而超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_index = -<span class="number">1</span>;</span><br><span class="line">String str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> start = i,end = j;</span><br><span class="line"><span class="keyword">while</span>(s.charAt(start) == s.charAt(end))</span><br><span class="line">&#123;</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line"><span class="keyword">if</span>(end&lt;<span class="number">0</span> || start&gt;s.length()-<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(start &gt;= end &amp;&amp; j-i+<span class="number">1</span> &gt; max_len)</span><br><span class="line">&#123;</span><br><span class="line">max_len = j-i+<span class="number">1</span>;</span><br><span class="line">max_index = j;</span><br><span class="line">str = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n<sup>3</sup>)，因为要进行N<em>N的循环，每次循环还要遍历根据初始位置start和结束位置end找出的子串判断是否是回文串，所以为N </em> N * N。</p><p>空间复杂度：O(1)</p><h3 id="3-动态规划法"><a href="#3-动态规划法" class="headerlink" title="3.动态规划法"></a>3.动态规划法</h3><p>为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，“ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。</p><p>我们给出 P(i,j) 的定义如下：</p><p><img src="\uploads\LeetCode\1.png" alt="1"></p><p>基本示例如下：</p><p>P(i, i) = true</p><p>P(i, i+1) = (Si==Si+1)</p><p>这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len[]=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">//记录是否为回文串，不是就记为0，是的就记录回文串长度</span></span><br><span class="line"><span class="keyword">int</span> max_len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_index=<span class="number">0</span>;</span><br><span class="line">String str=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()-<span class="number">1</span>;j&gt;=i;--j)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(i == j)  <span class="comment">//边界（奇数）</span></span><br><span class="line">   len[j] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(Math.abs(i-j)==<span class="number">1</span>) <span class="comment">//边界（偶数）</span></span><br><span class="line">   &#123;</span><br><span class="line">   len[j] = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   len[j] = len[j-<span class="number">1</span>]==<span class="number">0</span>? <span class="number">0</span>:len[j-<span class="number">1</span>]+<span class="number">2</span>;  <span class="comment">//判断内部子串是不是回文串，不是为false，是的就记录回文串长度</span></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   len[j] = <span class="number">0</span>;  <span class="comment">//不是回文串</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(len[j]&gt;max_len)</span><br><span class="line">   &#123;</span><br><span class="line">   max_len = len[j];</span><br><span class="line">   max_index = j;</span><br><span class="line">   str = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n<sup>2</sup>)</p><p>空间复杂度：正常情况下是O(n<sup>2</sup>)， 因为动态规划方法使用 O(n<sup>2</sup>)的空间来存储表。同样的，这个空间复杂度可以优化到<strong>O(n)</strong>，<strong>空间复杂度：O(n^2)O(n2)， 该方法使用 O(n^2)O(n2) 的空间来存储表。</strong></p><h3 id="4-中心扩展法"><a href="#4-中心扩展法" class="headerlink" title="4.中心扩展法"></a>4.中心扩展法</h3><p>事实上，只需使用恒定的空间，我们就可以在 O(n<sup>2</sup>) 的时间内解决这个问题。</p><p>我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。</p><p>你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个 ‘b’ 之间）。所以找奇数长度的回文串时可以遍历n个中心（也就是n个字符均作为一次中心），找偶数长度回文串时可以遍历n-1个中心（也就是n个字符之间的空隙均作为一次中心），加起来就是n+n-1=2n-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len=<span class="number">0</span>,length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start=-<span class="number">1</span>,end=-<span class="number">1</span>;</span><br><span class="line">String str=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = expandAroundCenter(s,i,i);</span><br><span class="line"><span class="keyword">int</span> len2 = expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">length = (len1&gt;len2)?len1:len2;</span><br><span class="line"><span class="keyword">if</span>(length&gt;max_len)</span><br><span class="line">&#123;</span><br><span class="line">max_len = length;</span><br><span class="line">start = i-((length+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>);</span><br><span class="line">end = start+length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str = s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>  <span class="comment">//从left/right的中心开始扩展</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L=left,R=right;</span><br><span class="line"><span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;=s.length()-<span class="number">1</span> &amp;&amp; s.charAt(L)==s.charAt(R))</span><br><span class="line">&#123;</span><br><span class="line">L--;</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> R-L-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n<sup>2</sup>)， 由于围绕中心来扩展回文会耗去 O(n) 的时间，所以总的复杂度为 O(n<sup>2</sup>)。</li><li>空间复杂度：O(1)。 </li></ul><h3 id="5-Manacher-马拉车算法"><a href="#5-Manacher-马拉车算法" class="headerlink" title="5.Manacher 马拉车算法"></a>5.Manacher 马拉车算法</h3><p>这个算法比较复杂，可以把时间复杂度和空闲复杂度都缩减到O(n)，建议多查看一些资料，此处不做叙述。</p><p>参考资料：Longest Palindromic Substring Part II – LeetCode</p><p><a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="noopener">https://articles.leetcode.com/longest-palindromic-substring-part-ii/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（中等）&quot;&gt;&lt;a href=&quot;#题目（中等）&quot; class=&quot;headerlink&quot; title=&quot;题目（中等）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（中等）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入: “babad”&lt;br&gt;输出: “bab”&lt;br&gt;注意: “aba” 也是一个有效答案。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入: “cbbd”&lt;br&gt;输出: “bb”&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="中等题型" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大数据————淘宝双十一项目实战</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E6%B7%98%E5%AE%9D%E5%8F%8C%E5%8D%81%E4%B8%80%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2018/12/04/大数据——淘宝双十一项目实战/</id>
    <published>2018-12-04T14:30:55.498Z</published>
    <updated>2018-12-04T15:15:48.930Z</updated>
    
    <content type="html"><![CDATA[<p>今天完成了一个基于淘宝双十一交易数据的大数据分析实战项目，这里稍作记录。</p><p>教程：淘宝双11数据分析与预测课程案例：厦大数据库实验室博客  <a href="http://dblab.xmu.edu.cn/blog/1362-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/1362-2/</a></p><p>项目和文档：<a href="https://github.com/JayZeed/taobao11" target="_blank" rel="noopener">https://github.com/JayZeed/taobao11</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天完成了一个基于淘宝双十一交易数据的大数据分析实战项目，这里稍作记录。&lt;/p&gt;
&lt;p&gt;教程：淘宝双11数据分析与预测课程案例：厦大数据库实验室博客  &lt;a href=&quot;http://dblab.xmu.edu.cn/blog/1362-2/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据————Ubuntu14.04 Echarts图例设置后不显示</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20Echarts%E5%9B%BE%E4%BE%8B%E8%AE%BE%E7%BD%AE%E5%90%8E%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/12/04/大数据——Ubuntu14.04 Echarts图例设置后不显示/</id>
    <published>2018-12-04T14:12:42.035Z</published>
    <updated>2018-12-04T15:15:35.005Z</updated>
    
    <content type="html"><![CDATA[<p>Echarts是用于前端数据可视化的一个工具。可以把数据以各种图表方式显示出来。</p><p>最近做一个大数据项目时，通过Echarts做了一个柱状图，但是设置了的图例一直不能显示出来。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">        x: <span class="string">'center'</span>,</span><br><span class="line">        data:[<span class="string">'销量'</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>红框内就是图例：</p><p><img src="\uploads\大数据——Echarts图例\1.png" alt="图例"></p><p>查了一些资料才知道原来<strong>需要series中的name和legend的data一致</strong>，这样才能显示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">    x: <span class="string">'center'</span>,</span><br><span class="line">    data:[<span class="string">'销量'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">series : [</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">'销量'</span>,</span><br><span class="line">        type:<span class="string">'bar'</span>,</span><br><span class="line">        barWidth: <span class="string">'60%'</span>,</span><br><span class="line">        data:y</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果想设置图例颜色，可以在option里设置 color : […] 实现。</p><p>参考资料：echarts柱状图图例不显示的问题 - royal1235的博客 - CSDN博客<br><a href="https://blog.csdn.net/royal1235/article/details/80746278" target="_blank" rel="noopener">https://blog.csdn.net/royal1235/article/details/80746278</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Echarts是用于前端数据可视化的一个工具。可以把数据以各种图表方式显示出来。&lt;/p&gt;
&lt;p&gt;最近做一个大数据项目时，通过Echarts做了一个柱状图，但是设置了的图例一直不能显示出来。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据————Ubuntu14.04 JavaScript array保存object对象出错</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20JavaScript%20array%E4%BF%9D%E5%AD%98object%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/12/04/大数据——Ubuntu14.04 JavaScript array保存object对象/</id>
    <published>2018-12-04T12:46:46.249Z</published>
    <updated>2018-12-04T14:32:14.632Z</updated>
    
    <content type="html"><![CDATA[<p>用JSP开发WEB应用时用到了javascript语言，其中想在数组保存object对象时出了点小问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydata=[];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> obj =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="xml"><span class="tag">&lt;<span class="name">%=a[0]%</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">mydata.push(obj);</span></span><br></pre></td></tr></table></figure><p>这里我想将obj用数组存起来，发现存储失败了，控制台调试发现报错：ReferenceError: 台湾 is not defined （这里台湾是&lt;%=a[0]%&gt;得到的值）大概意思是把台湾作为变量了，而不是一个值。<a id="more"></a></p><p>因为&lt;%=a[0]%&gt;表示取得a[0]的值，那么 obj.name = &lt;%=a[0]%&gt;; 就相当于 obj.name = 台湾; 确实会被理解成变量名，而我们需要的应该是 obj.name = “台湾” ; </p><p>所以只需要改成 obj.name = “&lt;%=a[0]%&gt;”; 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用JSP开发WEB应用时用到了javascript语言，其中想在数组保存object对象时出了点小问题。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mydata=[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.name = &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;%=a[0]%&lt;/span&gt;&amp;gt;&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;mydata.push(obj);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里我想将obj用数组存起来，发现存储失败了，控制台调试发现报错：ReferenceError: 台湾 is not defined （这里台湾是&amp;lt;%=a[0]%&amp;gt;得到的值）大概意思是把台湾作为变量了，而不是一个值。
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据——Ubuntu14.04 使用Sqoop将数据从Hive导入MySQL出错</title>
    <link href="http://yoursite.com/2018/11/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20%E4%BD%BF%E7%94%A8Sqoop%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8EHive%E5%AF%BC%E5%85%A5Mysql%E5%87%BA%E9%94%99/"/>
    <id>http://yoursite.com/2018/11/29/大数据——Ubuntu14.04 使用Sqoop将数据从Hive导入Mysql出错/</id>
    <published>2018-11-29T13:24:27.585Z</published>
    <updated>2018-11-29T13:45:45.570Z</updated>
    
    <content type="html"><![CDATA[<p>在基于大数据双十一用户行为统计与分析实验中 进行导入数据操作时：</p><p>(4)导入数据(执行时间：20秒左右)<br>注意，刚才已经退出MySQL，回到了Shell命令提示符状态。下面就可以执行数据导入操作</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/sqoop</span><br><span class="line">bin/sqoop export --connect jdbc:mysql://localhost:3306/dbtaobao --username root --password root --table user_log --export-dir '/user/hive/warehouse/dbtaobao.db/inner_user_log' --fields-terminated-by ',';</span><br></pre></td></tr></table></figure><p>执行<strong>错误提示</strong>如下：</p><p>18/11/29 05:20:45 <strong>ERROR manager.SqlManager:</strong> <strong>Error executing statement: java.sql.SQLException: Access denied for user ‘root‘@’localhost’ (using password: YES)</strong><br>java.sql.SQLException: Access denied for user ‘root‘@’localhost’ (using password: YES)<br>​    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:965)<br>​    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3978)<br>​    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3914)<br>​    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:871)<br>​    at com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1714)<br>​    at com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1224)<br>​    at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2199)<br>​    at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2230)<br>​    at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2025)<br>​    at com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:778)<br>​    at com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:47)<br>​    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)<br>​    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)<br>​    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)<br>​    at java.lang.reflect.Constructor.newInstance(Constructor.java:526)<br>​    at com.mysql.jdbc.Util.handleNewInstance(Util.java:425)<br>​    at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:386)<br>​    at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:330)<br>​    at java.sql.DriverManager.getConnection(DriverManager.java:571)<br>​    at java.sql.DriverManager.getConnection(DriverManager.java:215)<br>​    at org.apache.sqoop.manager.SqlManager.makeConnection(SqlManager.java:904)<br>​    at org.apache.sqoop.manager.GenericJdbcManager.getConnection(GenericJdbcManager.java:59)<br>​    at org.apache.sqoop.manager.SqlManager.execute(SqlManager.java:763)<br>​    at org.apache.sqoop.manager.SqlManager.execute(SqlManager.java:786)<br>​    at org.apache.sqoop.manager.SqlManager.getColumnInfoForRawQuery(SqlManager.java:289)<br>​    at org.apache.sqoop.manager.SqlManager.getColumnTypesForRawQuery(SqlManager.java:260)<br>​    at org.apache.sqoop.manager.SqlManager.getColumnTypes(SqlManager.java:246)<br>​    at org.apache.sqoop.manager.ConnManager.getColumnTypes(ConnManager.java:327)<br>​    at org.apache.sqoop.orm.ClassWriter.getColumnTypes(ClassWriter.java:1872)<br>​    at org.apache.sqoop.orm.ClassWriter.generate(ClassWriter.java:1671)<br>​    at org.apache.sqoop.tool.CodeGenTool.generateORM(CodeGenTool.java:106)<br>​    at org.apache.sqoop.tool.ExportTool.exportTable(ExportTool.java:63)<br>​    at org.apache.sqoop.tool.ExportTool.run(ExportTool.java:99)<br>​    at org.apache.sqoop.Sqoop.run(Sqoop.java:147)<br>​    at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:70)<br>​    at org.apache.sqoop.Sqoop.runSqoop(Sqoop.java:183)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:234)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:243)<br>​    at org.apache.sqoop.Sqoop.main(Sqoop.java:252)<br>18/11/29 05:20:45 ERROR tool.ExportTool: Encountered IOException running export job:<br>java.io.IOException: No columns to generate for ClassWriter<br>​    at org.apache.sqoop.orm.ClassWriter.generate(ClassWriter.java:1677)<br>​    at org.apache.sqoop.tool.CodeGenTool.generateORM(CodeGenTool.java:106)<br>​    at org.apache.sqoop.tool.ExportTool.exportTable(ExportTool.java:63)<br>​    at org.apache.sqoop.tool.ExportTool.run(ExportTool.java:99)<br>​    at org.apache.sqoop.Sqoop.run(Sqoop.java:147)<br>​    at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:70)<br>​    at org.apache.sqoop.Sqoop.runSqoop(Sqoop.java:183)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:234)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:243)<br>​    at org.apache.sqoop.Sqoop.main(Sqoop.java:252)</init></init></p><p>出现这个错误，第一反应是当前用户对于Mysql的权限不够，于是第一反应去修改权限：</p><p>先进入mysql shell:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -u root -p</span></span><br></pre></td></tr></table></figure><p>然后修改权限(第一个root表示用户，第二个root表示密码)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> grant all privileges on *.* to root@localhost identified by <span class="string">'root'</span>;</span></span><br></pre></td></tr></table></figure><p>最好刷新一下权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> flush privileges;</span></span><br></pre></td></tr></table></figure><p>经过尝试之后我发现  并 没 有 卵 用</p><p>那么问题肯定不是这个，仔细看了一遍该export指令的参数:</p><p><strong>字段解释：</strong></p><p>./bin/sqoop export ##表示数据从 hive 复制到 mysql 中<br>–connect jdbc:mysql://localhost:3306/dbtaobao<br>–username root #mysql登陆用户名<br>–password root #登录密码<br>–table user_log #mysql 中的表，即将被导入的表名称<br>–export-dir ‘/user/hive/warehouse/dbtaobao.db/user_log ‘ #hive 中被导出的文件<br>–fields-terminated-by ‘,’ #Hive 中被导出的文件字段的分隔符</p><p>我发现：password错了。。。</p><p>修改之后就正常执行了。。。下次一定要注意参数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在基于大数据双十一用户行为统计与分析实验中 进行导入数据操作时：&lt;/p&gt;
&lt;p&gt;(4)导入数据(执行时间：20秒左右)&lt;br&gt;注意，刚才已经退出MySQL，回到了Shell命令提示符状态。下面就可以执行数据导入操作&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>大数据——Ubuntu14.04 安装mysql</title>
    <link href="http://yoursite.com/2018/11/27/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%E5%AE%89%E8%A3%85mysql/"/>
    <id>http://yoursite.com/2018/11/27/大数据——Ubuntu14.04安装mysql/</id>
    <published>2018-11-27T15:35:14.133Z</published>
    <updated>2018-11-28T02:13:13.039Z</updated>
    
    <content type="html"><![CDATA[<p>今天用Ubuntu安装mysql遇到了几个小坑，记录一下帮助更多的人避坑。</p><p><strong>安装教程：</strong>Ubuntu安装MySQL及常用操作_厦大数据库实验室博客  <a href="http://dblab.xmu.edu.cn/blog/install-mysql/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/install-mysql/</a></p><a id="more"></a><hr><p><strong>1.mysql安装后找不到</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server  #安装mysql</span><br></pre></td></tr></table></figure><p>上述语句执行后，执行 <strong>service mysql start</strong> 出现找不到mysql情况，使用 <strong>sudo netstat -tap | grep mysql</strong> 也不能找到mysql，后来添加了两条指令，总共三条完成了mysql安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt install mysql-client</span><br><span class="line">sudo apt install libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/itxiaolong3/article/details/77905923" target="_blank" rel="noopener">https://blog.csdn.net/itxiaolong3/article/details/77905923</a></p><p><strong>2.mysqld.cnf找不到</strong></p><p>想修改 <strong>/etc/mysql/mysql.conf.d/mysqld.cnf</strong> 配置文件结果找不到，这个和mysql的版本也有关，我这个5.5版本没有这个文件。</p><p>于是修改了 <strong>/etc/mysql/my.cnf</strong> 文件，该文件配置全局选项。</p><p>/etc/my.cnf    全局选项<br>/etc/mysql/my.cnf    全局选项<br>SYSCONFDIR/my.cnf    全局选项<br>$MYSQL_HOME/my.cnf    服务器特定选项（仅限服务器）<br>defaults-extra-file    指定的文件 –defaults-extra-file，如果有的话<br>~/.my.cnf    用户特定选项<br>~/.mylogin.cnf    用户特定的登录路径选项（仅限客户端）</p><p><strong>3.如果还是出现无法使用service mysql start命令的情况</strong></p><p>可能你的mysql版本有问题，（我按教程自动获取最新版本获取的是5.5的，而课题中需要的是5.7的）</p><p>可以参考该教程自己选择和下载对应版本：<br>请自行尝试，我是先按照下面第二个教程配置到3）、安装mysql－server时解包出错了，一番折腾没有解决，换了第一个，又按顺序解包一遍成功。<br>Ubuntu14.04 下安装离线安装Mysql5.7 - wst878882582的博客 - CSDN博客<br><a href="https://blog.csdn.net/wst878882582/article/details/78457531" target="_blank" rel="noopener">https://blog.csdn.net/wst878882582/article/details/78457531</a></p><p>Ubuntu14.04安装MySQL5.7.20（MySQL最新版本） - qq_34256348的博客 - CSDN博客<br><a href="https://blog.csdn.net/qq_34256348/article/details/78340333" target="_blank" rel="noopener">https://blog.csdn.net/qq_34256348/article/details/78340333</a></p><p><strong>4.ERROR 1146 (42S02): Table ‘performance_schema.session_variables’ doesn’t exist</strong></p><p>使用<strong>show variables like “char%”;</strong>指令时出现该错误</p><p>需要进行<strong>mysql_upgrade</strong>操作进行修复</p><p>1）首先退出mysql</p><p>2）在命令行界面输入：mysql_upgrade -uroot -p –force</p><p>3）然后重启mysql即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天用Ubuntu安装mysql遇到了几个小坑，记录一下帮助更多的人避坑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装教程：&lt;/strong&gt;Ubuntu安装MySQL及常用操作_厦大数据库实验室博客  &lt;a href=&quot;http://dblab.xmu.edu.cn/blog/install-mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dblab.xmu.edu.cn/blog/install-mysql/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————2.两数相加</title>
    <link href="http://yoursite.com/2018/11/27/LeetCode%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2018/11/27/LeetCode——两数相加/</id>
    <published>2018-11-27T02:37:22.000Z</published>
    <updated>2018-12-06T09:12:39.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（中等）"><a href="#题目（中等）" class="headerlink" title="题目（中等）"></a><strong>题目（中等）</strong></h2><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。</p><a id="more"></a> <p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>输入：</p><p>[2,4,3]</p><p>[5,6,4]</p><p>输出：</p><p>[7,0,8]</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>用了最直接暴力的解法，先把两个链表的各个位提出来，恢复成int类型的数，然后相加，再讲相加的和保存为String类型，通过下标遍历String各位，从而建立一个新的输出链表。</p><p>该方法最大的问题就是<strong>溢出</strong>！虽然我写的时候已经注意到会这样，不过还是尝试了一下，果然无法accept。因为<strong>两个数相加可能超出int表示范围</strong>，这时候就溢出了，尽管后面用String保存也没有什么用，显然不可取。</p><p>所以相应地我想到可以把相加的两个数用String表示，然后逐位相加，这其实就和官方解答类似了。</p><h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a><strong>官方解法</strong></h3><p>其实官方解法很容易想，链表是倒序从低位到高位表示的，这和做算术加法的顺序一致，先加低位，产生进位传给高位，高位继续相加，这样逐位相加，最后的结果就是所需的输出链表。</p><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1l1 和 l2l2 的表头开始相加。由于每位数字都应当处于 0 \ldots 90…9 的范围内，我们计算两个数字的和时可能会出现“溢出”。例如，5 + 7 = 125+7=12。在这种情况下，我们会将当前位的数值设置为 22，并将进位 carry = 1carry=1 带入下一次迭代。进位 carrycarry 必定是 00 或 11，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 199+9+1=19。</p><p>伪代码如下：</p><p>将当前结点初始化为返回列表的哑结点。<br>将进位 carrycarry 初始化为 00。<br>将 pp 和 qq 分别初始化为列表 l1l1 和 l2l2 的头部。<br>遍历列表 l1l1 和 l2l2 直至到达它们的尾端。<br>将 xx 设为结点 pp 的值。如果 pp 已经到达 l1l1 的末尾，则将其值设置为 00。<br>将 yy 设为结点 qq 的值。如果 qq 已经到达 l2l2 的末尾，则将其值设置为 00。<br>设定 sum = x + y + carrysum=x+y+carry。<br>更新进位的值，carry = sum / 10carry=sum/10。<br>创建一个数值为 (sum \bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。<br>同时，将 pp 和 qq 前进到下一个结点。<br>检查 carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 11 的新结点。<br>返回哑结点的下一个结点。<br>请注意，我们<strong>使用哑结点来简化代码</strong>。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</p><table><thead><tr><th>l1=[0,1] <br>l2=[0,1,2]</th><th>当一个列表比另一个列表长时.</th></tr></thead><tbody><tr><td><strong>l1=[]<br>l2=[0,1]</strong></td><td><strong>当一个列表为空时，即出现空列表。</strong></td></tr><tr><td><strong>l1=[9,9]<br>l2=[1]</strong></td><td><strong>求和运算最后可能出现额外的进位，这一点很容易被遗忘</strong></td></tr></tbody></table><p><strong>官方代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己实现的代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">          ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//头结点，不存储数据，方便最后返回链表首部</span></span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">int</span> carry = <span class="number">0</span>, rest = <span class="number">0</span>;</span><br><span class="line">  ListNode p = l1, q = l2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="keyword">null</span> || q!=<span class="keyword">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">int</span> v_l1 = (p!=<span class="keyword">null</span>)? p.val:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v_l2 = (q!=<span class="keyword">null</span>)? q.val:<span class="number">0</span>;</span><br><span class="line">rest = (v_l1+v_l2+carry)%<span class="number">10</span>;</span><br><span class="line">carry = (v_l1+v_l2+carry)/<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ListNode addNode = <span class="keyword">new</span> ListNode(rest);</span><br><span class="line">curr.next = addNode;</span><br><span class="line">curr = addNode;</span><br><span class="line"></span><br><span class="line">p = (p==<span class="keyword">null</span>)? <span class="keyword">null</span>:p.next;</span><br><span class="line">q = (q==<span class="keyword">null</span>)? <span class="keyword">null</span>:q.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry!=<span class="number">0</span>)  <span class="comment">//如果最高位也满10进位</span></span><br><span class="line">  &#123;</span><br><span class="line">  curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><p>时间复杂度：O(max(m,n))，假设 m 和 n 分别表示 l1和 l2的长度，上面的算法最多重复 max(m,n) 次。</p><p>空间复杂度：O(max(m,n))， 新列表的长度最多为max(m,n)+1。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（中等）&quot;&gt;&lt;a href=&quot;#题目（中等）&quot; class=&quot;headerlink&quot; title=&quot;题目（中等）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（中等）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给出两个&lt;strong&gt;非空&lt;/strong&gt;的链表用来表示两个非负的整数。其中，它们各自的位数是按照&lt;strong&gt;逆序&lt;/strong&gt;的方式存储的，并且它们的每个节点只能存储&lt;strong&gt;一位&lt;/strong&gt;数字。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="中等题型" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大数据——CentOS7 eclipse中的hadoop环节配置</title>
    <link href="http://yoursite.com/2018/11/15/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94CentOS7%20eclipse%E4%B8%AD%E7%9A%84hadoop%E7%8E%AF%E8%8A%82%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/15/大数据——CentOS7 eclipse中的hadoop环节配置/</id>
    <published>2018-11-15T05:32:37.051Z</published>
    <updated>2018-11-16T15:36:50.438Z</updated>
    
    <content type="html"><![CDATA[<p>本来准备写个CentOS7下hadoop分布式集群的配置教程的，最近事情有点多，暂时搁置一下吧，先把遇到的小问题记录一下。</p><p>首先我用的是VMware虚拟机创建了三台虚拟机，都是CentOS7的，一台master（命名为hadoop1），两台slaver（命名为hadoop2和hadoop3），然后在master上配置了一些eclipse，准备跑MapReduce代码的，中间遇到了点小问题。</p><a id="more"></a><p>Eclipse版本： 4.5的Mars</p><p>Hadoop版本：2.7.3</p><p>所用教程：<a href="https://blog.csdn.net/xiaoyw71/article/details/53316390" target="_blank" rel="noopener">https://blog.csdn.net/xiaoyw71/article/details/53316390</a></p><hr><p>前面还算正常，到<strong>使用New Hadoop Location打开Hadoop Location配置窗口</strong>这一步时出错了，一直没有反应，然后打开Window -&gt; Show View -&gt; Error Log 查看错误日志，出错语句主要是两种：</p><p>Unhandled event loop exception</p><p>org.osgi.framework.BundleException: Exception in org.eclipse.equinox.internal</p><p>然后在网上一顿找，有的说应该是缺jar包，然后修改MANIFEST.MF文件的，比如这个老哥的情况：</p><p>2018-6-29 解决Eclipse使用Hadoop插件无法新建Location的问题 - 知乎</p><p><a href="https://zhuanlan.zhihu.com/p/38630695" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38630695</a></p><p>然后我下载了hadoop-eclipse-plugin-2.7.3.jar放入eclipse 安装目录下的plugins文件夹也还是解决不了，后来有人说是eclipse和hadoop-eclipse-plugin-x.x.x.jar<strong>版本不合适</strong>的，<strong>于是我把eclipse的版本改到了Neon 4.6 ，然后再重新在eclipse里面导入hadoop-eclipse-plugin-2.7.3.jar包就成功了，希望对大家有帮助。</strong></p><hr><p>三台集群配置完那天测试了一下jps指令感觉一切正常，于是就stop-all.sh关掉了，第二天重新start-all.sh发现作为namenode的hadoop1执行jps后少了resourcemanager，不过另外两个datanode执行jps是正常的，后来确认问题：</p><p><strong>namenode中的<u>yarn-site.xml</u>文件内容和datanode中的文件内容不一致</strong>，所以出现了resourcemanager启动失败的问题（似乎是启动后又关闭了），于是我把文件内容统一了一下，重新启动就正常了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License. See accompanying LICENSE file.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通知框架MR使用YARN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8033<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>昨天写了一个mapreduce函数一直有错误，找不到错误，今天找了一天终于解决了，原来是hadoop 的job.setOutputKeyClass和job.setOutputValueClas设置输出的问题。</p><p>job.<strong>setOutputKeyClass</strong>和job.<strong>setOutputValueClas</strong>在默认情况下是<strong>同时设置map阶段和reduce阶段的输出</strong>，也就是说只有map和reduce<strong>输出是一样的</strong>时候才不会出问题。</p><p>当map和reduce输出是不一样的时候就需要通过job.setMapOutputKeyClass和job.setMapOutputValueClas来设置map阶段的输出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来准备写个CentOS7下hadoop分布式集群的配置教程的，最近事情有点多，暂时搁置一下吧，先把遇到的小问题记录一下。&lt;/p&gt;
&lt;p&gt;首先我用的是VMware虚拟机创建了三台虚拟机，都是CentOS7的，一台master（命名为hadoop1），两台slaver（命名为hadoop2和hadoop3），然后在master上配置了一些eclipse，准备跑MapReduce代码的，中间遇到了点小问题。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ队列模式传递消息</title>
    <link href="http://yoursite.com/2018/10/20/ActiveMQ%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/10/20/ActiveMQ队列模式传递消息/</id>
    <published>2018-10-20T11:37:22.000Z</published>
    <updated>2018-10-20T11:37:22.954Z</updated>
    
    <content type="html"><![CDATA[<p>队列模式：点对点的方式（PTP）即：一个消息的生产者对应一个消费者，一个消息只能供一个消费者进行消费。</p><a id="more"></a><p><strong>生产者（Producer）实现步骤：</strong></p><p>第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递</p><p>第二步：通过第一步创建的工厂对象获得连接对象Connection</p><p>第三步：开启连接，直接调用connection对象的start方法即可</p><p>第四步：创建一个Session对象，通过connection对象创建</p><p>第五步：通过Session对象创建一个Destination对象（该对象有两种方式：topic和quene），这里使用quene</p><p>第六步：通过Session对象创建一个生产者Producer对象</p><p>第七步：创建Message对象，这里使用TextMessage对象，设置消息内容</p><p>第八步：使用创建的生产者对象Producer发送消息</p><p>第九步：关闭资源（Producer对象，Connection对象，Session对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>; <span class="comment">//127.0.0.1是回环地址，相当于localhost，61616是默认端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String queueName=<span class="string">"queue-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标</span></span><br><span class="line">            Destination destination = session.createQueue(queueName);</span><br><span class="line">            <span class="comment">//6.创建一个生产者</span></span><br><span class="line">            MessageProducer producer = session.createProducer(destination);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">//7.创建消息</span></span><br><span class="line">                TextMessage textMessage = session.createTextMessage(<span class="string">"test"</span> + i);</span><br><span class="line">                <span class="comment">//8.发布消息</span></span><br><span class="line">                producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"发送消息"</span> + textMessage.getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9.关闭连接</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者（Consumer）实现步骤：</strong></p><p>第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递</p><p>第二步：通过第一步创建的工厂对象获得连接对象Connection</p><p>第三步：开启连接，直接调用connection对象的start方法即可</p><p>第四步：创建一个Session对象，通过connection对象创建</p><p>第五步：创建一个Destination对象，使用quene，需要和生产者的quene一致</p><p>第六步：创建一个消费者对象</p><p>第七步：接收消息</p><p>第八步：打印接收的消息</p><p>第九步：关闭资源<strong>（此处关闭不要在监听后面直接关闭，因为监听是异步的，直接立刻关闭会导致监听没有结束就被关闭了，可以考虑在监听后面加入阻塞操作，让连接延迟中断）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String queueName=<span class="string">"queue-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标</span></span><br><span class="line">            Destination destination = session.createQueue(queueName);</span><br><span class="line">            <span class="comment">//6.创建一个消费者</span></span><br><span class="line">            MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line">            <span class="comment">//7.创建一个监听器</span></span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                    TextMessage textMessage = (TextMessage)message;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了）</span></span><br><span class="line">            <span class="comment">//等待键盘输入,可用于阻塞连接断开操作</span></span><br><span class="line">            <span class="comment">//System.in.read();</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外消费者可以开启多个，共同消费生成者产生的消息，这样消息会被均匀分配给消费者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;队列模式：点对点的方式（PTP）即：一个消息的生产者对应一个消费者，一个消息只能供一个消费者进行消费。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ主题模式传递消息</title>
    <link href="http://yoursite.com/2018/10/20/ActiveMQ%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/10/20/ActiveMQ主题模式传递消息/</id>
    <published>2018-10-20T11:37:22.000Z</published>
    <updated>2018-10-20T11:37:35.773Z</updated>
    
    <content type="html"><![CDATA[<p>订阅发布方式传递消息：Topic ，就类似微信公众号一样，可以多个订阅者接收一样的消息</p><p>补充：由于topic传递消息的特点是，一个生产者发送给多个消费者，生产者生产的消息在没有被消费者消费之前，并不会将消息持久化到activemq的服务端，发送的消息会自动消失。所以 测试的时候需要先创建消费者对象，然后再发送消息，防止消息丢失。</p><a id="more"></a><p><strong>生产者实现步骤：</strong></p><p>步骤和PTP的方式完全一样，不同的是在创建Destination对象的时候，需要创建topic对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">"topic-test"</span>; <span class="comment">//topic名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标（注意：此处变成了Topic）</span></span><br><span class="line">            Destination destination = session.createTopic(topicName);</span><br><span class="line">            <span class="comment">//6.创建一个生产者</span></span><br><span class="line">            MessageProducer producer = session.createProducer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">//7.创建消息</span></span><br><span class="line">                TextMessage textMessage = session.createTextMessage(<span class="string">"test"</span> + i);</span><br><span class="line">                <span class="comment">//8.发布消息</span></span><br><span class="line">                producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"发送消息"</span> + textMessage.getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9.关闭连接</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者实现的步骤：</strong></p><p>步骤和PTP消费者实现的步骤一样，唯一不同的是在创建Destination对象的时候，创建topic对象，同时要和发布订阅的生产者的topic一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">"topic-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标</span></span><br><span class="line">            Destination destination = session.createTopic(topicName);</span><br><span class="line">            <span class="comment">//6.创建一个消费者</span></span><br><span class="line">            MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line">            <span class="comment">//7.创建一个监听器</span></span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                    TextMessage textMessage = (TextMessage)message;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了）</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;订阅发布方式传递消息：Topic ，就类似微信公众号一样，可以多个订阅者接收一样的消息&lt;/p&gt;
&lt;p&gt;补充：由于topic传递消息的特点是，一个生产者发送给多个消费者，生产者生产的消息在没有被消费者消费之前，并不会将消息持久化到activemq的服务端，发送的消息会自动消失。所以 测试的时候需要先创建消费者对象，然后再发送消息，防止消息丢失。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
</feed>
