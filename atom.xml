<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JJ❤22</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-08T07:13:06.454Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JJZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web笔记——ajax请求与后台交互的问题</title>
    <link href="http://yoursite.com/2019/04/08/Web%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ajax%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%90%8E%E5%8F%B0%E4%BA%A4%E4%BA%92%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/08/Web笔记——ajax请求与后台交互的问题/</id>
    <published>2019-04-08T06:52:16.638Z</published>
    <updated>2019-04-08T07:13:06.454Z</updated>
    
    <content type="html"><![CDATA[<p>最近做一个物联网相关项目时涉及到APP前后端交互的问题</p><p>通过ajax发送Post请求</p><p>最开始的option.data通过&amp;连接不同参数，通过=为参数赋值：<a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * k:v形式作为参数发送</span></span><br><span class="line"><span class="comment"> * hasProgress 是否有进度条，true or false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxSendMap</span>(<span class="params">options, hasProgress</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> request = <span class="literal">null</span>;</span><br><span class="line">    options.method = options.method || <span class="string">'get'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(options.method);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        request = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> layerProgress = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasProgress) &#123;</span><br><span class="line">        layerProgress = layer.load(<span class="number">2</span>, &#123;</span><br><span class="line">            shade: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (options.method.toLowerCase() === <span class="string">'get'</span>) &#123;</span><br><span class="line">        request.open(<span class="string">'get'</span>, options.url + <span class="string">'?'</span> + options.data, <span class="literal">true</span>);</span><br><span class="line">        request.send();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.method.toLowerCase() === <span class="string">'post'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"options.url:"</span>+options.url);</span><br><span class="line">        request.open(<span class="string">'post'</span>, options.url, <span class="literal">true</span>);</span><br><span class="line">        request.setRequestHeader(<span class="string">"content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        <span class="comment">//request.setRequestHeader("content-type", "multipart/form-data");</span></span><br><span class="line">        <span class="keyword">var</span> ajaxdata = toAjaxData(options.data); <span class="comment">//通过&amp;连接为ajaxdata</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"ajaxdata:"</span> + ajaxdata);</span><br><span class="line">        request.send(ajaxdata);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"方式不正确"</span>);</span><br><span class="line">        layerProgress &amp;&amp; layer.close(layerProgress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置处理</span></span><br><span class="line">    setOnRespond(request, options, layerProgress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toAjaxData</span>(<span class="params">data, isForm</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"data.dataVal: "</span>+data.dataVal);</span><br><span class="line"><span class="comment">// 表单形式不用转换</span></span><br><span class="line"><span class="keyword">if</span> (isForm) &#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ajaxData = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line"><span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">ajaxData = key + <span class="string">"="</span> + data[key];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ajaxData = ajaxData + <span class="string">"&amp;"</span> + key + <span class="string">"="</span> + data[key]; <span class="comment">//可以看到此处通过&amp;连接</span></span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"isForm:"</span> + isForm + <span class="string">", ajaxData:"</span> + ajaxData);</span><br><span class="line"><span class="keyword">return</span> ajaxData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来发现当连接过程中，若某个data[key]很长时，这个var变量<strong>可能出现连接后截断的问题</strong>，从而出现数据格式丢失和错误的<strong>问题</strong></p><p><strong>解决方法：</strong></p><p>通过FormData格式将各个data[key]进行append操作，然后data: formData</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    formData.append(key, data[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: GeneralUtil.urlUser + <span class="string">'data/add'</span>,</span><br><span class="line">    type: <span class="string">"POST"</span>,</span><br><span class="line">    data: formData,  <span class="comment">//通过formData以键值对 a:value 形式发送表单数据</span></span><br><span class="line">    contentType : <span class="literal">false</span>,</span><br><span class="line">    processData : <span class="literal">false</span>,</span><br><span class="line">    cache : <span class="literal">false</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'成功'</span>);</span><br><span class="line">        callBack.done(result.data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'异常'</span>+err.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做一个物联网相关项目时涉及到APP前后端交互的问题&lt;/p&gt;
&lt;p&gt;通过ajax发送Post请求&lt;/p&gt;
&lt;p&gt;最开始的option.data通过&amp;amp;连接不同参数，通过=为参数赋值：
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——集合的初始容量和原因以及扩容增量</title>
    <link href="http://yoursite.com/2019/03/19/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E5%92%8C%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/19/JAVA笔记——集合的初始容量和原因以及扩容方式/</id>
    <published>2019-03-19T14:55:00.444Z</published>
    <updated>2019-03-19T16:07:24.220Z</updated>
    
    <content type="html"><![CDATA[<p>首先：容器包含 Collection集合类（Set、List、Queue） 和 Map，集合类是把对象的集合形式，Map是键值对的映射形式。</p><p><img src="https://images2015.cnblogs.com/blog/464364/201608/464364-20160821093249995-1755279341.jpg" alt="img"></p><p><strong>需要注意的是LinkedList也有继承Queue接口</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">初始容量</th><th style="text-align:center">扩容增量</th><th style="text-align:center">线程安全性</th></tr></thead><tbody><tr><td style="text-align:center">ArrayList</td><td style="text-align:center">10</td><td style="text-align:center">newN=1.5*N+1</td><td style="text-align:center">不安全</td></tr><tr><td style="text-align:center">Vector</td><td style="text-align:center">10</td><td style="text-align:center">newN=2*N</td><td style="text-align:center">安全</td></tr><tr><td style="text-align:center">HashSet</td><td style="text-align:center">16</td><td style="text-align:center">newN=2*N(装载因子0.75)</td><td style="text-align:center">不安全</td></tr><tr><td style="text-align:center">HashMap</td><td style="text-align:center">16</td><td style="text-align:center">newN=2*N(装载因子0.75)</td><td style="text-align:center">不安全</td></tr></tbody></table><p>为什么HashSet和HashMap的初始容量为16呢？这与hash的过程和特点有关。</p><p>首先我们要知道哈希碰撞这个概念，如果两个键值不同的元素hash函数值相同，则意味着两个元素会映射到一个索引下，即发生了碰撞。</p><p>因为把任意长度的字符串变成固定长度的字符串,所以存在一个hash对应多个字符串的情况,所以碰撞必然存在</p><p>为了减少hash值的碰撞,需要实现一个尽量均匀分布的hash函数,在HashMap中通过利用key的hashcode值,来进行位运算<br>公式:index = e.hash &amp; (newCap - 1)</p><p>举例子之前，</p><p>（1）关于String的hashCode()如何计算的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面利用上述方法计算字符串”Lee”的哈希值</p><p>‘L’的ASCII码为76，’e’的ASCII码为101</p><p>for循环3次</p><ol><li>h=31*0+76=76</li><li>h=31*76+101=2457</li><li>h=31*2457+101=76268</li></ol><p>所以字符串”Lee”的哈希码就是76268</p><p>（2）关于均匀散列的方法</p><p>一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，<strong>但取模会用到除法运算，效率很低，</strong>HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</p><p><strong>举个例子:</strong><br>1.计算”book”的hashcode<br>十进制 : 3029737<br>二进制 : 101110001110101110 1001</p><p>2.HashMap长度是默认的16，length - 1的结果<br>十进制 : 15<br>二进制 : 1111</p><p>3.把以上两个结果做与运算<br>101110001110101110 1001 &amp; 1111 = 1001<br>1001的十进制 : 9,所以 index=9</p><p>hash算法最终得到的index结果,取决于hashcode值的最后几位</p><p>为了推断HashMap的默认长度为什么是16<br>现在,我们假设HashMap的长度是10,重复刚才的运算步骤:<br>hashcode : 101110001110101110 1001<br>length - 1 : 1001<br>index : 1001</p><p>再换一个hashcode 101110001110101110 1111 试试:<br>hashcode : 101110001110101110 1111<br>length - 1 : 1001<br>index : 1001</p><p>从结果可以看出,虽然hashcode变化了,但是运算的结果都是1001,也就是说,当HashMap长度为10的时候,<strong>有些index结果的出现几率</strong><br><strong>会更大而有些index结果永远不会出现(比如0111),这样就不符合hash均匀分布的原则</strong></p><p><strong>反观长度16或者其他2的幂,length - 1的值是所有二进制位全为1,这种情况下,index的结果等同于hashcode后几位的值</strong><br><strong>只要输入的hashcode本身分布均匀,hash算法的结果就是均匀的</strong></p><p>所以,HashMap的默认长度为16,是<strong>为了降低hash碰撞的几率</strong>。</p><p>参考博客：为什么HashMap集合的初始大小是16？ - 鹤野云间 - CSDN博客<br><a href="https://blog.csdn.net/ocean_java666/article/details/85051694" target="_blank" rel="noopener">https://blog.csdn.net/ocean_java666/article/details/85051694</a></p><p>hashcode冲突的解决方法以及原理分析（收获颇大） - 子爵的博客 - CSDN博客<br><a href="https://blog.csdn.net/zyanyy8023/article/details/81913425" target="_blank" rel="noopener">https://blog.csdn.net/zyanyy8023/article/details/81913425</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先：容器包含 Collection集合类（Set、List、Queue） 和 Map，集合类是把对象的集合形式，Map是键值对的映射形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/464364/201608
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="集合类" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——并发控制机制</title>
    <link href="http://yoursite.com/2019/03/17/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/17/JAVA笔记——并发控制机制/</id>
    <published>2019-03-17T12:03:19.392Z</published>
    <updated>2019-03-17T12:05:37.067Z</updated>
    
    <content type="html"><![CDATA[<p>在一般性开发中，笔者经常看到很多同学在对待java并发开发模型中只会使用一些基础的方法。比如volatile，synchronized。像Lock和atomic这类高级并发包很多人并不经常使用。我想大部分原因都是来之于对原理的不属性导致的。在繁忙的开发工作中，又有谁会很准确的把握和使用正确的并发模型呢？</p><p>所以最近基于这个思想，本人打算把并发控制机制这部分整理成一篇文章。既是对自己掌握知识的一个回忆，也是希望这篇讲到的类容能帮助到大部分开发者。</p><p>并行程序开发不可避免地要涉及多线程、多任务的协作和数据共享等问题。在JDK中，提供了多种途径实现多线程间的并发控制。比如常用的：内部锁、重入锁、读写锁和信号量。<a id="more"></a></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>在java中，每一个线程有一块工作内存区，其中存放着被所有线程共享的主内存中的变量的值的拷贝。当线程执行时，它在自己的工作内存中操作这些变量。</p><p>为了存取一个共享的变量，一个线程通常先获取锁定并且清除它的工作内存区，这保证该共享变量从所有线程的共享内存区正确地装入到线程的工作内存区，当线程解锁时保证该工作内存区中变量的值协会到共享内存中。</p><p>当一个线程使用某一个变量时，不论程序是否正确地使用线程同步操作，它获取的值一定是由它本身或者其他线程存储到变量中的值。例如，如果两个线程把不同的值或者对象引用存储到同一个共享变量中，那么该变量的值要么是这个线程的，要么是那个线程的，共享变量的值不会是由两个线程的引用值组合而成。</p><p>一个变量时Java程序可以存取的一个地址，它不仅包括基本类型变量、引用类型变量，而且还包括数组类型变量。保存在主内存区的变量可以被所有线程共享，但是一个线程存取另一个线程的参数或者局部变量时不可能的，所以开发人员不必担心局部变量的线程安全问题。至于内存模型中线程工作内存与主内存的交互请关注<a href="http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html" target="_blank" rel="noopener">http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html</a> , 这里就不再做过多介绍。</p><h2 id="volatile变量–多线程间可见"><a href="#volatile变量–多线程间可见" class="headerlink" title="volatile变量–多线程间可见"></a>volatile变量–多线程间可见</h2><p>由于每个线程都有自己的工作内存区，因此当一个线程改变自己的工作内存中的数据时，对其他线程来说，可能是不可见的。为此，可以使用volatile关键字破事所有线程军读写内存中的变量，从而使得volatile变量在多线程间可见。</p><p>声明为volatile的变量可以做到如下保证：</p><p>1、其他线程对变量的修改，可以及时反应在当前线程中；</p><p>2、确保当前线程对volatile变量的修改，能及时写回到共享内存中，并被其他线程所见；</p><p>3、使用volatile声明的变量，编译器会保证其有序性。</p><h2 id="同步关键字synchronized"><a href="#同步关键字synchronized" class="headerlink" title="同步关键字synchronized"></a>同步关键字synchronized</h2><p>同步关键字synchronized是Java语言中最为常用的同步方法之一。在JDK早期版本中，synchronized的性能并不是太好，值适合于锁竞争不是特别激烈的场合。在JDK6中，synchronized和非公平</p><p>锁的差距已经缩小。更为重要的是，synchronized更为简洁明了，代码可读性和维护性比较好。</p><p>锁定一个对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当method()方法被调用时，调用线程首先必须获得当前对象所，若当前对象锁被其他线程持有，这调用线程会等待，犯法结束后，对象锁会被释放，以上方法等价于下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line"><span class="comment">// do something …</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，使用synchronized还可以构造同步块，与同步方法相比，同步块可以更为精确控制同步代码范围。一个小的同步代码非常有离与锁的快进快出，从而使系统拥有更高的吞吐量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line"><span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized也可以用于static函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个地方一定要注意，synchronized的锁是加在 当前Class对象 上，因此，所有对该方法的调用，都必须获得Class对象的锁。</p><p>虽然synchronized可以保证对象或者代码段的线程安全，但是仅使用synchronized还是不足以控制拥有复杂逻辑的线程交互。为了实现多线程间的交互，还需要使用Object对象的wait()和notify()方法。</p><p>典型用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">while</span>(&lt;?&gt;)&#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">        <span class="comment">// 收到通知后，继续执行。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用wait()方法前，需要获得对象锁。在wait()方法执行时，当前线程或释放obj的独占锁，供其他线程使用。</p><p>当等待在obj上线程收到obj.notify()时，它就能重新获得obj的独占锁，并继续运行。注意了，notify()方法是 随机唤起 等待在当前对象的某一个线程。</p><p>下面是一个阻塞队列的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueue</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (list.size()==<span class="number">0</span>)&#123;</span><br><span class="line"> <span class="keyword">this</span>.wait();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> list.remove(<span class="number">0</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">put</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"> list.add(obj);</span><br><span class="line"> <span class="keyword">this</span>.notify();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized配合wait()、notify()应该是Java开发者必须掌握的基本技能。</p><h2 id="Reentrantlock重入锁"><a href="#Reentrantlock重入锁" class="headerlink" title="Reentrantlock重入锁"></a>Reentrantlock重入锁</h2><p>Reentrantlock称为重入锁。它比synchronized拥有更加强大的功能，它可以中断、可定时。在高并发的情况下，它比synchronized有明显的性能优势。</p><p>Reentrantlock提供了公平和非公平两种锁。公平锁是对锁的获取是先进先出，而非公平锁是可以插队的。当然从性能上分析，非公平锁的性能要好得多。因此，在无特殊需要，应该优选非公平锁，但是synchronized提供锁业不是绝对公平的。Reentrantlock在构造的时候可以指定锁是否公平。</p><p>在使用重入锁时，一定要在程序最后释放锁。一般释放锁的代码要写在finally里。否则，如果程序出现异常，Loack就永远无法释放了。synchronized的锁是JVM最后自动释放的。</p><p>经典使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123; <span class="comment">//如果已经被lock，尝试等待5s，看是否可以获得锁，如果5s后仍然无法获得锁则返回false继续执行</span></span><br><span class="line"> <span class="comment">// lock.lockInterruptibly();可以响应中断事件</span></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="comment">//操作</span></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace(); <span class="comment">//当前线程被中断时(interrupt)，会抛InterruptedException </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reentrantlock提供了非常丰富的锁控制功能，灵活应用这些控制方法，可以提高应用程序的性能。不过这里并非是极力推荐使用Reentrantlock。重入锁算是JDK中提供的高级开发工具。这里有一篇文章专门针对 <a href="http://blog.csdn.net/fw0124/article/details/6672522" target="_blank" rel="noopener">ReentrantLock和synchronized两种锁定机制的对比</a> 。</p><h2 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h2><p>读写分离是一种非常常见的数据处理思想。在sql中应该算是必须用到的技术。ReadWriteLock是在JDK5中提供的读写分离锁。读写分离锁可以有效地帮助减少锁竞争，以提升系统性能。读写分离使用场景主要是如果在系统中，读操作次数远远大于写操作。使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="keyword">private</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line"><span class="keyword">private</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Condition对象"><a href="#Condition对象" class="headerlink" title="Condition对象"></a>Condition对象</h2><p>Conditiond对象用于协调多线程间的复杂协作。主要与锁相关联。通过Lock接口中的newCondition()方法可以生成一个与Lock绑定的Condition实例。Condition对象和锁的关系就如用Object.wait()、Object.notify()两个函数以及synchronized关键字一样。</p><p>这里可以把ArrayBlockingQueue的源码摘出来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span> <span class="keyword">extends</span> <span class="title">AbstractQueue</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BlockingQueue</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair); </span><br><span class="line">    notEmpty = lock.newCondition(); <span class="comment">// 生成与Lock绑定的Condition</span></span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal(); <span class="comment">// 通知</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// 如果队列为空</span></span><br><span class="line">            notEmpty.await();  <span class="comment">// 则消费者队列要等待一个非空的信号</span></span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">extract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]);</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    takeIndex = inc(takeIndex);</span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal(); <span class="comment">// 通知put() 线程队列已有空闲空间</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p>信号量为多线程协作提供了更为强大的控制方法。信号量是对锁的扩展。无论是内部锁synchronized还是重入锁ReentrantLock，一次都允许一个线程访问一个资源，而信号量却可以指定多个线程同时访问某一个资源。从构造函数可以看出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></span>&#123;&#125; <span class="comment">// 可以指定是否公平</span></span><br></pre></td></tr></table></figure><p>permits指定了信号量的准入书，也就是同时能申请多少个许可。当每个线程每次只申请一个许可时，这就相当于指定了同时有多少个线程可以访问某一个资源。这里罗列一下主要方法的使用：</p><ul><li>public void acquire() throws InterruptedException {} //尝试获得一个准入的许可。若无法获得，则线程会等待，知道有线程释放一个许可或者当前线程被中断。</li><li>public void acquireUninterruptibly(){} // 类似于acquire()，但是不会响应中断。</li><li>public boolean tryAcquire(){} // 尝试获取，如果成功则为true，否则false。这个方法不会等待，立即返回。</li><li>public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException {} // 尝试等待多长时间</li><li>public void release() //用于在现场访问资源结束后，释放一个许可，以使其他等待许可的线程可以进行资源访问。</li></ul><p>下面来看一下JDK文档中提供使用信号量的实例。这个实例很好的解释了如何通过信号量控制资源访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    available.acquire();</span><br><span class="line">    <span class="comment">// 申请一个许可</span></span><br><span class="line">    <span class="comment">// 同时只能有100个线程进入取得可用项，</span></span><br><span class="line">    <span class="comment">// 超过100个则需要等待</span></span><br><span class="line">    <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将给定项放回池内，标记为未被使用</span></span><br><span class="line">    <span class="keyword">if</span> (markAsUnused(x)) &#123;</span><br><span class="line">        available.release();</span><br><span class="line">        <span class="comment">// 新增了一个可用项，释放一个许可，请求资源的线程被激活一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅作示例参考，非真实数据</span></span><br><span class="line"><span class="keyword">protected</span> Object[] items = <span class="keyword">new</span> Object[MAX_AVAILABLE]; <span class="comment">// 用于对象池复用对象</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE]; <span class="comment">// 标记作用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> items[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实例简单实现了一个对象池，对象池最大容量为100。因此，当同时有100个对象请求时，对象池就会出现资源短缺，未能获得资源的线程就需要等待。当某个线程使用对象完毕后，就需要将对象返回给对象池。此时，由于可用资源增加，因此，可以激活一个等待该资源的线程。</p><h2 id="ThreadLocal线程局部变量"><a href="#ThreadLocal线程局部变量" class="headerlink" title="ThreadLocal线程局部变量"></a>ThreadLocal线程局部变量</h2><p>在刚开始接触ThreadLocal，笔者很难理解这个线程局部变量的使用场景。当现在回过头去看，ThreadLocal是一种多线程间并发访问变量的解决方案。与synchronized等加锁的方式不同，ThreadLocal完全不提供锁，而使用了以空间换时间的手段，为每个线程提供变量的独立副本，以保障线程安全，因此它不是一种数据共享的解决方案。</p><p>ThreadLocal是解决线程安全问题一个很好的思路，ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本，由于Key值不可重复，每一个“线程对象”对应线程的“变量副本”，而到达了线程安全。</p><p>特别值得注意的地方，从性能上说，ThreadLocal并不具有绝对的又是，在并发量不是很高时，也行加锁的性能会更好。但作为一套与锁完全无关的线程安全解决方案，在高并发量或者所竞争激烈的场合，使用ThreadLocal可以在一定程度上减少锁竞争。</p><p>下面是一个ThreadLocal的简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNum</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal seqNum = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">// 获取下一个序列值</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> seqNum.set(seqNum.get() + <span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> seqNum.get();</span><br><span class="line">&#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> TestNum sn = <span class="keyword">new</span> TestNum();</span><br><span class="line"> <span class="comment">//3个线程共享sn，各自产生序列号</span></span><br><span class="line"> TestClient t1 = <span class="keyword">new</span> TestClient(sn);</span><br><span class="line"> TestClient t2 = <span class="keyword">new</span> TestClient(sn);</span><br><span class="line"> TestClient t3 = <span class="keyword">new</span> TestClient(sn);</span><br><span class="line"> t1.start();</span><br><span class="line"> t2.start();</span><br><span class="line"> t3.start();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> TestNum sn;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClient</span><span class="params">(TestNum sn)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.sn = sn;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"> <span class="comment">// 每个线程打出3个序列值</span></span><br><span class="line"> System.out.println(<span class="string">"thread["</span> + Thread.currentThread().getName() + <span class="string">"] --&gt; sn["</span></span><br><span class="line"> + sn.getNextNum() + <span class="string">"]"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread[Thread-<span class="number">0</span>] –&gt; sn[<span class="number">1</span>]</span><br><span class="line">thread[Thread-<span class="number">1</span>] –&gt; sn[<span class="number">1</span>]</span><br><span class="line">thread[Thread-<span class="number">2</span>] –&gt; sn[<span class="number">1</span>]</span><br><span class="line">thread[Thread-<span class="number">1</span>] –&gt; sn[<span class="number">2</span>]</span><br><span class="line">thread[Thread-<span class="number">0</span>] –&gt; sn[<span class="number">2</span>]</span><br><span class="line">thread[Thread-<span class="number">1</span>] –&gt; sn[<span class="number">3</span>]</span><br><span class="line">thread[Thread-<span class="number">2</span>] –&gt; sn[<span class="number">2</span>]</span><br><span class="line">thread[Thread-<span class="number">0</span>] –&gt; sn[<span class="number">3</span>]</span><br><span class="line">thread[Thread-<span class="number">2</span>] –&gt; sn[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>输出的结果信息可以发现每个线程所产生的序号虽然都共享同一个TestNum实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为ThreadLocal为每一个线程提供了单独的副本。</p><h2 id="锁的性能和优化"><a href="#锁的性能和优化" class="headerlink" title="锁的性能和优化"></a>锁的性能和优化</h2><p>“锁”是最常用的同步方法之一。在平常开发中，经常能看到很多同学直接把锁加很大一段代码上。还有的同学只会用一种锁方式解决所有共享问题。显然这样的编码是让人无法接受的。特别的在高并发的环境下，激烈的锁竞争会导致程序的性能下降德更加明显。因此合理使用锁对程序的性能直接相关。</p><p>1、线程的开销</p><p>在多核情况下，使用多线程可以明显提高系统的性能。但是在实际情况中，使用多线程的方式会额外增加系统的开销。相对于单核系统任务本身的资源消耗外，多线程应用还需要维护额外多线程特有的信息。比如，线程本身的元数据，线程调度，线程上下文的切换等。</p><p>2、减小锁持有时间 </p><p>在使用锁进行并发控制的程序中，当锁发生竞争时，单个线程对锁的持有时间与系统性能有着直接的关系。如果线程持有锁的时间很长，那么相对地，锁的竞争程度也就越激烈。因此，在程序开发过程中，应该尽可能地减少对某个锁的占有时间，以减少线程间互斥的可能。比如下面这一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMehod</span><span class="params">()</span></span>&#123;</span><br><span class="line">beforeMethod();</span><br><span class="line">mutexMethod();</span><br><span class="line">afterMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此实例如果只有mutexMethod()方法是有同步需要的，而在beforeMethod(),和afterMethod()并不需要做同步控制。如果beforeMethod(),和afterMethod()分别是重量级的方法，则会花费较长的CPU时间。在这个时候，如果并发量较大时，使用这种同步方案会导致等待线程大量增加。因为当前执行的线程只有在执行完所有任务后，才会释放锁。</p><p>下面是优化后的方案，只在必要的时候进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMehod</span><span class="params">()</span></span>&#123;</span><br><span class="line">beforeMethod();</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">mutexMethod();</span><br><span class="line">&#125;</span><br><span class="line">afterMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、减少锁粒度</p><p>减小锁粒度也是一种削弱多线程锁竞争的一种有效手段，这种技术典型的使用场景就是ConcurrentHashMap这个类。在普通的HashMap中每当对集合进行add()操作或者get()操作时，总是获得集合对象的锁。这种操作完全是一种同步行为，因为锁是在整个集合对象上的，因此，在高并发时，激烈的锁竞争会影响到系统的吞吐量。</p><p>如果看过源码的同学应该知道HashMap是数组+链表的方式做实现的。ConcurrentHashMap在HashMap的基础上将整个HashMap分成若干个段(Segment)，每个段都是一个子HashMap。如果需要在增加一个新的表项，并不是将这个HashMap加锁，二十搜线根据hashcode得到该表项应该被存放在哪个段中，然后对该段加锁，并完成put()操作。这样，在多线程环境中，如果多个线程同时进行写入操作，只要被写入的项不存在同一个段中，那么线程间便可以做到真正的并行。具体的实现希望读者自己花点时间读一读ConcurrentHashMap这个类的源码，这里就不再做过多描述了。</p><p> 4、锁分离 </p><p>在前面提起过ReadWriteLock读写锁，那么读写分离的延伸就是锁的分离。同样可以在JDK中找到锁分离的源码LinkedBlockingQueue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span> <span class="keyword">extends</span> <span class="title">AbstractQueue</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BlockingQueue</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/* Lock held by take, poll, etc /</span></span><br><span class="line"><span class="comment">private final ReentrantLock takeLock = new ReentrantLock();</span></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly(); <span class="comment">// 不能有两个线程同时读取数据</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">// 如果当前没有可用数据，一直等待put()的通知</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue(); <span class="comment">// 从头部移除一项</span></span><br><span class="line">        c = count.getAndDecrement(); <span class="comment">// size减1</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 通知其他take()操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull(); <span class="comment">// 通知put()操作，已有空余空间</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly(); <span class="comment">// 不能有两个线程同时put数据</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">         * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">         * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">         * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">         * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">         * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123; <span class="comment">// 队列满了 则等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node); <span class="comment">// 加入队列</span></span><br><span class="line">        c = count.getAndIncrement();<span class="comment">// size加1</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal(); <span class="comment">// 如果有足够空间，通知其他线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();<span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();<span class="comment">// 插入成功后，通知take()操作读取数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other code     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明一下的就是，take()和put()函数是相互独立的，它们之间不存在锁竞争关系。只需要在take()和put()各自方法内部分别对takeLock和putLock发生竞争。从而，削弱了锁竞争的可能性。</p><p>5、锁粗化</p><p>上面说到的减小锁时间和粒度，这样做就是为了满足每个线程持有锁的时间尽量短。但是，在粒度上应该把握一个度，如果对用一个锁不停地进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而加大了系统开销。</p><p>我们需要知道的是，虚拟机在遇到一连串连续的对同一锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这样的操作叫做锁的粗化。下面是一段整合实例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMehod</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM整合后的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMehod</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">method1();</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，这样的整合给我们开发人员对锁粒度的把握给出了很好的演示作用。</p><h2 id="无锁的并行计算"><a href="#无锁的并行计算" class="headerlink" title="无锁的并行计算"></a>无锁的并行计算</h2><p>上面花了很大篇幅在说锁的事情，同时也提到过锁是会带来一定的上下文切换的额外资源开销，在高并发时，”锁“的激烈竞争可能会成为系统瓶颈。因此，这里可以使用一种非阻塞同步方法。这种无锁方式依然能保证数据和程序在高并发环境下保持多线程间的一致性。</p><p>1、非阻塞同步/无锁</p><p>非阻塞同步方式其实在前面的ThreadLocal中已经有所体现，每个线程拥有各自独立的变量副本，因此在并行计算时，无需相互等待。这里笔者主要推荐一种更为重要的、基于比较并交换（Compare And Swap）CAS算法的无锁并发控制方法。</p><p>CAS算法的过程：它包含3个参数CAS(V,E,N)。V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后CAS返回当前V的真实值。CAS操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余俊辉失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作及时没有锁，也可以发现其他线程对当前线程的干扰，并且进行恰当的处理。</p><p>在这里笔者引入一篇讲得很不错的文章 <a href="http://www.cnblogs.com/Mainz/p/3546347.html" target="_blank" rel="noopener">非阻塞同步算法与CAS(Compare and Swap)无锁算法</a> 。</p><p>2、原子量操作</p><p>JDK的java.util.concurrent.atomic包提供了使用无锁算法实现的原子操作类，代码内部主要使用了底层native代码的实现。有兴趣的同学可以继续跟踪一下native层面的代码。这里就不贴表层的代码实现了。</p><p>下面主要以一个例子来展示普通同步方法和无锁同步的性能差距：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomic</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_THREADS = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_COUNT = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TARGET_COUNT = <span class="number">100</span> * <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">private</span> AtomicInteger acount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">long</span> startTime;</span><br><span class="line">    TestAtomic out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">(TestAtomic o, <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.out = o;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = out.inc();</span><br><span class="line">        <span class="keyword">while</span> (v &lt; TARGET_COUNT) &#123;</span><br><span class="line">            v = out.inc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"SyncThread spend:"</span> + (endTime - startTime) + <span class="string">"ms"</span> + <span class="string">", v="</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicThread</span><span class="params">(<span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = acount.incrementAndGet();</span><br><span class="line">        <span class="keyword">while</span> (v &lt; TARGET_COUNT) &#123;</span><br><span class="line">            v = acount.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"AtomicThread spend:"</span> + (endTime - startTime) + <span class="string">"ms"</span> + <span class="string">", v="</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService exe = Executors.newFixedThreadPool(MAX_THREADS);</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    SyncThread sync = <span class="keyword">new</span> SyncThread(<span class="keyword">this</span>, startTime);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_COUNT; i++) &#123;</span><br><span class="line">        exe.submit(sync);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAtomic</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService exe = Executors.newFixedThreadPool(MAX_THREADS);</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    AtomicThread atomic = <span class="keyword">new</span> AtomicThread(startTime);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_COUNT; i++) &#123;</span><br><span class="line">        exe.submit(atomic);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">testSync():</span><br><span class="line">SyncThread spend:<span class="number">201</span>ms, v=<span class="number">1000002</span></span><br><span class="line">SyncThread spend:<span class="number">201</span>ms, v=<span class="number">1000000</span></span><br><span class="line">SyncThread spend:<span class="number">201</span>ms, v=<span class="number">1000001</span></span><br><span class="line">testAtomic():</span><br><span class="line">AtomicThread spend:<span class="number">43</span>ms, v=<span class="number">1000000</span></span><br><span class="line">AtomicThread spend:<span class="number">44</span>ms, v=<span class="number">1000001</span></span><br><span class="line">AtomicThread spend:<span class="number">46</span>ms, v=<span class="number">1000002</span></span><br></pre></td></tr></table></figure><p>相信这样的测试结果将内部锁和非阻塞同步算法的性能差异体现的非常明显。因此笔者更推荐直接视同atomic下的这个原子类。</p><p>完整文章链接：Java并发控制机制 - KING磊 - 博客园<br><a href="https://www.cnblogs.com/caolei1108/p/6281807.html" target="_blank" rel="noopener">https://www.cnblogs.com/caolei1108/p/6281807.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一般性开发中，笔者经常看到很多同学在对待java并发开发模型中只会使用一些基础的方法。比如volatile，synchronized。像Lock和atomic这类高级并发包很多人并不经常使用。我想大部分原因都是来之于对原理的不属性导致的。在繁忙的开发工作中，又有谁会很准确的把握和使用正确的并发模型呢？&lt;/p&gt;
&lt;p&gt;所以最近基于这个思想，本人打算把并发控制机制这部分整理成一篇文章。既是对自己掌握知识的一个回忆，也是希望这篇讲到的类容能帮助到大部分开发者。&lt;/p&gt;
&lt;p&gt;并行程序开发不可避免地要涉及多线程、多任务的协作和数据共享等问题。在JDK中，提供了多种途径实现多线程间的并发控制。比如常用的：内部锁、重入锁、读写锁和信号量。
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——信道利用率回顾</title>
    <link href="http://yoursite.com/2019/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E5%9B%9E%E9%A1%BE/"/>
    <id>http://yoursite.com/2019/03/05/计算机网络——信道利用率回顾/</id>
    <published>2019-03-05T05:00:42.574Z</published>
    <updated>2019-03-05T05:03:41.878Z</updated>
    
    <content type="html"><![CDATA[<p>T = P/C+RTT（RTT是往返时间）需要的在捎带确认中才有。否则针对每一个帧进行确认的话，发送周期是T = P/C+RTT<br>如果确认帧传输时延不可忽略，则T = P/C+RTT+P/C</p><p>P是一帧长度，C是数据传输速率。</p><p>以2015年一题为例。<a id="more"></a></p><p>核心是理解发送周期的计算方式。至于确认帧的大小是否计较，是是否计算一个帧的传输时延的问题。</p><p>2012年的真题个人觉得是有问题的，不去管，后来的就也越来越没有争议。</p><p>（2015.35）主机甲通过128kbps卫星链路，采用滑动窗口协议向主机乙发送数据，链路单向传播时延为250ms，帧长为1000字节。不考虑确认帧的开销，为使链路利用率不小于80%，帧序号的比特数至少是：B.</p><p>A.3<br><strong>B. 4</strong><br>C. 7<br>D. 8</p><p>分析：以发送周期为切入点来思考这个问题。开始发送帧到收到第一个确认帧为止，用时：<br>T = 第一个帧的传输时延+第一个帧的传播时延+确认帧的传输时延+确认帧的传播时延。</p><p>因为确认帧的开销不计，所以它的传输不计。但是传播时延要计的。<br>所以T = 1000B/128kbps + RTT = 0.5625s<br>那么在0.5625s内需要发送多少数据可以满足利用率80%呢？</p><p>设为L字节，则：<br>L128kbpsT≥0.8→L=7200B<br>L128kbpsT≥0.8→L=7200B<br>就是说在一个发送周期内至少发7.2帧就可满足要求。</p><p>因此，需要编号的比特数为n;</p><p>2n−1≥7.22n−1≥7.2<br>所以n至少为4.</p><p>此外，还需要特别思考一下，信道的数据传输速率的极限是128kbps，理论上最大每秒可传输16000B，即16帧，大于12.8，因此符合要求。</p><p>另一种思路是：16⋅0.8=12.816⋅0.8=12.8<br>即在1秒要发送12.8帧才能满足要求。但是我们不是拿12.8计算比特数的，而是一个发送周期内需要发多少帧！<br>一个发送周期是0.5625s,所以发送：7.2帧。<br>同样为了区分新旧：</p><p>2n−1≥7.22n−1≥7.2<br>可直接计算得到4比特。</p><p>另外可以参考：<br><a href="http://blog.csdn.net/u011240016/article/details/52613941" target="_blank" rel="noopener">http://blog.csdn.net/u011240016/article/details/52613941</a></p><p>终于不再互相有矛盾了。</p><p><strong>总结点如下：</strong></p><p>推导一个发送周期大小是关键<br>计算帧序号数是针对一个发送周期而言，不是特指1秒<br>给定的是帧范围，帧越大，帧数越少。帧数最大时需要最多的比特数，却可以说是满足最大信道利用率的最小比特数。</p><p>信道利用率总结专题 - Bing’s Blog - CSDN博客<br><a href="https://blog.csdn.net/u011240016/article/details/53141380" target="_blank" rel="noopener">https://blog.csdn.net/u011240016/article/details/53141380</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;T = P/C+RTT（RTT是往返时间）需要的在捎带确认中才有。否则针对每一个帧进行确认的话，发送周期是T = P/C+RTT&lt;br&gt;如果确认帧传输时延不可忽略，则T = P/C+RTT+P/C&lt;/p&gt;
&lt;p&gt;P是一帧长度，C是数据传输速率。&lt;/p&gt;
&lt;p&gt;以2015年一题为例。
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——并发编程volatile和synchronized关键字</title>
    <link href="http://yoursite.com/2019/03/04/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bvolatile%E5%92%8Csynchronized/"/>
    <id>http://yoursite.com/2019/03/04/JAVA笔记——并发编程volatile和synchronized/</id>
    <published>2019-03-04T13:49:12.561Z</published>
    <updated>2019-03-17T12:03:39.871Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized关键字：保证原子性和可见性</p><p>volatile关键字：保证可见性，不保证原子性</p><p>volatile可以保证修改的值立刻从工作内存被写入主存，且其他线程中该变量对应的缓存行被置位无效，从而需要重新读取主存</p><p>Java并发编程：volatile关键字解析 - Matrix海子 - 博客园<br><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;synchronized关键字：保证原子性和可见性&lt;/p&gt;
&lt;p&gt;volatile关键字：保证可见性，不保证原子性&lt;/p&gt;
&lt;p&gt;volatile可以保证修改的值立刻从工作内存被写入主存，且其他线程中该变量对应的缓存行被置位无效，从而需要重新读取主存&lt;/p&gt;
&lt;p&gt;Java
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>try-catch-finally的执行顺序[转]</title>
    <link href="http://yoursite.com/2019/02/26/try-catch-finally%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/26/try-catch-finally的执行顺序/</id>
    <published>2019-02-26T02:50:22.000Z</published>
    <updated>2019-02-26T02:54:45.928Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.cnblogs.com/superFish2016/p/6687549.html" target="_blank" rel="noopener">https://www.cnblogs.com/superFish2016/p/6687549.html</a></p><p>在网上看到一些异常处理的面试题，试着总结一下，先看下面代码，把这个方法在main中进行调用打印返回结果，看看结果输出什么。<a id="more"></a></p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static  int testBasic()&#123;</span><br><span class="line">        int i = 1; </span><br><span class="line">        try&#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(&quot;try block, i = &quot;+i);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            i ++;</span><br><span class="line">            System.out.println(&quot;catch block i = &quot;+i);</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            i = 10;</span><br><span class="line">            System.out.println(&quot;finally block i = &quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>没错，会按照顺序执行，先执行try内代码段，没有异常的话进入finally，最后返回，那么输出如下：</p><p>try block, i = 2<br>finally block i = 10<br>main test i = 10</p><p>这个没有问题，如果我们把return语句放入try catch里又会怎么样呢</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static  int testBasic()&#123;</span><br><span class="line">        int i = 1; </span><br><span class="line">        try&#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(&quot;try block, i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            i ++;</span><br><span class="line">            System.out.println(&quot;catch block i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            i = 10;</span><br><span class="line">            System.out.println(&quot;finally block i = &quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>输出结果是：</p><p>try block, i = 2<br>finally block i = 10<br>main test i = 2</p><p>代码顺序执行从try到finally，由于finally是无论如何都会执行的，所以try里的语句并不会直接返回。在try语句的return块中，return返回的引用变量并不是try语句外定义的引用变量i,而是系统重新定义了一个局部引用i’，这个引用指向了引用i对应的值，也就是2，即使在finally语句中把引用i指向了值10，因为return返回的引用已经不是i,而是i’,所以引用i的值和try语句中的返回值无关了。</p><p>但是，这只是一部分，如果把i换成包装类型而不是基本类型呢，来看看输出结果怎样，示例如下：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static  List&lt;Object&gt; testWrap()&#123;</span><br><span class="line">        List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        try&#123;</span><br><span class="line">            list.add(&quot;try&quot;);</span><br><span class="line">            System.out.println(&quot;try block&quot;);</span><br><span class="line">            return list;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            list.add(&quot;catch&quot;);</span><br><span class="line">            System.out.println(&quot;catch block&quot;);</span><br><span class="line">            return list;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            list.add(&quot;finally&quot;);</span><br><span class="line">            System.out.println(&quot;finally block &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>打印结果如下：</p><p>try block<br>finally block<br>main test i = [try, finally]</p><p>可以看到，finally里对list集合的操作生效了，这是为什么呢。我们知道基本类型在栈中存储，而对于非基本类型是存储在堆中的，返回的是堆中的地址，因此内容被改变了。</p><p>好了，现在我们在finally里加一个return，看看语句是从哪里返回的。</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static  int testBasic()&#123;</span><br><span class="line">        int i = 1; </span><br><span class="line">        try&#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(&quot;try block, i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            i ++;</span><br><span class="line">            System.out.println(&quot;catch block i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            i = 10;</span><br><span class="line">            System.out.println(&quot;finally block i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>输出结果如下：</p><p>try block, i = 2<br>finally block i = 10<br>main test i = 10</p><p>可以看到，是从finally语句块中返回的。可见，JVM是忽略了try中的return语句。但IDE中会对finally中加的return有黄色警告提示，这是为什么呢，在try里加入一行会执行异常的代码，如下：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static  int testBasic()&#123;</span><br><span class="line">        int i = 1; </span><br><span class="line">        try&#123;</span><br><span class="line">            i++;</span><br><span class="line">            int m = i / 0 ;</span><br><span class="line">            System.out.println(&quot;try block, i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            i ++;</span><br><span class="line">            System.out.println(&quot;catch block i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            i = 10;</span><br><span class="line">            System.out.println(&quot;finally block i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>打印结果如下：</p><p>catch block i = 3<br>finally block i = 10<br>main test i = 10</p><p>可以看到，因为finally中有return语句，try、catch中的异常被消化掉了，屏蔽了异常的发生，这与初期使用try、catch的初衷是相违背的，因此编译器也会提示警告。</p><p>那如果在finally中有异常发生，会对try、catch中的异常有什么影响呢？</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static  int testBasic()&#123;</span><br><span class="line">        int i = 1; </span><br><span class="line">        try&#123;</span><br><span class="line">            i++;</span><br><span class="line">            Integer.parseInt(null);</span><br><span class="line">            System.out.println(&quot;try block, i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            String.valueOf(null);</span><br><span class="line">            System.out.println(&quot;catch block i = &quot;+i);</span><br><span class="line">            return i;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            i = 10;</span><br><span class="line">            int m = i / 0;</span><br><span class="line">            System.out.println(&quot;finally block i = &quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>这里我们在try、catch里强行加上异常语句，打印结果如下：</p><p>Exception in thread “main” java.lang.ArithmeticException: / by zero<br>at tryandcatch.TryAndCatch.testBasic(TryAndCatch.java:25)<br>at tryandcatch.TryAndCatch.main(TryAndCatch.java:45)</p><p>这个提示表示的是finally里的异常信息，也就是说一旦finally里发生异常，try、catch里的异常信息即被消化掉了，也达不到异常信息处理的目的。</p><p>总结以上测试：</p><p>1、finally语句总会执行</p><p>2、如果try、catch中有return语句，finally中没有return，那么在finally中<strong>修改除包装类型和静态变量、全局变量</strong>以外的数据都不会对try、catch中返回的变量有任何的影响（<strong>包装类型、静态变量会改变、全局变量</strong>）</p><p>3、尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生</p><p>4、finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略</p><p><strong>所以在实际项目中，finally常常是用来关闭流或者数据库资源的，并不额外做其他操作。</strong></p><p><strong>另外如果在一个catch块中出现的异常，不会在后面的catch块被捕捉，而是会向上抛出</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/superFish2016/p/6687549.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/superFish2016/p/6687549.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在网上看到一些异常处理的面试题，试着总结一下，先看下面代码，把这个方法在main中进行调用打印返回结果，看看结果输出什么。
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————不用加减乘除做加法</title>
    <link href="http://yoursite.com/2019/02/11/LeetCode%E2%80%94%E2%80%94%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/11/LeetCode——不用加减乘除做加法/</id>
    <published>2019-02-11T02:37:22.000Z</published>
    <updated>2019-02-11T04:51:37.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p>解法一：投机取巧，用 += 运算符</p><p>解法二：用异或(^)表示加法，按位与(&amp;)表示进位，当进位为0时表示得到最后结果</p><p>例如： 5+7=12，三步走</p><ol><li>第一步：相加各位的值，不算进位，得到2。</li><li>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</li><li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>) &#123; <span class="comment">//只有进位为0才能停止</span></span><br><span class="line">            <span class="keyword">int</span> temp = num1 ^ num2; <span class="comment">//求异或，得到无进位的和</span></span><br><span class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>; <span class="comment">//左移位，表示进位</span></span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。&lt;/p&gt;
&lt;p&gt;解法一：投机取巧，用 += 运
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>谈谈HTTP协议中的短轮询、长轮询、长连接和短连接[转]</title>
    <link href="http://yoursite.com/2019/02/03/%E8%B0%88%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%5B%E8%BD%AC%5D/"/>
    <id>http://yoursite.com/2019/02/03/谈谈HTTP协议中的短轮询、长轮询、长连接和短连接[转]/</id>
    <published>2019-02-03T13:26:00.551Z</published>
    <updated>2019-02-18T08:23:49.967Z</updated>
    
    <content type="html"><![CDATA[<p>引言</p><p>最近刚到公司不到一个月，正处于熟悉项目和源码的阶段，因此最近经常会看一些源码。在研究一个项目的时候，源码里面用到了HTTP的长轮询。由于之前没太接触过，因此LZ便趁着这个机会，好好了解了一下HTTP的长长短短。</p><p>了解的方式主要都是LZ在网络上获取的，这里只是谈一下LZ对于这四种叫法最直观的理解。如果你之前不懂的话，可以帮你普及一下，如果你之前就懂得话，可以互相对照一下。</p><a id="more"></a><h3 id="以前的误解"><a href="#以前的误解" class="headerlink" title="以前的误解"></a>以前的误解</h3><p>很久之前LZ就听说过长连接的说法，而且还知道HTTP1.0协议不支持长连接，从HTTP1.1协议以后，连接默认都是长连接。但LZ终究觉得对于长连接一直懵懵懂懂的，有种抓不到关键点的感觉。</p><p>今天LZ通过一番研究，终于明白了这其中的奥秘。而之前，LZ也看过长连接相关的内容，但一直都是云里雾里的。这次之所以能在这么短的时间里搞清楚，和LZ自己技术的沉淀密不可分。因此，这里LZ借着这个机会，再次强调一下，千万不要试图去研究你研究了很久都整不明白的东西，或许是你的层次不到，也或许是你从未在实际的应用场景接触过，这种情况下你去研究，只会事倍功半，徒劳一番罢了。</p><p>回到正题，既然说是误解，那么LZ的误解到底是什么？</p><p>那就是LZ一直认为，HTTP连接分为长连接和短连接，而我们现在常用的都是HTTP1.1，因此我们用的都是长连接。</p><p>这句话其实只对了一半，我们现如今的HTTP协议，大部分都是1.1的，因此我们平时用的基本上都是长连接。但是前半句是不对的，HTTP协议根本没有长短连接这一说，也正因为误解了这个，导致LZ对于长连接一直不明不白，始终不得其要领，具体下面一段会说到。</p><p>网络上很多文章都是误人子弟，根本没有说明白这个概念。这里LZ要强调一下，<strong>HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了</strong>，或者更准确的说，是本次HTTP请求就结束了，根本没有长连接这一说。那么自然也就没有短连接这一说了。</p><p>之所以网络上说HTTP分为长连接和短连接，其实本质上是说的TCP连接。<strong>TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说</strong>。</p><p>其实知道了以后，会觉得这很好理解。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。</p><p>一个形象的例子就是，拿你在网上购物来说，HTTP协议是指的那个快递单，你寄件的时候填的单子就像是发了一个HTTP请求，等货物运到地方了，快递员会根据你发的请求把货物送给相应的收货人。而TCP协议就是中间运货的那个大货车，也可能是火车或者飞机，但不管是什么，它是负责运输的，因此必须要有路，不管是地上还是天上。那么这个路就是所谓的TCP连接，也就是一个双向的数据通道。</p><p>因此，LZ现在甚至觉得，“HTTP连接”这个词就不应该出现，它只是一个应用层的协议，根本就没有所谓的连接这一说，就像FTP也是应用层的协议，但是你有听说过FTP连接吗？（恩，好像是听过，-_-，但你现在知道了，其实所谓的FTP连接，严格来说，依旧是TCP连接）</p><p>实际上，说HTTP请求和HTTP响应会更准确一些，而HTTP请求和HTTP响应，都是通过TCP连接这个通道来回传输的。</p><p><strong>不管怎么说，一定要务必记住，长连接是指的TCP连接，而不是HTTP连接。</strong></p><h3 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h3><p>之前LZ一直对一件事有些模糊不清，首先是怎么样就算是把HTTP变成长连接了，是不是只要设置Connection为keep-alive就算是了？</p><p>如果是的话，那都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接，但是长连接不是一般用于交互比较频繁的应用吗？像我们这种普通的Web应用，比如博客园这种，或者我的个人博客这种，长连接有什么用？</p><p>如果有用那用处到底是什么，我们又不是客户端与服务器交互频繁的那种应用（毕竟你打开网页肯定要半天才打开另外一个吧），如果没用的话，那到底应不应该把Connection为keep-alive这个header值给改掉，从而改成短连接？</p><p>这个疑问，在LZ明白了长连接其实是指的TCP连接之后，基本上就明白了。而这个疑问，也正是LZ在“以前的误解”那一段所提到的，那个因为误解导致LZ一直搞不明白的问题。</p><p>为什么解决了上面那个误解之后，前面所说的这些疑问LZ都明白了？</p><p>因为长连接意味着连接会被复用，毕竟一直保持着连接不就是为了重复使用嘛。但如果长连接是指的HTTP的话，那就是说HTTP连接可以被重复利用，这个话听起来就感觉很别扭。之所以觉得别扭，其实就是LZ的一种直觉，没什么理论依据。而这种别扭的根源就在于，之前一直没有融会贯通的感觉，所以总感觉缺少点什么。不过这点疑惑，并没有影响LZ的工作，因此也就没深究过。</p><p>但现在好了，明白了长连接实际上是指的TCP连接，LZ瞬间自己就想明白了上面的那些问题。</p><p>第一个问题是，是不是只要设置Connection为keep-alive就算是长连接了？</p><p>当然是的，但要服务器和客户端都设置。</p><p>第二个问题是，我们平时用的是不是长连接？</p><p>这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）</p><p>第三个问题，也是LZ之前最想不明白的问题，那就是我们这种普通的Web应用（比如博客园，我的个人博客这种）用长连接有啥好处？需不需要关掉长连接而使用短连接？</p><p>这个问题LZ现在终于明白了，问题的答案是好处还是有的。</p><p>好处是什么？</p><p>首先，刚才已经说了，长连接是为了复用，这个在之前LZ就明白。那既然长连接是指的TCP连接，也就是说复用的是TCP连接。那这就很好解释了，也就是说，长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。</p><p>比如你请求了博客园的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源就不用LZ去说了吧。</p><p>但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。</p><p>这样一解释，就很明白了，不知道大家看了这些解释感觉如何，反正LZ在自己想明白以后，有种豁然开朗的感觉。</p><p>另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。</p><p>这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？</p><h3 id="长轮询和短轮询"><a href="#长轮询和短轮询" class="headerlink" title="长轮询和短轮询"></a>长轮询和短轮询</h3><p>前面基本上LZ已经把长短连接说的差不多了，接下来说说长短轮询，今天也正是为了研究长短轮询，LZ才顺便研究了下长短连接这回事。</p><p>短轮询相信大家都不难理解，比如你现在要做一个电商中商品详情的页面，这个详情界面中有一个字段是库存量（相信这个大家都不陌生，随便打开淘宝或者京东都能找到这种页面）。而这个库存量需要实时的变化，保持和服务器里实际的库存一致。</p><p>这个时候，你会怎么做？</p><p>最简单的一种方式，就是你用JS写个死循环，不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。</p><p>这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。</p><p>那怎么办呢？</p><p>长轮询这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。</p><p>而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。</p><p>这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。</p><p>但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。</p><p>因此，从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。之所以举这个例子，只是因为大家肯定都会网购，所以这个例子比较通俗一点。</p><p>哪怕轮询解决不了获取库存这个问题，但只要大家明白了长短轮询的区别，这就足够了。实际上，据LZ自己平日里购物的观察，那个库存量应该是不会变的，这个例子纯属LZ个人的意淫，-_-。</p><h3 id="长短轮询和长短连接的区别"><a href="#长短轮询和长短连接的区别" class="headerlink" title="长短轮询和长短连接的区别"></a>长短轮询和长短连接的区别</h3><p>这里简单说一下它们的区别，LZ这里只说最根本的区别。</p><p>第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。</p><p>第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>好了，本文就到此为止吧。LZ写这篇文章，主要也是为了避免自己遗忘。说实话，写到最后了，LZ感觉对于它们的理解又进了一步，这就是写博客的好处吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引言&lt;/p&gt;
&lt;p&gt;最近刚到公司不到一个月，正处于熟悉项目和源码的阶段，因此最近经常会看一些源码。在研究一个项目的时候，源码里面用到了HTTP的长轮询。由于之前没太接触过，因此LZ便趁着这个机会，好好了解了一下HTTP的长长短短。&lt;/p&gt;
&lt;p&gt;了解的方式主要都是LZ在网络上获取的，这里只是谈一下LZ对于这四种叫法最直观的理解。如果你之前不懂的话，可以帮你普及一下，如果你之前就懂得话，可以互相对照一下。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——父子类的加载执行顺序</title>
    <link href="http://yoursite.com/2019/02/03/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E7%88%B6%E5%AD%90%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/03/JAVA笔记—父子类的加载执行顺序/</id>
    <published>2019-02-03T02:59:26.620Z</published>
    <updated>2019-02-03T03:40:45.233Z</updated>
    
    <content type="html"><![CDATA[<p><strong>类的加载顺序</strong></p><ul><li>（1）父类静态代码块（包括静态初始化块，静态属性，但不包括静态方法）</li><li>（2）子类静态代码块（包括静态初始化块，静态属性，但不包括静态方法）</li><li>（3）父类非静态代码块（包括非静态初始化块，非静态属性）</li><li>（4）父类构造函数</li><li>（5）子类非静态代码块（包括非静态初始化块，非静态属性）</li><li>（6）子类构造函数</li></ul><p><strong>类的执行顺序</strong></p><ul><li>（1）父类静态变量和静态代码块（先声明的先执行）</li><li>（2）子类静态变量和静态代码块（先声明的先执行）</li><li>（3）父类的非静态属性（变量）和非静态代码块（先声明的先执行）</li><li>（4）父类构造函数</li><li>（5）子类的非静态属性（变量）和非静态代码块（先声明的先执行）</li><li>（6）子类构造函数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;类的加载顺序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（1）父类静态代码块（包括静态初始化块，静态属性，但不包括静态方法）&lt;/li&gt;
&lt;li&gt;（2）子类静态代码块（包括静态初始化块，静态属性，但不包括静态方法）&lt;/li&gt;
&lt;li&gt;（3）父类非静态代码块（
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——JVM内存区域划分[转载]</title>
    <link href="http://yoursite.com/2019/01/29/JAVA%E7%AC%94%E8%AE%B0%E2%80%94JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%5B%E8%BD%AC%5D/"/>
    <id>http://yoursite.com/2019/01/29/JAVA笔记—JVM内存区域划分[转]/</id>
    <published>2019-01-29T09:50:32.492Z</published>
    <updated>2019-01-29T12:11:29.954Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到一个JVM的比较有意思的帖子，比较形象生动，此处记录一下。</p><p>JVM内存区域划分Eden Space、Survivor Space、Tenured Gen，Perm Gen解释 - kaixinmao1987 - 博客园<br><a href="https://www.cnblogs.com/kxm87/p/7205414.html" target="_blank" rel="noopener">https://www.cnblogs.com/kxm87/p/7205414.html</a></p><p>[译]GC专家系列1：理解Java垃圾回收 - 牧曦之晨 - SegmentFault 思否<br><a href="https://segmentfault.com/a/1190000004233812" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004233812</a></p><hr><p>jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。<a id="more"></a></p><p>HotSpot虚拟机GC算法采用分代收集算法：</p><p>1、一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。</p><p>2、并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。</p><p>3、进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。</p><p>分区的目的：新生区由于对象产生的比较多并且大都是朝生夕灭的，所以直接采用标记-清理算法。而养老区生命力很强，则采用复制算法，针对不同情况使用不同算法。</p><p>非heap区域中Perm Gen中放着类、方法的定义，jvm Stack区域放着方法参数、局域变量等的引用，方法执行顺序按照栈的先入后出方式。</p><p>以上转自：<a href="http://lhc1986.iteye.com/blog/1421832" target="_blank" rel="noopener">http://lhc1986.iteye.com/blog/1421832</a></p><p>以下转自：<a href="http://www.cnblogs.com/xhr8334/archive/2011/12/01/2270994.html" target="_blank" rel="noopener">http://www.cnblogs.com/xhr8334/archive/2011/12/01/2270994.html</a></p><p>JVM在程序运行过程当中，会创建大量的对象，这些对象，大部分是短周期的对象，小部分是长周期的对象，对于短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉，对于长周期对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测。为解决这种矛盾，Sun JVM的内存管理采用分代的策略。</p><p>​      1）年轻代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）。当对象在堆创建时，将进入年轻代的Eden Space。垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制到Old Gen。同时，在扫描Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个持久化对象，则将其移到Old Gen。扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色（即下次垃圾回收时会扫描Eden Space和BSuvivor Space。这么做主要是为了减少内存碎片的产生。</p><p>​      我们可以看到：Young Gen垃圾回收时，采用将存活对象复制到到空的Suvivor Space的方式来确保尽量不存在内存碎片，采用空间换时间的方式来加速内存中不再被持有的对象尽快能够得到回收。<br>​      2）年老代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。<br>​      3）持久代(Perm Gen)：持久代主要存放类定义、字节码和常量等很少会变更的信息。</p><p><img src="\uploads\JAVA笔记\2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看到一个JVM的比较有意思的帖子，比较形象生动，此处记录一下。&lt;/p&gt;
&lt;p&gt;JVM内存区域划分Eden Space、Survivor Space、Tenured Gen，Perm Gen解释 - kaixinmao1987 - 博客园&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/kxm87/p/7205414.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/kxm87/p/7205414.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[译]GC专家系列1：理解Java垃圾回收 - 牧曦之晨 - SegmentFault 思否&lt;br&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000004233812&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000004233812&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——String中的intern()方法[转载]</title>
    <link href="http://yoursite.com/2019/01/25/JAVA%E7%AC%94%E8%AE%B0%E2%80%94String%E4%B8%AD%E7%9A%84intern()%E6%96%B9%E6%B3%95%5B%E8%BD%AC%5D/"/>
    <id>http://yoursite.com/2019/01/25/JAVA笔记—String中的intern()方法[转]/</id>
    <published>2019-01-24T17:38:42.684Z</published>
    <updated>2019-01-29T12:11:03.593Z</updated>
    
    <content type="html"><![CDATA[<p>文章是转载的网上一篇博客，感觉写的比较清楚</p><p>对String中intern()方法的认识 - 董_不懂的博客 - CSDN博客<br><a href="https://blog.csdn.net/believesoul/article/details/79588305" target="_blank" rel="noopener">https://blog.csdn.net/believesoul/article/details/79588305</a></p><hr><p>最近在看字符串相关知识的时候，又看到了关于字符串创建方式和是否相等的相关问题，回忆起之前碰到的一个String中的intern()方法，它是一个本地方法（由Java语言外的语言编写），因此在jdk1.8源码中没有其实现，不过有一段描述，讲述了它的作用。<br>intern()方法的描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment"> * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment"> * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment"> * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment"> * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment"> * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java™ Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment"> *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>归纳一下的话，它的作用在<strong>jdk1.7之后</strong>是查看常量池中是否存在和调用方法的字符串内容一样的字符串，如果有的话，就返回该常量池中的字符串，若没有的话，就在常量池中写入一个堆中该字符串对象的一个引用，指向堆中的该对象，并返回该引用。<br>用代码说话吧，注释中有我对intern()方法的理解，过程中查阅了部分源码和相关博客，如果有谬误，请大家指出，互相交流学习，共同进步。 </p><p><strong>intern方法的测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        <span class="comment">// 第一次，创建了两个对象，一个是堆中的string对象，一个是常量池中的"abc"</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        <span class="comment">// 第二次，创建一个对象，堆中的另外一个string对象</span></span><br><span class="line">        System.out.println(a.intern() == b.intern());<span class="comment">// true</span></span><br><span class="line">        System.out.println(a.intern() == b);<span class="comment">// false</span></span><br><span class="line">        System.out.println(a.intern() == a);<span class="comment">// false</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * intern方法会到常量池中查找是否存在该对象，如果存在，返回该对象。不存在的话就创建该对象并返回该对象(jdk1.6),(jdk1.7)</span></span><br><span class="line"><span class="comment">         * 会在常量池中存一个指向堆中的那个对象的引用。 不存在往往是String s3 = new String("1") + new</span></span><br><span class="line"><span class="comment">         * String("1");这种形式，会在堆中有一个s3指向的11的对象和常量池中的1对象</span></span><br><span class="line"><span class="comment">         * 在这里就是体现的堆中的内存地址不一样，但对应的同一个常量池中的string 第一个比较时常量池中的该对象和自身比较</span></span><br><span class="line"><span class="comment">         * 下面两个比较则是常量池中的对象和堆中的两个对象进行比较</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String poolstr = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">// 直接从字符串常量池中获取</span></span><br><span class="line">        System.out.println(a.intern() == poolstr);<span class="comment">// true</span></span><br><span class="line">        System.out.println(b.intern() == poolstr);<span class="comment">// true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里新声明并赋值了一个poolstr，值为常量池中的字符串"abc",将它和a.intern()和b.inten()比较就是和自身比较</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">        System.out.println(str.intern() == str);<span class="comment">// true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * str创建了3个对象，在堆中有一个"ab"，在常量池中有一个"a"和"b" 比较str.intern()和str会得到true</span></span><br><span class="line"><span class="comment">         * 在jdk1.7之后，会在常量池中存一个指向堆中的那个对象的引用。</span></span><br><span class="line"><span class="comment">         * 调用str.intern()会在常量池中存储一个指向堆中"ab"的引用，也就是说它和堆中的对象实际是等价的，因此==时返回true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String strtwo = <span class="string">"ab"</span>;</span><br><span class="line">        System.out.println(strtwo == str);<span class="comment">// true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 常量池中已存在ab，所以会直接将strtwo指向常量池中的"ab",即堆中str对象的引用，因此相等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有提到一个new String（“”）会创建几个对象，一般就是一个或两个，主要是看常量池中是否已经有了该字符串，在上述代码在也有所提及。<br>对于每一个比较语句我都做了自己的理解的标注，比较通俗易懂，仔细看一下就能理解intern方法的作用，另外附上一篇博文，是一篇讲述intern方法的实现原理的博文，对我理解intern方法有很大帮助，感兴趣的朋友可以看一下。<br>Java技术——你真的了解String类的intern()方法吗<br>其中提到了jdk1.7将常量池从方法区中转移到堆中对intern()方法的影响，非常清晰的描述了差别，配合本博文实例更适宜使用，本博文更多的从实现角度来解析intern()方法，希望对您有所帮助<br>如有谬误，敬请指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章是转载的网上一篇博客，感觉写的比较清楚&lt;/p&gt;
&lt;p&gt;对String中intern()方法的认识 - 董_不懂的博客 - CSDN博客&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/believesoul/article/details/79588305&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/believesoul/article/details/79588305&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最近在看字符串相关知识的时候，又看到了关于字符串创建方式和是否相等的相关问题，回忆起之前碰到的一个String中的intern()方法，它是一个本地方法（由Java语言外的语言编写），因此在jdk1.8源码中没有其实现，不过有一段描述，讲述了它的作用。&lt;br&gt;intern()方法的描述&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Returns a canonical representation for the string object.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * A pool of strings, initially empty, is maintained privately by the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * class &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; String&amp;#125;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * When the intern method is invoked, if the pool already contains a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * string equal to this &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; String&amp;#125; object as determined by&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * the &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; #equals(Object)&amp;#125; method, then the string from the pool is&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * returned. Otherwise, this &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; String&amp;#125; object is added to the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * pool and a reference to this &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; String&amp;#125; object is returned.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * It follows that for any two strings &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; s&amp;#125; and &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; t&amp;#125;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; s.intern() == t.intern()&amp;#125; is &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; true&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * if and only if &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; s.equals(t)&amp;#125; is &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; true&amp;#125;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * All literal strings and string-valued constant expressions are&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * interned. String literals are defined in section 3.10.5 of the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;lt;cite&amp;gt;The Java™ Language Specification&amp;lt;/cite&amp;gt;.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;  a string that has the same contents as this string, but is&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *          guaranteed to be from a pool of unique strings.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;intern&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="常量池" scheme="http://yoursite.com/tags/%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ在windows配置安装</title>
    <link href="http://yoursite.com/2019/01/11/RocketMQ%E5%9C%A8windows%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/01/11/RocketMQ在windows配置安装/</id>
    <published>2019-01-11T05:37:22.000Z</published>
    <updated>2019-01-11T05:44:31.849Z</updated>
    
    <content type="html"><![CDATA[<p>配置过程不麻烦，就是有点小插曲</p><p>教程参考： <a href="https://yq.aliyun.com/articles/656078" target="_blank" rel="noopener">https://yq.aliyun.com/articles/656078</a>   </p><p>​           <a href="https://www.jianshu.com/p/4a275e779afa" target="_blank" rel="noopener">https://www.jianshu.com/p/4a275e779afa</a></p><p><strong>注意：</strong>过程中需要对JVM configuration 修改一下 内存 ： 修改<strong>runserver.sh</strong>和<strong>runbroker.sh</strong>，两个分别对应nameserver和broker的配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="string">"JAVA_OPT=%JAVA_OPT% -server -Xms2g -Xmx2g -Xmn1g"</span></span><br></pre></td></tr></table></figure><p>另外 如果启动broker出现找不到XXXXX主类的错误，把 %CLASSPATH% 加上双引号，修改为 “%CLASSPATH%” 就可以了</p><p><a href="https://blog.csdn.net/lvwenzhuye/article/details/81483479" target="_blank" rel="noopener">https://blog.csdn.net/lvwenzhuye/article/details/81483479</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;配置过程不麻烦，就是有点小插曲&lt;/p&gt;
&lt;p&gt;教程参考： &lt;a href=&quot;https://yq.aliyun.com/articles/656078&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://yq.aliyun.com/article
      
    
    </summary>
    
      <category term="RocketMQ" scheme="http://yoursite.com/categories/RocketMQ/"/>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>大数据——hashMap put函数 重复插入相同(key,value)的问题</title>
    <link href="http://yoursite.com/2018/12/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94hashMap%E7%9A%84put%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/12/28/大数据——hashMap的put重复插入问题/</id>
    <published>2018-12-27T16:31:26.088Z</published>
    <updated>2018-12-27T16:42:56.566Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">writer = SequenceFile.createWriter(fs, conf, path, key.getClass(), value.getClass());</span><br><span class="line"><span class="keyword">for</span>(File dir:dirs)&#123;</span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line"><span class="comment">//key：目录名+":"+文件名</span></span><br><span class="line">key.set(dir.getName() + <span class="string">":"</span> + file.getName());</span><br><span class="line"><span class="comment">//value：文件内容</span></span><br><span class="line">value.set(fileToString(file));</span><br><span class="line">fileContents.put(key, value); <span class="comment">//////////////////////////A</span></span><br><span class="line">fileContents.put(<span class="keyword">new</span> Text(dir.getName() + <span class="string">":"</span> + file.getName()), <span class="keyword">new</span> Text(fileToString(file))); <span class="comment">/////////////////////////////B</span></span><br><span class="line">writer.append(key, value);</span><br><span class="line"><span class="comment">//System.out.println(key + "\t" + value);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">IOUtils.closeStream(writer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天做基于hadoop的朴素贝叶斯文档分类时，遇到一个问题：注意代码块中的A和B，最开始使用A时我发现hashMap内存储的都是同一个(key，value)对，改成B就可以了，目测应该是key和value对数据引用后，修改key和value导致hash值变化了。</p><p>具体类比资料：hashmap出现重复key的情况 - qq_29909965的博客 - CSDN博客<br><a href="https://blog.csdn.net/qq_29909965/article/details/78358066" target="_blank" rel="noopener">https://blog.csdn.net/qq_29909965/article/details/78358066</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——类的访问权限</title>
    <link href="http://yoursite.com/2018/12/17/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2018/12/17/JAVA笔记—类的访问权限/</id>
    <published>2018-12-17T01:35:12.815Z</published>
    <updated>2018-12-17T01:38:50.758Z</updated>
    
    <content type="html"><![CDATA[<p><img src="\uploads\JAVA笔记\1.png" alt="1"></p><p>如果一个类的成员没有任何权限修饰，那么它门就是缺省包访问权限，用friendly来表示，注意friendly不是Java中的关键字，这里是个人喜欢的方式用它表示而已。同一个包内其它类可以访问，但包外就不可以。对于同一个文件夹下的、没有用package的classes，Java会自动将这些classes初见为隶属于该目录的default package，可以相互调用class中的friendly成员。</p><p>如以下两个class分别在同一个文件夹的两个文件中，虽然没有引入package，但隶属于相同的default package。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sundae</span></span>&#123;</span><br><span class="line">　　 <span class="comment">//以下两个方法缺省为friendly</span></span><br><span class="line">　　 Sundae()&#123;&#125;</span><br><span class="line">　　 <span class="function">Void <span class="title">f</span><span class="params">()</span> </span>&#123;System.out.println(“Sundae.f()”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">　　 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　 Sundae x = <span class="keyword">new</span> Sundae();</span><br><span class="line">　　 x.f();</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类来说：同一个包中的类可以用。总之，类只可以声明为public或者friendly。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;\uploads\JAVA笔记\1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果一个类的成员没有任何权限修饰，那么它门就是缺省包访问权限，用friendly来表示，注意friendly不是Java中的关键字，这里是个人喜欢的方式用它表示而已。同一个包内
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————9.回文数</title>
    <link href="http://yoursite.com/2018/12/16/LeetCode%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://yoursite.com/2018/12/16/LeetCode——回文数/</id>
    <published>2018-12-16T06:50:22.000Z</published>
    <updated>2018-12-16T08:07:43.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（简单）"><a href="#题目（简单）" class="headerlink" title="题目（简单）"></a><strong>题目（简单）</strong></h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p>输入: 10</p><p>输出: false</p><p>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h4 id="方法：反转一半数字"><a href="#方法：反转一半数字" class="headerlink" title="方法：反转一半数字"></a>方法：反转一半数字</h4><p><strong>思路</strong></p><p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p><p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。 但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。</p><p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><p>例如，输入 <code>1221</code>，我们可以将数字“12<strong>21</strong>”的后半部分从“<strong>21</strong>”反转为“<strong>12</strong>”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 <code>1221</code> 是回文。</p><p>让我们看看如何将这个想法转化为一个算法。</p><p><strong>算法</strong></p><p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 <code>-</code> 不等于 <code>3</code>。所以我们可以对所有负数返回 false。</p><p>现在，让我们来考虑如何反转后半部分的数字。 对于数字 <code>1221</code>，如果执行 <code>1221 % 10</code>，我们将得到最后一位数字 <code>1</code>，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 <code>1221</code> 中移除，<code>1221 / 10 = 122</code>，再求出上一步结果除以10的余数，<code>122 % 10 = 2</code>，就可以得到倒数第二位数字。如果我们把最后一位数字乘以10，再加上倒数第二位数字，<code>1 * 10 + 2 = 12</code>，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。</p><p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> bool <span class="title">IsPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log<sub>10</sub>(n)， 对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(log<sub>10</sub>(n)。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目（简单）&quot;&gt;&lt;a href=&quot;#题目（简单）&quot; class=&quot;headerlink&quot; title=&quot;题目（简单）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（简单）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————7.整数反转</title>
    <link href="http://yoursite.com/2018/12/07/LeetCode%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/12/07/LeetCode——整数反转/</id>
    <published>2018-12-06T16:37:22.000Z</published>
    <updated>2018-12-06T17:42:55.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（简单）"><a href="#题目（简单）" class="headerlink" title="题目（简单）"></a><strong>题目（简单）</strong></h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，<strong>如果反转后整数溢出那么就返回 0。</strong><a id="more"></a></p><hr><p>题目很明确，很自然的想法就是通过除法和取余逐位取出，再依次乘10加余数达到反向效果，但是也有一点就是<strong>做乘法时可能会出现溢出的情况</strong>。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>反转整数的方法可以与反转字符串进行类比。</p><p>我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。</p><p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop operation:</span></span><br><span class="line">pop = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push operation:</span></span><br><span class="line">temp = rev * <span class="number">10</span> + pop;</span><br><span class="line">rev = temp;</span><br></pre></td></tr></table></figure><p>但是，这种方法很危险，因为当 temp=rev⋅10+pop 时会导致溢出。</p><p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p><p>为了便于解释，我们假设 rev 是正数。</p><p><img src="\uploads\LeetCode\2.png" alt="2"></p><p>这里要补充两点：</p><p>1.显然因为top只能是处于0~9的个位数字，所以若rev·10+top溢出，那么rev&gt;=INTMAX/10必然成立。</p><p>2.若rev==INTMAX/10，若pop&gt;7(假设为8)，那么反转前肯定是8xxxxxxxx，显然超出了Int的范围，所以top&lt;=7一定成立的。</p><p>当 rev 为负时可以应用类似的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> X =x;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">X = -x;</span><br><span class="line"><span class="keyword">int</span> rev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(X&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> end = X%<span class="number">10</span>;</span><br><span class="line">        X = X/<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(rev&gt;<span class="number">214748364</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rev = rev*<span class="number">10</span>+end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">        rev = -rev;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE/<span class="number">10</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE/<span class="number">10</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(log<sub>10</sub>(n))，因为每次都通过除以10取出尾数位。</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（简单）&quot;&gt;&lt;a href=&quot;#题目（简单）&quot; class=&quot;headerlink&quot; title=&quot;题目（简单）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（简单）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; &lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: -123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，&lt;strong&gt;如果反转后整数溢出那么就返回 0。&lt;/strong&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————5.最长回文子串(常考)</title>
    <link href="http://yoursite.com/2018/12/06/LeetCode%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/12/06/LeetCode——最长回文子串/</id>
    <published>2018-12-06T09:37:22.000Z</published>
    <updated>2018-12-06T15:41:19.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（中等）"><a href="#题目（中等）" class="headerlink" title="题目（中等）"></a><strong>题目（中等）</strong></h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><a id="more"></a> <hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><h3 id="1-最大公共子串法"><a href="#1-最大公共子串法" class="headerlink" title="1.最大公共子串法"></a>1.最大公共子串法</h3><p>第一个比较容易的想法可能就是 把字符串S反转过来，记为S’，先使用<strong>动态规划方法</strong>找到S与S’之间的最长公共子串，即所求的最长回文子串。</p><p>例如，S = “caba” , S’ = “abac”, S 以及 S’ 之间的最长公共子串为 “aba”，恰恰是答案。</p><p>让我们尝试一下这个例子：S = “abacdfgdcaba” , S’ = “abacdgfdcaba”, S 以及 S’之间的最长公共子串为 “abacd”，显然，这不是回文。</p><p>我们可以看到，当 S 的其他部分中存在非回文子串的反向副本时(即例子中的abacd和dcaba)，最长公共子串法就会失败。为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要<strong>检查子串的索引是否与反向子串的原始索引相同</strong>。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。</p><p>这里要解释一下上面加粗的那句，即判断条件，比如”caba”这个串，反转找到的最长公共子串是”aba”，它在”cab<strong>a</strong>“的结束索引为<strong>3</strong>（不是1是因为最长公共子串找到的索引是<strong>结束索引</strong>）；在反向串”ab<strong>a</strong>c”中的<strong>结束索引</strong>为<strong>2</strong>，我们要找的<strong>原始索引</strong>就是在反向串中的<strong>反向索引</strong>，即”aba”的<strong>开始索引</strong>（串长 4-1-<strong>结束索引2</strong>=4-1-2=<strong>1</strong>）加上该最大公共子串长度3再减1（即<strong>1</strong>+3-1=<strong>3</strong>）因为反向索引<strong>3</strong>和原串的索引<strong>3</strong>相等，所以认定这是个回文串，而不是反向副本；再比如”abacdfgdcaba”，找到的公共子串”abacd”的<strong>结束索引</strong>为<strong>4</strong>，<strong>开始索引</strong>=12-1-4=7，又因为最大公共子串长为5，所以反向串中的<strong>原始索引</strong>就为7+5-1=11，这与原串的结束索引4不等，所以这是个反向副本，而不是回文数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line">   <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        String s1 = s;</span><br><span class="line">        String s2 = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">        String str=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l1 = s1.length();</span><br><span class="line"><span class="keyword">int</span> l2 = s2.length();</span><br><span class="line"><span class="keyword">int</span> max_index1[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">int</span> max_index2[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> array[][] = <span class="keyword">new</span> <span class="keyword">int</span>[l1][l2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;s.length();++t)</span><br><span class="line">&#123;</span><br><span class="line">max_index1[t] = -<span class="number">1</span>;</span><br><span class="line">max_index2[t] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;l2;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">array[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">array[i][j] = array[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(array[i][j] &gt; max_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r_index2 = s.length()-j-<span class="number">1</span>;  <span class="comment">//判断是否是回文而不是反向副本</span></span><br><span class="line"><span class="keyword">if</span>(i == r_index2+array[i][j]-<span class="number">1</span>)  <span class="comment">//判断是否是回文而不是反向副本</span></span><br><span class="line">&#123;</span><br><span class="line">max_len = array[i][j];</span><br><span class="line">max_index1[<span class="number">0</span>] = i;</span><br><span class="line">max_index2[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;s.length();++t)</span><br><span class="line">&#123;</span><br><span class="line">max_index1[t] = -<span class="number">1</span>;</span><br><span class="line">max_index2[t] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">array[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(max_index1[<span class="number">0</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">str = (s1.substring(max_index1[<span class="number">0</span>]-max_len+<span class="number">1</span>,max_index1[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line">System.out.print(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：因为是动态规划，所以是O(n<sup>2</sup>)。</p><p>空间复杂度：因为用了空间换时间，所以是O(n<sup>2</sup>)。其实还可以通过<strong>把Array二维数组转换为一维</strong>，因为每次循环都是固定i，内部循环j，而第3行的数据其实只用到之前第2行的数据，不需要第1行的，所以每次用一维数组重复利用，做数据更新就可以了。这样空间复杂度就缩小到了O(n)。</p><h3 id="2-暴力法"><a href="#2-暴力法" class="headerlink" title="2.暴力法"></a>2.暴力法</h3><p>很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。但是暴力法面对比如”zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz”这样的超长回文串，就会因为时间开销太大而超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_index = -<span class="number">1</span>;</span><br><span class="line">String str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> start = i,end = j;</span><br><span class="line"><span class="keyword">while</span>(s.charAt(start) == s.charAt(end))</span><br><span class="line">&#123;</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line"><span class="keyword">if</span>(end&lt;<span class="number">0</span> || start&gt;s.length()-<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(start &gt;= end &amp;&amp; j-i+<span class="number">1</span> &gt; max_len)</span><br><span class="line">&#123;</span><br><span class="line">max_len = j-i+<span class="number">1</span>;</span><br><span class="line">max_index = j;</span><br><span class="line">str = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n<sup>3</sup>)，因为要进行N<em>N的循环，每次循环还要遍历根据初始位置start和结束位置end找出的子串判断是否是回文串，所以为N </em> N * N。</p><p>空间复杂度：O(1)</p><h3 id="3-动态规划法"><a href="#3-动态规划法" class="headerlink" title="3.动态规划法"></a>3.动态规划法</h3><p>为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，“ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。</p><p>我们给出 P(i,j) 的定义如下：</p><p><img src="\uploads\LeetCode\1.png" alt="1"></p><p>基本示例如下：</p><p>P(i, i) = true</p><p>P(i, i+1) = (Si==Si+1)</p><p>这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len[]=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">//记录是否为回文串，不是就记为0，是的就记录回文串长度</span></span><br><span class="line"><span class="keyword">int</span> max_len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_index=<span class="number">0</span>;</span><br><span class="line">String str=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()-<span class="number">1</span>;j&gt;=i;--j)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(i == j)  <span class="comment">//边界（奇数）</span></span><br><span class="line">   len[j] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(Math.abs(i-j)==<span class="number">1</span>) <span class="comment">//边界（偶数）</span></span><br><span class="line">   &#123;</span><br><span class="line">   len[j] = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   len[j] = len[j-<span class="number">1</span>]==<span class="number">0</span>? <span class="number">0</span>:len[j-<span class="number">1</span>]+<span class="number">2</span>;  <span class="comment">//判断内部子串是不是回文串，不是为false，是的就记录回文串长度</span></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   len[j] = <span class="number">0</span>;  <span class="comment">//不是回文串</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(len[j]&gt;max_len)</span><br><span class="line">   &#123;</span><br><span class="line">   max_len = len[j];</span><br><span class="line">   max_index = j;</span><br><span class="line">   str = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n<sup>2</sup>)</p><p>空间复杂度：正常情况下是O(n<sup>2</sup>)， 因为动态规划方法使用 O(n<sup>2</sup>)的空间来存储表。同样的，这个空间复杂度可以优化到<strong>O(n)</strong>，<strong>空间复杂度：O(n^2)O(n2)， 该方法使用 O(n^2)O(n2) 的空间来存储表。</strong></p><h3 id="4-中心扩展法"><a href="#4-中心扩展法" class="headerlink" title="4.中心扩展法"></a>4.中心扩展法</h3><p>事实上，只需使用恒定的空间，我们就可以在 O(n<sup>2</sup>) 的时间内解决这个问题。</p><p>我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。</p><p>你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个 ‘b’ 之间）。所以找奇数长度的回文串时可以遍历n个中心（也就是n个字符均作为一次中心），找偶数长度回文串时可以遍历n-1个中心（也就是n个字符之间的空隙均作为一次中心），加起来就是n+n-1=2n-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len=<span class="number">0</span>,length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start=-<span class="number">1</span>,end=-<span class="number">1</span>;</span><br><span class="line">String str=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = expandAroundCenter(s,i,i);</span><br><span class="line"><span class="keyword">int</span> len2 = expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">length = (len1&gt;len2)?len1:len2;</span><br><span class="line"><span class="keyword">if</span>(length&gt;max_len)</span><br><span class="line">&#123;</span><br><span class="line">max_len = length;</span><br><span class="line">start = i-((length+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>);</span><br><span class="line">end = start+length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str = s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>  <span class="comment">//从left/right的中心开始扩展</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L=left,R=right;</span><br><span class="line"><span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;=s.length()-<span class="number">1</span> &amp;&amp; s.charAt(L)==s.charAt(R))</span><br><span class="line">&#123;</span><br><span class="line">L--;</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> R-L-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n<sup>2</sup>)， 由于围绕中心来扩展回文会耗去 O(n) 的时间，所以总的复杂度为 O(n<sup>2</sup>)。</li><li>空间复杂度：O(1)。 </li></ul><h3 id="5-Manacher-马拉车算法"><a href="#5-Manacher-马拉车算法" class="headerlink" title="5.Manacher 马拉车算法"></a>5.Manacher 马拉车算法</h3><p>这个算法比较复杂，可以把时间复杂度和空闲复杂度都缩减到O(n)，建议多查看一些资料，此处不做叙述。</p><p>参考资料：Longest Palindromic Substring Part II – LeetCode</p><p><a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="noopener">https://articles.leetcode.com/longest-palindromic-substring-part-ii/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（中等）&quot;&gt;&lt;a href=&quot;#题目（中等）&quot; class=&quot;headerlink&quot; title=&quot;题目（中等）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（中等）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入: “babad”&lt;br&gt;输出: “bab”&lt;br&gt;注意: “aba” 也是一个有效答案。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入: “cbbd”&lt;br&gt;输出: “bb”&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="中等题型" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大数据————淘宝双十一项目实战</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E6%B7%98%E5%AE%9D%E5%8F%8C%E5%8D%81%E4%B8%80%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2018/12/04/大数据——淘宝双十一项目实战/</id>
    <published>2018-12-04T14:30:55.498Z</published>
    <updated>2018-12-04T15:15:48.930Z</updated>
    
    <content type="html"><![CDATA[<p>今天完成了一个基于淘宝双十一交易数据的大数据分析实战项目，这里稍作记录。</p><p>教程：淘宝双11数据分析与预测课程案例：厦大数据库实验室博客  <a href="http://dblab.xmu.edu.cn/blog/1362-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/1362-2/</a></p><p>项目和文档：<a href="https://github.com/JayZeed/taobao11" target="_blank" rel="noopener">https://github.com/JayZeed/taobao11</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天完成了一个基于淘宝双十一交易数据的大数据分析实战项目，这里稍作记录。&lt;/p&gt;
&lt;p&gt;教程：淘宝双11数据分析与预测课程案例：厦大数据库实验室博客  &lt;a href=&quot;http://dblab.xmu.edu.cn/blog/1362-2/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据————Ubuntu14.04 Echarts图例设置后不显示</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20Echarts%E5%9B%BE%E4%BE%8B%E8%AE%BE%E7%BD%AE%E5%90%8E%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/12/04/大数据——Ubuntu14.04 Echarts图例设置后不显示/</id>
    <published>2018-12-04T14:12:42.035Z</published>
    <updated>2018-12-04T15:15:35.005Z</updated>
    
    <content type="html"><![CDATA[<p>Echarts是用于前端数据可视化的一个工具。可以把数据以各种图表方式显示出来。</p><p>最近做一个大数据项目时，通过Echarts做了一个柱状图，但是设置了的图例一直不能显示出来。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">        x: <span class="string">'center'</span>,</span><br><span class="line">        data:[<span class="string">'销量'</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>红框内就是图例：</p><p><img src="\uploads\大数据——Echarts图例\1.png" alt="图例"></p><p>查了一些资料才知道原来<strong>需要series中的name和legend的data一致</strong>，这样才能显示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">    x: <span class="string">'center'</span>,</span><br><span class="line">    data:[<span class="string">'销量'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">series : [</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">'销量'</span>,</span><br><span class="line">        type:<span class="string">'bar'</span>,</span><br><span class="line">        barWidth: <span class="string">'60%'</span>,</span><br><span class="line">        data:y</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果想设置图例颜色，可以在option里设置 color : […] 实现。</p><p>参考资料：echarts柱状图图例不显示的问题 - royal1235的博客 - CSDN博客<br><a href="https://blog.csdn.net/royal1235/article/details/80746278" target="_blank" rel="noopener">https://blog.csdn.net/royal1235/article/details/80746278</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Echarts是用于前端数据可视化的一个工具。可以把数据以各种图表方式显示出来。&lt;/p&gt;
&lt;p&gt;最近做一个大数据项目时，通过Echarts做了一个柱状图，但是设置了的图例一直不能显示出来。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据————Ubuntu14.04 JavaScript array保存object对象出错</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20JavaScript%20array%E4%BF%9D%E5%AD%98object%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/12/04/大数据——Ubuntu14.04 JavaScript array保存object对象/</id>
    <published>2018-12-04T12:46:46.249Z</published>
    <updated>2018-12-04T14:32:14.632Z</updated>
    
    <content type="html"><![CDATA[<p>用JSP开发WEB应用时用到了javascript语言，其中想在数组保存object对象时出了点小问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydata=[];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> obj =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="xml"><span class="tag">&lt;<span class="name">%=a[0]%</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">mydata.push(obj);</span></span><br></pre></td></tr></table></figure><p>这里我想将obj用数组存起来，发现存储失败了，控制台调试发现报错：ReferenceError: 台湾 is not defined （这里台湾是&lt;%=a[0]%&gt;得到的值）大概意思是把台湾作为变量了，而不是一个值。<a id="more"></a></p><p>因为&lt;%=a[0]%&gt;表示取得a[0]的值，那么 obj.name = &lt;%=a[0]%&gt;; 就相当于 obj.name = 台湾; 确实会被理解成变量名，而我们需要的应该是 obj.name = “台湾” ; </p><p>所以只需要改成 obj.name = “&lt;%=a[0]%&gt;”; 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用JSP开发WEB应用时用到了javascript语言，其中想在数组保存object对象时出了点小问题。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mydata=[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.name = &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;%=a[0]%&lt;/span&gt;&amp;gt;&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;mydata.push(obj);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里我想将obj用数组存起来，发现存储失败了，控制台调试发现报错：ReferenceError: 台湾 is not defined （这里台湾是&amp;lt;%=a[0]%&amp;gt;得到的值）大概意思是把台湾作为变量了，而不是一个值。
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
</feed>
