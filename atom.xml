<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JJ❤22</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-06T17:42:55.784Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JJZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode————7.整数反转</title>
    <link href="http://yoursite.com/2018/12/07/LeetCode%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/12/07/LeetCode——整数反转/</id>
    <published>2018-12-06T16:37:22.000Z</published>
    <updated>2018-12-06T17:42:55.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（简单）"><a href="#题目（简单）" class="headerlink" title="题目（简单）"></a><strong>题目（简单）</strong></h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，<strong>如果反转后整数溢出那么就返回 0。</strong><a id="more"></a></p><hr><p>题目很明确，很自然的想法就是通过除法和取余逐位取出，再依次乘10加余数达到反向效果，但是也有一点就是<strong>做乘法时可能会出现溢出的情况</strong>。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>反转整数的方法可以与反转字符串进行类比。</p><p>我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。</p><p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop operation:</span></span><br><span class="line">pop = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push operation:</span></span><br><span class="line">temp = rev * <span class="number">10</span> + pop;</span><br><span class="line">rev = temp;</span><br></pre></td></tr></table></figure><p>但是，这种方法很危险，因为当 temp=rev⋅10+pop 时会导致溢出。</p><p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p><p>为了便于解释，我们假设 rev 是正数。</p><p><img src="\uploads\LeetCode\2.png" alt="2"></p><p>这里要补充两点：</p><p>1.显然因为top只能是处于0~9的个位数字，所以若rev·10+top溢出，那么rev&gt;=INTMAX/10必然成立。</p><p>2.若rev==INTMAX/10，若pop&gt;7(假设为8)，那么反转前肯定是8xxxxxxxx，显然超出了Int的范围，所以top&lt;=7一定成立的。</p><p>当 rev 为负时可以应用类似的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> X =x;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">X = -x;</span><br><span class="line"><span class="keyword">int</span> rev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(X&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> end = X%<span class="number">10</span>;</span><br><span class="line">        X = X/<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(rev&gt;<span class="number">214748364</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rev = rev*<span class="number">10</span>+end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">        rev = -rev;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE/<span class="number">10</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE/<span class="number">10</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(log<sub>10</sub>(n))，因为每次都通过除以10取出尾数位。</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（简单）&quot;&gt;&lt;a href=&quot;#题目（简单）&quot; class=&quot;headerlink&quot; title=&quot;题目（简单）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（简单）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; &lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: -123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，&lt;strong&gt;如果反转后整数溢出那么就返回 0。&lt;/strong&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————5.最长回文子串(常考)</title>
    <link href="http://yoursite.com/2018/12/06/LeetCode%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/12/06/LeetCode——最长回文子串/</id>
    <published>2018-12-06T09:37:22.000Z</published>
    <updated>2018-12-06T15:41:19.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（中等）"><a href="#题目（中等）" class="headerlink" title="题目（中等）"></a><strong>题目（中等）</strong></h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><a id="more"></a> <hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><h3 id="1-最大公共子串法"><a href="#1-最大公共子串法" class="headerlink" title="1.最大公共子串法"></a>1.最大公共子串法</h3><p>第一个比较容易的想法可能就是 把字符串S反转过来，记为S’，先使用<strong>动态规划方法</strong>找到S与S’之间的最长公共子串，即所求的最长回文子串。</p><p>例如，S = “caba” , S’ = “abac”, S 以及 S’ 之间的最长公共子串为 “aba”，恰恰是答案。</p><p>让我们尝试一下这个例子：S = “abacdfgdcaba” , S’ = “abacdgfdcaba”, S 以及 S’之间的最长公共子串为 “abacd”，显然，这不是回文。</p><p>我们可以看到，当 S 的其他部分中存在非回文子串的反向副本时(即例子中的abacd和dcaba)，最长公共子串法就会失败。为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要<strong>检查子串的索引是否与反向子串的原始索引相同</strong>。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。</p><p>这里要解释一下上面加粗的那句，即判断条件，比如”caba”这个串，反转找到的最长公共子串是”aba”，它在”cab<strong>a</strong>“的结束索引为<strong>3</strong>（不是1是因为最长公共子串找到的索引是<strong>结束索引</strong>）；在反向串”ab<strong>a</strong>c”中的<strong>结束索引</strong>为<strong>2</strong>，我们要找的<strong>原始索引</strong>就是在反向串中的<strong>反向索引</strong>，即”aba”的<strong>开始索引</strong>（串长 4-1-<strong>结束索引2</strong>=4-1-2=<strong>1</strong>）加上该最大公共子串长度3再减1（即<strong>1</strong>+3-1=<strong>3</strong>）因为反向索引<strong>3</strong>和原串的索引<strong>3</strong>相等，所以认定这是个回文串，而不是反向副本；再比如”abacdfgdcaba”，找到的公共子串”abacd”的<strong>结束索引</strong>为<strong>4</strong>，<strong>开始索引</strong>=12-1-4=7，又因为最大公共子串长为5，所以反向串中的<strong>原始索引</strong>就为7+5-1=11，这与原串的结束索引4不等，所以这是个反向副本，而不是回文数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line">   <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        String s1 = s;</span><br><span class="line">        String s2 = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">        String str=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l1 = s1.length();</span><br><span class="line"><span class="keyword">int</span> l2 = s2.length();</span><br><span class="line"><span class="keyword">int</span> max_index1[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">int</span> max_index2[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> array[][] = <span class="keyword">new</span> <span class="keyword">int</span>[l1][l2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;s.length();++t)</span><br><span class="line">&#123;</span><br><span class="line">max_index1[t] = -<span class="number">1</span>;</span><br><span class="line">max_index2[t] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;l2;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">array[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">array[i][j] = array[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(array[i][j] &gt; max_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r_index2 = s.length()-j-<span class="number">1</span>;  <span class="comment">//判断是否是回文而不是反向副本</span></span><br><span class="line"><span class="keyword">if</span>(i == r_index2+array[i][j]-<span class="number">1</span>)  <span class="comment">//判断是否是回文而不是反向副本</span></span><br><span class="line">&#123;</span><br><span class="line">max_len = array[i][j];</span><br><span class="line">max_index1[<span class="number">0</span>] = i;</span><br><span class="line">max_index2[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;s.length();++t)</span><br><span class="line">&#123;</span><br><span class="line">max_index1[t] = -<span class="number">1</span>;</span><br><span class="line">max_index2[t] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">array[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(max_index1[<span class="number">0</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">str = (s1.substring(max_index1[<span class="number">0</span>]-max_len+<span class="number">1</span>,max_index1[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line">System.out.print(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：因为是动态规划，所以是O(n<sup>2</sup>)。</p><p>空间复杂度：因为用了空间换时间，所以是O(n<sup>2</sup>)。其实还可以通过<strong>把Array二维数组转换为一维</strong>，因为每次循环都是固定i，内部循环j，而第3行的数据其实只用到之前第2行的数据，不需要第1行的，所以每次用一维数组重复利用，做数据更新就可以了。这样空间复杂度就缩小到了O(n)。</p><h3 id="2-暴力法"><a href="#2-暴力法" class="headerlink" title="2.暴力法"></a>2.暴力法</h3><p>很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。但是暴力法面对比如”zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz”这样的超长回文串，就会因为时间开销太大而超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_index = -<span class="number">1</span>;</span><br><span class="line">String str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> start = i,end = j;</span><br><span class="line"><span class="keyword">while</span>(s.charAt(start) == s.charAt(end))</span><br><span class="line">&#123;</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line"><span class="keyword">if</span>(end&lt;<span class="number">0</span> || start&gt;s.length()-<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(start &gt;= end &amp;&amp; j-i+<span class="number">1</span> &gt; max_len)</span><br><span class="line">&#123;</span><br><span class="line">max_len = j-i+<span class="number">1</span>;</span><br><span class="line">max_index = j;</span><br><span class="line">str = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n<sup>3</sup>)，因为要进行N<em>N的循环，每次循环还要遍历根据初始位置start和结束位置end找出的子串判断是否是回文串，所以为N </em> N * N。</p><p>空间复杂度：O(1)</p><h3 id="3-动态规划法"><a href="#3-动态规划法" class="headerlink" title="3.动态规划法"></a>3.动态规划法</h3><p>为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，“ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。</p><p>我们给出 P(i,j) 的定义如下：</p><p><img src="\uploads\LeetCode\1.png" alt="1"></p><p>基本示例如下：</p><p>P(i, i) = true</p><p>P(i, i+1) = (Si==Si+1)</p><p>这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len[]=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">//记录是否为回文串，不是就记为0，是的就记录回文串长度</span></span><br><span class="line"><span class="keyword">int</span> max_len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_index=<span class="number">0</span>;</span><br><span class="line">String str=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()-<span class="number">1</span>;j&gt;=i;--j)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(i == j)  <span class="comment">//边界（奇数）</span></span><br><span class="line">   len[j] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(Math.abs(i-j)==<span class="number">1</span>) <span class="comment">//边界（偶数）</span></span><br><span class="line">   &#123;</span><br><span class="line">   len[j] = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   len[j] = len[j-<span class="number">1</span>]==<span class="number">0</span>? <span class="number">0</span>:len[j-<span class="number">1</span>]+<span class="number">2</span>;  <span class="comment">//判断内部子串是不是回文串，不是为false，是的就记录回文串长度</span></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   len[j] = <span class="number">0</span>;  <span class="comment">//不是回文串</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(len[j]&gt;max_len)</span><br><span class="line">   &#123;</span><br><span class="line">   max_len = len[j];</span><br><span class="line">   max_index = j;</span><br><span class="line">   str = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n<sup>2</sup>)</p><p>空间复杂度：正常情况下是O(n<sup>2</sup>)， 因为动态规划方法使用 O(n<sup>2</sup>)的空间来存储表。同样的，这个空间复杂度可以优化到<strong>O(n)</strong>，<strong>空间复杂度：O(n^2)O(n2)， 该方法使用 O(n^2)O(n2) 的空间来存储表。</strong></p><h3 id="4-中心扩展法"><a href="#4-中心扩展法" class="headerlink" title="4.中心扩展法"></a>4.中心扩展法</h3><p>事实上，只需使用恒定的空间，我们就可以在 O(n<sup>2</sup>) 的时间内解决这个问题。</p><p>我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。</p><p>你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个 ‘b’ 之间）。所以找奇数长度的回文串时可以遍历n个中心（也就是n个字符均作为一次中心），找偶数长度回文串时可以遍历n-1个中心（也就是n个字符之间的空隙均作为一次中心），加起来就是n+n-1=2n-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len=<span class="number">0</span>,length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start=-<span class="number">1</span>,end=-<span class="number">1</span>;</span><br><span class="line">String str=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = expandAroundCenter(s,i,i);</span><br><span class="line"><span class="keyword">int</span> len2 = expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">length = (len1&gt;len2)?len1:len2;</span><br><span class="line"><span class="keyword">if</span>(length&gt;max_len)</span><br><span class="line">&#123;</span><br><span class="line">max_len = length;</span><br><span class="line">start = i-((length+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>);</span><br><span class="line">end = start+length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str = s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>  <span class="comment">//从left/right的中心开始扩展</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L=left,R=right;</span><br><span class="line"><span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;=s.length()-<span class="number">1</span> &amp;&amp; s.charAt(L)==s.charAt(R))</span><br><span class="line">&#123;</span><br><span class="line">L--;</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> R-L-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n<sup>2</sup>)， 由于围绕中心来扩展回文会耗去 O(n) 的时间，所以总的复杂度为 O(n<sup>2</sup>)。</li><li>空间复杂度：O(1)。 </li></ul><h3 id="5-Manacher-马拉车算法"><a href="#5-Manacher-马拉车算法" class="headerlink" title="5.Manacher 马拉车算法"></a>5.Manacher 马拉车算法</h3><p>这个算法比较复杂，可以把时间复杂度和空闲复杂度都缩减到O(n)，建议多查看一些资料，此处不做叙述。</p><p>参考资料：Longest Palindromic Substring Part II – LeetCode</p><p><a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="noopener">https://articles.leetcode.com/longest-palindromic-substring-part-ii/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（中等）&quot;&gt;&lt;a href=&quot;#题目（中等）&quot; class=&quot;headerlink&quot; title=&quot;题目（中等）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（中等）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入: “babad”&lt;br&gt;输出: “bab”&lt;br&gt;注意: “aba” 也是一个有效答案。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入: “cbbd”&lt;br&gt;输出: “bb”&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="中等题型" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大数据————淘宝双十一项目实战</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E6%B7%98%E5%AE%9D%E5%8F%8C%E5%8D%81%E4%B8%80%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2018/12/04/大数据——淘宝双十一项目实战/</id>
    <published>2018-12-04T14:30:55.498Z</published>
    <updated>2018-12-04T15:15:48.930Z</updated>
    
    <content type="html"><![CDATA[<p>今天完成了一个基于淘宝双十一交易数据的大数据分析实战项目，这里稍作记录。</p><p>教程：淘宝双11数据分析与预测课程案例：厦大数据库实验室博客  <a href="http://dblab.xmu.edu.cn/blog/1362-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/1362-2/</a></p><p>项目和文档：<a href="https://github.com/JayZeed/taobao11" target="_blank" rel="noopener">https://github.com/JayZeed/taobao11</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天完成了一个基于淘宝双十一交易数据的大数据分析实战项目，这里稍作记录。&lt;/p&gt;
&lt;p&gt;教程：淘宝双11数据分析与预测课程案例：厦大数据库实验室博客  &lt;a href=&quot;http://dblab.xmu.edu.cn/blog/1362-2/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据————Ubuntu14.04 Echarts图例设置后不显示</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20Echarts%E5%9B%BE%E4%BE%8B%E8%AE%BE%E7%BD%AE%E5%90%8E%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/12/04/大数据——Ubuntu14.04 Echarts图例设置后不显示/</id>
    <published>2018-12-04T14:12:42.035Z</published>
    <updated>2018-12-04T15:15:35.005Z</updated>
    
    <content type="html"><![CDATA[<p>Echarts是用于前端数据可视化的一个工具。可以把数据以各种图表方式显示出来。</p><p>最近做一个大数据项目时，通过Echarts做了一个柱状图，但是设置了的图例一直不能显示出来。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">        x: <span class="string">'center'</span>,</span><br><span class="line">        data:[<span class="string">'销量'</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>红框内就是图例：</p><p><img src="\uploads\大数据——Echarts图例\1.png" alt="图例"></p><p>查了一些资料才知道原来<strong>需要series中的name和legend的data一致</strong>，这样才能显示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">    x: <span class="string">'center'</span>,</span><br><span class="line">    data:[<span class="string">'销量'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">series : [</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">'销量'</span>,</span><br><span class="line">        type:<span class="string">'bar'</span>,</span><br><span class="line">        barWidth: <span class="string">'60%'</span>,</span><br><span class="line">        data:y</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果想设置图例颜色，可以在option里设置 color : […] 实现。</p><p>参考资料：echarts柱状图图例不显示的问题 - royal1235的博客 - CSDN博客<br><a href="https://blog.csdn.net/royal1235/article/details/80746278" target="_blank" rel="noopener">https://blog.csdn.net/royal1235/article/details/80746278</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Echarts是用于前端数据可视化的一个工具。可以把数据以各种图表方式显示出来。&lt;/p&gt;
&lt;p&gt;最近做一个大数据项目时，通过Echarts做了一个柱状图，但是设置了的图例一直不能显示出来。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据————Ubuntu14.04 JavaScript array保存object对象出错</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20JavaScript%20array%E4%BF%9D%E5%AD%98object%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/12/04/大数据——Ubuntu14.04 JavaScript array保存object对象/</id>
    <published>2018-12-04T12:46:46.249Z</published>
    <updated>2018-12-04T14:32:14.632Z</updated>
    
    <content type="html"><![CDATA[<p>用JSP开发WEB应用时用到了javascript语言，其中想在数组保存object对象时出了点小问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydata=[];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> obj =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="xml"><span class="tag">&lt;<span class="name">%=a[0]%</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">mydata.push(obj);</span></span><br></pre></td></tr></table></figure><p>这里我想将obj用数组存起来，发现存储失败了，控制台调试发现报错：ReferenceError: 台湾 is not defined （这里台湾是&lt;%=a[0]%&gt;得到的值）大概意思是把台湾作为变量了，而不是一个值。<a id="more"></a></p><p>因为&lt;%=a[0]%&gt;表示取得a[0]的值，那么 obj.name = &lt;%=a[0]%&gt;; 就相当于 obj.name = 台湾; 确实会被理解成变量名，而我们需要的应该是 obj.name = “台湾” ; </p><p>所以只需要改成 obj.name = “&lt;%=a[0]%&gt;”; 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用JSP开发WEB应用时用到了javascript语言，其中想在数组保存object对象时出了点小问题。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mydata=[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.name = &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;%=a[0]%&lt;/span&gt;&amp;gt;&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;mydata.push(obj);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里我想将obj用数组存起来，发现存储失败了，控制台调试发现报错：ReferenceError: 台湾 is not defined （这里台湾是&amp;lt;%=a[0]%&amp;gt;得到的值）大概意思是把台湾作为变量了，而不是一个值。
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据——Ubuntu14.04 使用Sqoop将数据从Hive导入MySQL出错</title>
    <link href="http://yoursite.com/2018/11/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20%E4%BD%BF%E7%94%A8Sqoop%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8EHive%E5%AF%BC%E5%85%A5Mysql%E5%87%BA%E9%94%99/"/>
    <id>http://yoursite.com/2018/11/29/大数据——Ubuntu14.04 使用Sqoop将数据从Hive导入Mysql出错/</id>
    <published>2018-11-29T13:24:27.585Z</published>
    <updated>2018-11-29T13:45:45.570Z</updated>
    
    <content type="html"><![CDATA[<p>在基于大数据双十一用户行为统计与分析实验中 进行导入数据操作时：</p><p>(4)导入数据(执行时间：20秒左右)<br>注意，刚才已经退出MySQL，回到了Shell命令提示符状态。下面就可以执行数据导入操作</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/sqoop</span><br><span class="line">bin/sqoop export --connect jdbc:mysql://localhost:3306/dbtaobao --username root --password root --table user_log --export-dir '/user/hive/warehouse/dbtaobao.db/inner_user_log' --fields-terminated-by ',';</span><br></pre></td></tr></table></figure><p>执行<strong>错误提示</strong>如下：</p><p>18/11/29 05:20:45 <strong>ERROR manager.SqlManager:</strong> <strong>Error executing statement: java.sql.SQLException: Access denied for user ‘root‘@’localhost’ (using password: YES)</strong><br>java.sql.SQLException: Access denied for user ‘root‘@’localhost’ (using password: YES)<br>​    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:965)<br>​    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3978)<br>​    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3914)<br>​    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:871)<br>​    at com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1714)<br>​    at com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1224)<br>​    at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2199)<br>​    at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2230)<br>​    at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2025)<br>​    at com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:778)<br>​    at com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:47)<br>​    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)<br>​    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)<br>​    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)<br>​    at java.lang.reflect.Constructor.newInstance(Constructor.java:526)<br>​    at com.mysql.jdbc.Util.handleNewInstance(Util.java:425)<br>​    at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:386)<br>​    at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:330)<br>​    at java.sql.DriverManager.getConnection(DriverManager.java:571)<br>​    at java.sql.DriverManager.getConnection(DriverManager.java:215)<br>​    at org.apache.sqoop.manager.SqlManager.makeConnection(SqlManager.java:904)<br>​    at org.apache.sqoop.manager.GenericJdbcManager.getConnection(GenericJdbcManager.java:59)<br>​    at org.apache.sqoop.manager.SqlManager.execute(SqlManager.java:763)<br>​    at org.apache.sqoop.manager.SqlManager.execute(SqlManager.java:786)<br>​    at org.apache.sqoop.manager.SqlManager.getColumnInfoForRawQuery(SqlManager.java:289)<br>​    at org.apache.sqoop.manager.SqlManager.getColumnTypesForRawQuery(SqlManager.java:260)<br>​    at org.apache.sqoop.manager.SqlManager.getColumnTypes(SqlManager.java:246)<br>​    at org.apache.sqoop.manager.ConnManager.getColumnTypes(ConnManager.java:327)<br>​    at org.apache.sqoop.orm.ClassWriter.getColumnTypes(ClassWriter.java:1872)<br>​    at org.apache.sqoop.orm.ClassWriter.generate(ClassWriter.java:1671)<br>​    at org.apache.sqoop.tool.CodeGenTool.generateORM(CodeGenTool.java:106)<br>​    at org.apache.sqoop.tool.ExportTool.exportTable(ExportTool.java:63)<br>​    at org.apache.sqoop.tool.ExportTool.run(ExportTool.java:99)<br>​    at org.apache.sqoop.Sqoop.run(Sqoop.java:147)<br>​    at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:70)<br>​    at org.apache.sqoop.Sqoop.runSqoop(Sqoop.java:183)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:234)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:243)<br>​    at org.apache.sqoop.Sqoop.main(Sqoop.java:252)<br>18/11/29 05:20:45 ERROR tool.ExportTool: Encountered IOException running export job:<br>java.io.IOException: No columns to generate for ClassWriter<br>​    at org.apache.sqoop.orm.ClassWriter.generate(ClassWriter.java:1677)<br>​    at org.apache.sqoop.tool.CodeGenTool.generateORM(CodeGenTool.java:106)<br>​    at org.apache.sqoop.tool.ExportTool.exportTable(ExportTool.java:63)<br>​    at org.apache.sqoop.tool.ExportTool.run(ExportTool.java:99)<br>​    at org.apache.sqoop.Sqoop.run(Sqoop.java:147)<br>​    at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:70)<br>​    at org.apache.sqoop.Sqoop.runSqoop(Sqoop.java:183)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:234)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:243)<br>​    at org.apache.sqoop.Sqoop.main(Sqoop.java:252)</init></init></p><p>出现这个错误，第一反应是当前用户对于Mysql的权限不够，于是第一反应去修改权限：</p><p>先进入mysql shell:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mysql -u root -p</span><br></pre></td></tr></table></figure><p>然后修改权限(第一个root表示用户，第二个root表示密码)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> grant all privileges on *.* to root@localhost identified by 'root';</span><br></pre></td></tr></table></figure><p>最好刷新一下权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure><p>经过尝试之后我发现  并 没 有 卵 用</p><p>那么问题肯定不是这个，仔细看了一遍该export指令的参数:</p><p><strong>字段解释：</strong></p><p>./bin/sqoop export ##表示数据从 hive 复制到 mysql 中<br>–connect jdbc:mysql://localhost:3306/dbtaobao<br>–username root #mysql登陆用户名<br>–password root #登录密码<br>–table user_log #mysql 中的表，即将被导入的表名称<br>–export-dir ‘/user/hive/warehouse/dbtaobao.db/user_log ‘ #hive 中被导出的文件<br>–fields-terminated-by ‘,’ #Hive 中被导出的文件字段的分隔符</p><p>我发现：password错了。。。</p><p>修改之后就正常执行了。。。下次一定要注意参数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在基于大数据双十一用户行为统计与分析实验中 进行导入数据操作时：&lt;/p&gt;
&lt;p&gt;(4)导入数据(执行时间：20秒左右)&lt;br&gt;注意，刚才已经退出MySQL，回到了Shell命令提示符状态。下面就可以执行数据导入操作&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>大数据——Ubuntu14.04 安装mysql</title>
    <link href="http://yoursite.com/2018/11/27/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%E5%AE%89%E8%A3%85mysql/"/>
    <id>http://yoursite.com/2018/11/27/大数据——Ubuntu14.04安装mysql/</id>
    <published>2018-11-27T15:35:14.133Z</published>
    <updated>2018-11-28T02:13:13.039Z</updated>
    
    <content type="html"><![CDATA[<p>今天用Ubuntu安装mysql遇到了几个小坑，记录一下帮助更多的人避坑。</p><p><strong>安装教程：</strong>Ubuntu安装MySQL及常用操作_厦大数据库实验室博客  <a href="http://dblab.xmu.edu.cn/blog/install-mysql/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/install-mysql/</a></p><a id="more"></a><hr><p><strong>1.mysql安装后找不到</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server  #安装mysql</span><br></pre></td></tr></table></figure><p>上述语句执行后，执行 <strong>service mysql start</strong> 出现找不到mysql情况，使用 <strong>sudo netstat -tap | grep mysql</strong> 也不能找到mysql，后来添加了两条指令，总共三条完成了mysql安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt install mysql-client</span><br><span class="line">sudo apt install libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/itxiaolong3/article/details/77905923" target="_blank" rel="noopener">https://blog.csdn.net/itxiaolong3/article/details/77905923</a></p><p><strong>2.mysqld.cnf找不到</strong></p><p>想修改 <strong>/etc/mysql/mysql.conf.d/mysqld.cnf</strong> 配置文件结果找不到，这个和mysql的版本也有关，我这个5.5版本没有这个文件。</p><p>于是修改了 <strong>/etc/mysql/my.cnf</strong> 文件，该文件配置全局选项。</p><p>/etc/my.cnf    全局选项<br>/etc/mysql/my.cnf    全局选项<br>SYSCONFDIR/my.cnf    全局选项<br>$MYSQL_HOME/my.cnf    服务器特定选项（仅限服务器）<br>defaults-extra-file    指定的文件 –defaults-extra-file，如果有的话<br>~/.my.cnf    用户特定选项<br>~/.mylogin.cnf    用户特定的登录路径选项（仅限客户端）</p><p><strong>3.如果还是出现无法使用service mysql start命令的情况</strong></p><p>可能你的mysql版本有问题，（我按教程自动获取最新版本获取的是5.5的，而课题中需要的是5.7的）</p><p>可以参考该教程自己选择和下载对应版本：<br>请自行尝试，我是先按照下面第二个教程配置到3）、安装mysql－server时解包出错了，一番折腾没有解决，换了第一个，又按顺序解包一遍成功。<br>Ubuntu14.04 下安装离线安装Mysql5.7 - wst878882582的博客 - CSDN博客<br><a href="https://blog.csdn.net/wst878882582/article/details/78457531" target="_blank" rel="noopener">https://blog.csdn.net/wst878882582/article/details/78457531</a></p><p>Ubuntu14.04安装MySQL5.7.20（MySQL最新版本） - qq_34256348的博客 - CSDN博客<br><a href="https://blog.csdn.net/qq_34256348/article/details/78340333" target="_blank" rel="noopener">https://blog.csdn.net/qq_34256348/article/details/78340333</a></p><p><strong>4.ERROR 1146 (42S02): Table ‘performance_schema.session_variables’ doesn’t exist</strong></p><p>使用<strong>show variables like “char%”;</strong>指令时出现该错误</p><p>需要进行<strong>mysql_upgrade</strong>操作进行修复</p><p>1）首先退出mysql</p><p>2）在命令行界面输入：mysql_upgrade -uroot -p –force</p><p>3）然后重启mysql即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天用Ubuntu安装mysql遇到了几个小坑，记录一下帮助更多的人避坑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装教程：&lt;/strong&gt;Ubuntu安装MySQL及常用操作_厦大数据库实验室博客  &lt;a href=&quot;http://dblab.xmu.edu.cn/blog/install-mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dblab.xmu.edu.cn/blog/install-mysql/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————2.两数相加</title>
    <link href="http://yoursite.com/2018/11/27/LeetCode%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2018/11/27/LeetCode——两数相加/</id>
    <published>2018-11-27T02:37:22.000Z</published>
    <updated>2018-12-06T09:12:39.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（中等）"><a href="#题目（中等）" class="headerlink" title="题目（中等）"></a><strong>题目（中等）</strong></h2><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。</p><a id="more"></a> <p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>输入：</p><p>[2,4,3]</p><p>[5,6,4]</p><p>输出：</p><p>[7,0,8]</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>用了最直接暴力的解法，先把两个链表的各个位提出来，恢复成int类型的数，然后相加，再讲相加的和保存为String类型，通过下标遍历String各位，从而建立一个新的输出链表。</p><p>该方法最大的问题就是<strong>溢出</strong>！虽然我写的时候已经注意到会这样，不过还是尝试了一下，果然无法accept。因为<strong>两个数相加可能超出int表示范围</strong>，这时候就溢出了，尽管后面用String保存也没有什么用，显然不可取。</p><p>所以相应地我想到可以把相加的两个数用String表示，然后逐位相加，这其实就和官方解答类似了。</p><h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a><strong>官方解法</strong></h3><p>其实官方解法很容易想，链表是倒序从低位到高位表示的，这和做算术加法的顺序一致，先加低位，产生进位传给高位，高位继续相加，这样逐位相加，最后的结果就是所需的输出链表。</p><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1l1 和 l2l2 的表头开始相加。由于每位数字都应当处于 0 \ldots 90…9 的范围内，我们计算两个数字的和时可能会出现“溢出”。例如，5 + 7 = 125+7=12。在这种情况下，我们会将当前位的数值设置为 22，并将进位 carry = 1carry=1 带入下一次迭代。进位 carrycarry 必定是 00 或 11，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 199+9+1=19。</p><p>伪代码如下：</p><p>将当前结点初始化为返回列表的哑结点。<br>将进位 carrycarry 初始化为 00。<br>将 pp 和 qq 分别初始化为列表 l1l1 和 l2l2 的头部。<br>遍历列表 l1l1 和 l2l2 直至到达它们的尾端。<br>将 xx 设为结点 pp 的值。如果 pp 已经到达 l1l1 的末尾，则将其值设置为 00。<br>将 yy 设为结点 qq 的值。如果 qq 已经到达 l2l2 的末尾，则将其值设置为 00。<br>设定 sum = x + y + carrysum=x+y+carry。<br>更新进位的值，carry = sum / 10carry=sum/10。<br>创建一个数值为 (sum \bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。<br>同时，将 pp 和 qq 前进到下一个结点。<br>检查 carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 11 的新结点。<br>返回哑结点的下一个结点。<br>请注意，我们<strong>使用哑结点来简化代码</strong>。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</p><table><thead><tr><th>l1=[0,1] <br>l2=[0,1,2]</th><th>当一个列表比另一个列表长时.</th></tr></thead><tbody><tr><td><strong>l1=[]<br>l2=[0,1]</strong></td><td><strong>当一个列表为空时，即出现空列表。</strong></td></tr><tr><td><strong>l1=[9,9]<br>l2=[1]</strong></td><td><strong>求和运算最后可能出现额外的进位，这一点很容易被遗忘</strong></td></tr></tbody></table><p><strong>官方代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己实现的代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">          ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//头结点，不存储数据，方便最后返回链表首部</span></span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">int</span> carry = <span class="number">0</span>, rest = <span class="number">0</span>;</span><br><span class="line">  ListNode p = l1, q = l2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="keyword">null</span> || q!=<span class="keyword">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">int</span> v_l1 = (p!=<span class="keyword">null</span>)? p.val:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v_l2 = (q!=<span class="keyword">null</span>)? q.val:<span class="number">0</span>;</span><br><span class="line">rest = (v_l1+v_l2+carry)%<span class="number">10</span>;</span><br><span class="line">carry = (v_l1+v_l2+carry)/<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ListNode addNode = <span class="keyword">new</span> ListNode(rest);</span><br><span class="line">curr.next = addNode;</span><br><span class="line">curr = addNode;</span><br><span class="line"></span><br><span class="line">p = (p==<span class="keyword">null</span>)? <span class="keyword">null</span>:p.next;</span><br><span class="line">q = (q==<span class="keyword">null</span>)? <span class="keyword">null</span>:q.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry!=<span class="number">0</span>)  <span class="comment">//如果最高位也满10进位</span></span><br><span class="line">  &#123;</span><br><span class="line">  curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><p>时间复杂度：O(max(m,n))，假设 m 和 n 分别表示 l1和 l2的长度，上面的算法最多重复 max(m,n) 次。</p><p>空间复杂度：O(max(m,n))， 新列表的长度最多为max(m,n)+1。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（中等）&quot;&gt;&lt;a href=&quot;#题目（中等）&quot; class=&quot;headerlink&quot; title=&quot;题目（中等）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（中等）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给出两个&lt;strong&gt;非空&lt;/strong&gt;的链表用来表示两个非负的整数。其中，它们各自的位数是按照&lt;strong&gt;逆序&lt;/strong&gt;的方式存储的，并且它们的每个节点只能存储&lt;strong&gt;一位&lt;/strong&gt;数字。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="中等题型" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大数据——CentOS7 eclipse中的hadoop环节配置</title>
    <link href="http://yoursite.com/2018/11/15/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94CentOS7%20eclipse%E4%B8%AD%E7%9A%84hadoop%E7%8E%AF%E8%8A%82%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/15/大数据——CentOS7 eclipse中的hadoop环节配置/</id>
    <published>2018-11-15T05:32:37.051Z</published>
    <updated>2018-11-16T15:36:50.438Z</updated>
    
    <content type="html"><![CDATA[<p>本来准备写个CentOS7下hadoop分布式集群的配置教程的，最近事情有点多，暂时搁置一下吧，先把遇到的小问题记录一下。</p><p>首先我用的是VMware虚拟机创建了三台虚拟机，都是CentOS7的，一台master（命名为hadoop1），两台slaver（命名为hadoop2和hadoop3），然后在master上配置了一些eclipse，准备跑MapReduce代码的，中间遇到了点小问题。</p><a id="more"></a><p>Eclipse版本： 4.5的Mars</p><p>Hadoop版本：2.7.3</p><p>所用教程：<a href="https://blog.csdn.net/xiaoyw71/article/details/53316390" target="_blank" rel="noopener">https://blog.csdn.net/xiaoyw71/article/details/53316390</a></p><hr><p>前面还算正常，到<strong>使用New Hadoop Location打开Hadoop Location配置窗口</strong>这一步时出错了，一直没有反应，然后打开Window -&gt; Show View -&gt; Error Log 查看错误日志，出错语句主要是两种：</p><p>Unhandled event loop exception</p><p>org.osgi.framework.BundleException: Exception in org.eclipse.equinox.internal</p><p>然后在网上一顿找，有的说应该是缺jar包，然后修改MANIFEST.MF文件的，比如这个老哥的情况：</p><p>2018-6-29 解决Eclipse使用Hadoop插件无法新建Location的问题 - 知乎</p><p><a href="https://zhuanlan.zhihu.com/p/38630695" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38630695</a></p><p>然后我下载了hadoop-eclipse-plugin-2.7.3.jar放入eclipse 安装目录下的plugins文件夹也还是解决不了，后来有人说是eclipse和hadoop-eclipse-plugin-x.x.x.jar<strong>版本不合适</strong>的，<strong>于是我把eclipse的版本改到了Neon 4.6 ，然后再重新在eclipse里面导入hadoop-eclipse-plugin-2.7.3.jar包就成功了，希望对大家有帮助。</strong></p><hr><p>三台集群配置完那天测试了一下jps指令感觉一切正常，于是就stop-all.sh关掉了，第二天重新start-all.sh发现作为namenode的hadoop1执行jps后少了resourcemanager，不过另外两个datanode执行jps是正常的，后来确认问题：</p><p><strong>namenode中的<u>yarn-site.xml</u>文件内容和datanode中的文件内容不一致</strong>，所以出现了resourcemanager启动失败的问题（似乎是启动后又关闭了），于是我把文件内容统一了一下，重新启动就正常了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License. See accompanying LICENSE file.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通知框架MR使用YARN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8033<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>昨天写了一个mapreduce函数一直有错误，找不到错误，今天找了一天终于解决了，原来是hadoop 的job.setOutputKeyClass和job.setOutputValueClas设置输出的问题。</p><p>job.<strong>setOutputKeyClass</strong>和job.<strong>setOutputValueClas</strong>在默认情况下是<strong>同时设置map阶段和reduce阶段的输出</strong>，也就是说只有map和reduce<strong>输出是一样的</strong>时候才不会出问题。</p><p>当map和reduce输出是不一样的时候就需要通过job.setMapOutputKeyClass和job.setMapOutputValueClas来设置map阶段的输出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来准备写个CentOS7下hadoop分布式集群的配置教程的，最近事情有点多，暂时搁置一下吧，先把遇到的小问题记录一下。&lt;/p&gt;
&lt;p&gt;首先我用的是VMware虚拟机创建了三台虚拟机，都是CentOS7的，一台master（命名为hadoop1），两台slaver（命名为hadoop2和hadoop3），然后在master上配置了一些eclipse，准备跑MapReduce代码的，中间遇到了点小问题。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ队列模式传递消息</title>
    <link href="http://yoursite.com/2018/10/20/ActiveMQ%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/10/20/ActiveMQ队列模式传递消息/</id>
    <published>2018-10-20T11:37:22.000Z</published>
    <updated>2018-10-20T11:37:22.954Z</updated>
    
    <content type="html"><![CDATA[<p>队列模式：点对点的方式（PTP）即：一个消息的生产者对应一个消费者，一个消息只能供一个消费者进行消费。</p><a id="more"></a><p><strong>生产者（Producer）实现步骤：</strong></p><p>第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递</p><p>第二步：通过第一步创建的工厂对象获得连接对象Connection</p><p>第三步：开启连接，直接调用connection对象的start方法即可</p><p>第四步：创建一个Session对象，通过connection对象创建</p><p>第五步：通过Session对象创建一个Destination对象（该对象有两种方式：topic和quene），这里使用quene</p><p>第六步：通过Session对象创建一个生产者Producer对象</p><p>第七步：创建Message对象，这里使用TextMessage对象，设置消息内容</p><p>第八步：使用创建的生产者对象Producer发送消息</p><p>第九步：关闭资源（Producer对象，Connection对象，Session对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>; <span class="comment">//127.0.0.1是回环地址，相当于localhost，61616是默认端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String queueName=<span class="string">"queue-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标</span></span><br><span class="line">            Destination destination = session.createQueue(queueName);</span><br><span class="line">            <span class="comment">//6.创建一个生产者</span></span><br><span class="line">            MessageProducer producer = session.createProducer(destination);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">//7.创建消息</span></span><br><span class="line">                TextMessage textMessage = session.createTextMessage(<span class="string">"test"</span> + i);</span><br><span class="line">                <span class="comment">//8.发布消息</span></span><br><span class="line">                producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"发送消息"</span> + textMessage.getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9.关闭连接</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者（Consumer）实现步骤：</strong></p><p>第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递</p><p>第二步：通过第一步创建的工厂对象获得连接对象Connection</p><p>第三步：开启连接，直接调用connection对象的start方法即可</p><p>第四步：创建一个Session对象，通过connection对象创建</p><p>第五步：创建一个Destination对象，使用quene，需要和生产者的quene一致</p><p>第六步：创建一个消费者对象</p><p>第七步：接收消息</p><p>第八步：打印接收的消息</p><p>第九步：关闭资源<strong>（此处关闭不要在监听后面直接关闭，因为监听是异步的，直接立刻关闭会导致监听没有结束就被关闭了，可以考虑在监听后面加入阻塞操作，让连接延迟中断）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String queueName=<span class="string">"queue-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标</span></span><br><span class="line">            Destination destination = session.createQueue(queueName);</span><br><span class="line">            <span class="comment">//6.创建一个消费者</span></span><br><span class="line">            MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line">            <span class="comment">//7.创建一个监听器</span></span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                    TextMessage textMessage = (TextMessage)message;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了）</span></span><br><span class="line">            <span class="comment">//等待键盘输入,可用于阻塞连接断开操作</span></span><br><span class="line">            <span class="comment">//System.in.read();</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外消费者可以开启多个，共同消费生成者产生的消息，这样消息会被均匀分配给消费者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;队列模式：点对点的方式（PTP）即：一个消息的生产者对应一个消费者，一个消息只能供一个消费者进行消费。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ主题模式传递消息</title>
    <link href="http://yoursite.com/2018/10/20/ActiveMQ%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/10/20/ActiveMQ主题模式传递消息/</id>
    <published>2018-10-20T11:37:22.000Z</published>
    <updated>2018-10-20T11:37:35.773Z</updated>
    
    <content type="html"><![CDATA[<p>订阅发布方式传递消息：Topic ，就类似微信公众号一样，可以多个订阅者接收一样的消息</p><p>补充：由于topic传递消息的特点是，一个生产者发送给多个消费者，生产者生产的消息在没有被消费者消费之前，并不会将消息持久化到activemq的服务端，发送的消息会自动消失。所以 测试的时候需要先创建消费者对象，然后再发送消息，防止消息丢失。</p><a id="more"></a><p><strong>生产者实现步骤：</strong></p><p>步骤和PTP的方式完全一样，不同的是在创建Destination对象的时候，需要创建topic对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">"topic-test"</span>; <span class="comment">//topic名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标（注意：此处变成了Topic）</span></span><br><span class="line">            Destination destination = session.createTopic(topicName);</span><br><span class="line">            <span class="comment">//6.创建一个生产者</span></span><br><span class="line">            MessageProducer producer = session.createProducer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">//7.创建消息</span></span><br><span class="line">                TextMessage textMessage = session.createTextMessage(<span class="string">"test"</span> + i);</span><br><span class="line">                <span class="comment">//8.发布消息</span></span><br><span class="line">                producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"发送消息"</span> + textMessage.getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9.关闭连接</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者实现的步骤：</strong></p><p>步骤和PTP消费者实现的步骤一样，唯一不同的是在创建Destination对象的时候，创建topic对象，同时要和发布订阅的生产者的topic一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">"topic-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标</span></span><br><span class="line">            Destination destination = session.createTopic(topicName);</span><br><span class="line">            <span class="comment">//6.创建一个消费者</span></span><br><span class="line">            MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line">            <span class="comment">//7.创建一个监听器</span></span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                    TextMessage textMessage = (TextMessage)message;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了）</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;订阅发布方式传递消息：Topic ，就类似微信公众号一样，可以多个订阅者接收一样的消息&lt;/p&gt;
&lt;p&gt;补充：由于topic传递消息的特点是，一个生产者发送给多个消费者，生产者生产的消息在没有被消费者消费之前，并不会将消息持久化到activemq的服务端，发送的消息会自动消失。所以 测试的时候需要先创建消费者对象，然后再发送消息，防止消息丢失。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——接口及其转换</title>
    <link href="http://yoursite.com/2018/10/20/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/10/20/JAVA笔记——接口及其转换/</id>
    <published>2018-10-20T07:45:56.819Z</published>
    <updated>2018-10-20T11:31:40.641Z</updated>
    
    <content type="html"><![CDATA[<p>仍然是这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.创建一个监听器</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage)message; <span class="comment">//强制转换，因为Producer发送的message已经确定是TextMessage类型的，</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>TextMessage textMessage = (TextMessage)message;这句让我感到疑惑。</p><a id="more"></a><ol><li><p><strong>TextMessage继承的Message，但是两者都是接口。怎么能直接用来生成对象呢？</strong></p><p>参考：Java接口可以有对象吗_百度知道  <a href="https://zhidao.baidu.com/question/579326704.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/579326704.html</a></p><p>其实这里相当于父类引用指向子类对象一样，就是用接口引用指向了一个实现了这个接口的对象，包括方法返回值是TextMessage也相当于是做了接口引用指向实现了这个接口的对象的转化。具体可以再看看参考。</p></li><li><p><strong>message是Message，即父接口，textMessage是TextMessage，即子接口，为啥这句代码把父类强制转换成了子类？</strong></p><p>这是因为在Producer时发送的消息就是TextMessage的（producer.send(textMessage);），这里相当于发送时把子类先转换成了父类引用，后来到这句代码又强制转换回来了，这样是没有影响的。</p><p><strong>PS：</strong>平时如果一个父类对象直接强制转换为子类一般是不允许的；反过来，若子类被强制转为父类，它的存储空间应该是没有变化的，只是属于自己子类特有的部分被锁起来了，可以用从父类继承过来的部分，如果强制转换回来可以解锁继续用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仍然是这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//7.创建一个监听器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;consumer.setMessageListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MessageListener() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message message)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TextMessage textMessage = (TextMessage)message; &lt;span class=&quot;comment&quot;&gt;//强制转换，因为Producer发送的message已经确定是TextMessage类型的，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;接受消息&quot;&lt;/span&gt;+textMessage.getText());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (JMSException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;TextMessage textMessage = (TextMessage)message;这句让我感到疑惑。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——匿名内部类</title>
    <link href="http://yoursite.com/2018/10/20/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/20/JAVA笔记——匿名内部类/</id>
    <published>2018-10-20T07:04:47.239Z</published>
    <updated>2018-10-20T11:31:50.700Z</updated>
    
    <content type="html"><![CDATA[<p>今天写ActiveMQ代码时遇到一个不熟悉的东西，叫匿名内部类，于是查阅记录一下。首先代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.创建一个监听器</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage)message; <span class="comment">//强制转换，因为Producer发送的message已经确定是TextMessage类型的</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>于是我查看了一下setMessageListener方法的定义，它的参数是MessageListener：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMessageListener</span><span class="params">(MessageListener var1)</span> <span class="keyword">throws</span> JMSException</span>;</span><br></pre></td></tr></table></figure><p>然后又看了一下MessageListener的定义，发现它是个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我就懵逼了。。为什么代码里new了一个接口，查了查才知道这叫匿名内部类。</p><p>参考资料：<a href="https://zhidao.baidu.com/question/424144818620834092.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/424144818620834092.html</a></p><p>也就是说，new MessageListener()后面的大括号内相当于创建了一个类，它实现了这个MessageListener接口，所以里面实现了onMessage（）方法。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天写ActiveMQ代码时遇到一个不熟悉的东西，叫匿名内部类，于是查阅记录一下。首先代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//7.创建一个监听器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;consumer.setMessageListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MessageListener() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message message)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TextMessage textMessage = (TextMessage)message; &lt;span class=&quot;comment&quot;&gt;//强制转换，因为Producer发送的message已经确定是TextMessage类型的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;接受消息&quot;&lt;/span&gt;+textMessage.getText());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (JMSException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="匿名内部类" scheme="http://yoursite.com/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java IDE配置ActiveMQ</title>
    <link href="http://yoursite.com/2018/10/20/Java%20IDE%E9%85%8D%E7%BD%AEActiveMQ/"/>
    <id>http://yoursite.com/2018/10/20/Java IDE配置ActiveMQ/</id>
    <published>2018-10-20T02:38:22.339Z</published>
    <updated>2018-10-20T11:31:00.781Z</updated>
    
    <content type="html"><![CDATA[<p>在实际操作中，我们需要用java完成activeMQ的应用，此处我使用的IntelliJ IDEA的编译器，eclipse的还没有尝试，不过应该是类似的，此处稍微记录一下。</p><a id="more"></a><ol><li>打开IDEA，选择Maven项目，直接点击next，GroupId写com.ActiveMQ.test1，ArtifactId写的test1，当然这个不是很重要，可以自己随意写，最后Finish就行。</li><li>然后在src/main/java下添加package和class</li><li>想要使用ActiveMQ，我们还需要把jar包导入，点击左上角File——进入Project Structure——找到Libraries——添加——选择ActiveMQ根目录下的jar包(比如activemq-all-5.15.6.jar)，导入后就差不多了，如果有相关提示，处理一下就行了。</li><li>再使用ActiveMQ内的函数已经编译器已经会自动识别和提示了</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际操作中，我们需要用java完成activeMQ的应用，此处我使用的IntelliJ IDEA的编译器，eclipse的还没有尝试，不过应该是类似的，此处稍微记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之递归</title>
    <link href="http://yoursite.com/2018/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2018/10/14/数据结构之递归/</id>
    <published>2018-10-14T15:12:08.944Z</published>
    <updated>2018-10-14T15:48:50.060Z</updated>
    
    <content type="html"><![CDATA[<p>递归既会出现多次函数调用，会多占用空间也会消耗时间，空间复杂度和时间复杂度都会上升，其他基础知识不再此赘述，主要记录一下几个关键点。</p><a id="more"></a> <h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><h2 id="递归需要注意的问题"><a href="#递归需要注意的问题" class="headerlink" title="递归需要注意的问题"></a>递归需要注意的问题</h2><ol><li>递归代码要警惕堆栈溢出，因为系统栈或者虚拟机栈空间一般都不大。解决方案：可以限制递归调用的最大深度，但是这种方法不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，无法事先计算，所以当最大递归深度比较小，如10、50时，可以使用这种方法。</li><li>递归代码要警惕重复计算。比如f(n)=f(n-1)+f(n-2)，那么f(4)=f(3)+f(2)且f(5)=f(4)+f(3)，则f(3)就被重复计算了两次。此时可以通过散列表为已经求出的f(K)值建立索引K，这样当在后面的递归中用到f(K)时就不需要重复计算了，只需要map.get(n)获取相应值即可。</li><li>谨防脏数据，出现递归死循环。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;递归既会出现多次函数调用，会多占用空间也会消耗时间，空间复杂度和时间复杂度都会上升，其他基础知识不再此赘述，主要记录一下几个关键点。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之队列</title>
    <link href="http://yoursite.com/2018/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/10/14/数据结构之队列/</id>
    <published>2018-10-14T08:22:57.308Z</published>
    <updated>2018-10-14T15:45:34.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h2><p>就像栈有顺序栈和链式栈一样，队列也有顺序的和链式的。</p><a id="more"></a> <p>顺序队列使用head指针指向队头，使用tail指针指向队尾，初始队列的头指针和尾指针指向第0个位置，入队操作时尾指针向后移（相当于尾指针是指向队列尾元素的下一个位置的），出队操作时头指针向后移（相当于头指针是指向队列头元素的位置的），队满的判断条件为 tail == n，队空的判断条件为 head == tail。随着不停地进行入队、出队操作，head 和 tail 都会持续后移，当 tail 移动到最右边，<strong>即使数组中还有空闲空间，也无法往队列里继续添加数据了</strong>，此时可以使用<strong>数据搬移</strong>，一个解决方案就是每进行一次出队操作，就把出队前0位置后面的数据前移一位，但是这样出队操作的时间复杂度会从O(1)变成O(n)；更好的方案是不必要每次出队后都进行一次数据迁移，而是<strong>等到队列没有空闲空间时，再次需要入队时集中触发数据搬移操作即可。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作，将 item 放入队尾 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tail == n 表示队列末尾没有空间了</span></span><br><span class="line">  <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">    <span class="comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 数据搬移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">         items[i-head] = items[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搬移完之后重新更新 head 和 tail</span></span><br><span class="line">    tail -= head;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  items[tail] = item;</span><br><span class="line">  ++tail;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将head到tail之间的数据移动至0到tail-head的位置。此时均摊时间复杂度为O(1)，平均时间复杂度也为O(1)（此处存疑）。</p><p>链式队列类似，不再赘述。</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列<strong>一般都是数组形式的顺序队列</strong>，链式的叫循环链表。</p><p>循环队列队空的判断条件仍为 head == tail，队满的判断条件为(tail+1)%n == head，也正因为这样，当队列满时， tail 指向的位置实际是没有存储数据的，所以会浪费一个数组的存储空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span> &#123;</span></span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">      items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">      n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> boolean <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//出队</span></span><br><span class="line">  <span class="keyword">public</span> String dequeue &#123;</span><br><span class="line">    <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> null;</span><br><span class="line">    String ret = item[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h2><p>阻塞队列其实就是在队列基础上增加了阻塞操作。就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。其实就是一个“生产者 - 消费者模型”。</p><p>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue()上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;顺序队列和链式队列&quot;&gt;&lt;a href=&quot;#顺序队列和链式队列&quot; class=&quot;headerlink&quot; title=&quot;顺序队列和链式队列&quot;&gt;&lt;/a&gt;顺序队列和链式队列&lt;/h2&gt;&lt;p&gt;就像栈有顺序栈和链式栈一样，队列也有顺序的和链式的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ安装</title>
    <link href="http://yoursite.com/2018/10/14/ActiveMQ%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/10/14/ActiveMQ安装/</id>
    <published>2018-10-13T16:32:00.753Z</published>
    <updated>2018-10-19T16:39:12.224Z</updated>
    
    <content type="html"><![CDATA[<p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。MQ: message queue, 顾名思义就是消息队列的意思。因而这个主要是关于消息交互和消息队列的。</p><a id="more"></a><h2 id="下载ActiveMQ"><a href="#下载ActiveMQ" class="headerlink" title="下载ActiveMQ"></a>下载ActiveMQ</h2><p>去官方网站下载：<a href="http://activemq.apache.org/" target="_blank" rel="noopener">http://activemq.apache.org/</a></p><p>下载之前注意查看版本对应的JDK要求，并在本机配置好；可以在官网release底下找到要求的最低版本，此处放出部分版本号。</p><table><thead><tr><th>MQ版本号</th><th>Build-Jdk</th><th>依赖JDK</th></tr></thead><tbody><tr><td>apache-activemq-5.11.0</td><td>1.7.0_60</td><td>1.7+</td></tr><tr><td>apache-activemq-5.12.0</td><td>1.7.0_80</td><td>1.7+</td></tr><tr><td>apache-activemq-5.13.0</td><td>1.7.0_80</td><td>1.7+</td></tr><tr><td>apache-activemq-5.14.0</td><td>1.7.0_80</td><td>1.7+</td></tr><tr><td>apache-activemq-5.15.0</td><td>1.8.0_112</td><td>1.8+</td></tr></tbody></table><h2 id="运行ActiveMQ"><a href="#运行ActiveMQ" class="headerlink" title="运行ActiveMQ"></a>运行ActiveMQ</h2><p>解压文件夹后进入bin目录，双击activemq.bat就可以启动ActiveMQ了</p><p><strong>此处我出现了一个问题</strong>，双击bat文件后出现控制台闪现后消失的现象，<strong>解决方案</strong>如下：</p><ol><li>windows系统，在bin文件夹下打开cmd命令行，输入 activemq-admin.bat start。  </li><li>大约是JDK版本问题，引起了闪退。</li><li>后来偶然发现另一个方式，根目录的bin文件下有win32和win64两个文件夹，因为我的是64位，所以就打开win64文件夹，并且运行activemq.bat即可直接使用。(当然若运行InstallService.bat并打开activemq服务可以直接打开管理页面，不需要去console运行了)</li></ol><p>我是使用了第一个方法解决的。</p><p>出错时显示如下：</p><p><img src="\uploads\ActiveMQ安装\ActiveMQ安装-1.png" alt="出错图"></p><p>解决后显示如下：</p><p><img src="\uploads\ActiveMQ安装\ActiveMQ安装-2.png" alt="解决图"></p><p>启动ActiveMQ以后，登陆：<a href="http://localhost:8161/admin/" target="_blank" rel="noopener">http://localhost:8161/admin/</a> ,账户和密码都是admin，正常显示如下：</p><p><img src="\uploads\ActiveMQ安装\ActiveMQ安装-3.png" alt="正常运行"></p><p>至此安装结束，可以创建queue了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。MQ: message queue, 顾名思义就是消息队列的意思。因而这个主要是关于消息交互和消息队列的。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之堆栈</title>
    <link href="http://yoursite.com/2018/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%A0%88/"/>
    <id>http://yoursite.com/2018/10/11/数据结构之堆栈/</id>
    <published>2018-10-11T15:24:13.330Z</published>
    <updated>2018-10-14T08:26:40.717Z</updated>
    
    <content type="html"><![CDATA[<p>关于堆栈的基础知识此处不做赘述。主要写一下今天学习数据结构的堆栈时看到的一个问题：</p><h2 id="JVM的堆栈和数据结构的堆栈一样么"><a href="#JVM的堆栈和数据结构的堆栈一样么" class="headerlink" title="JVM的堆栈和数据结构的堆栈一样么"></a>JVM的堆栈和数据结构的堆栈一样么</h2><p>第一反应肯定还是不一样的，但是具体为什么不一样好像也不知道个所以然。。于是上网查了查，此处引用一篇资料，希望有所帮助。<br><a id="more"></a></p><p>JVM中的stack和heap与数据结构中所说的stack和heap是一个概念吗-CSDN论坛<br><a href="https://bbs.csdn.net/topics/330120842" target="_blank" rel="noopener">https://bbs.csdn.net/topics/330120842</a></p><p><a href="https://blog.csdn.net/weixin_41856078/article/details/79725852" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41856078/article/details/79725852</a></p><p>JVM中的stack和heap的实现方法与特性和普通的数据结构是一样，概念上应该是一致的。只是实现层次不同，实现方式上肯定比一般的实现要复杂点，只是对外的操作肯定一致。</p><p><strong>数据结构中的堆栈</strong>：是两种特殊的数据结构，都是对数据项按序排列的数据结构，对管理数据的一种手段和方法。可以用来存放数据和地址，栈只能在一端（栈顶）对数据项进行插入和删除。</p><p><strong>内存中的堆栈</strong>：是确切存在的物理结构，是用来存放不同数据的内存空间。内存中的栈，是由系统自动分配和释放的，是由高地址向低地址扩展的数据机构，是一段连续的内存区域，是对数据结构中的栈这种手段的实现。栈的顶地址和最大容量是系统预先设定好的，在程序编译时，它就是一个确定的常数，但注意并不是所有用到栈技术的区域都是栈区，虽然目前是这样，这是概念定义的准确性问题。 内存中堆，一般用来动态分配内存的，它的实现跟操作系统和编译器有关，一般内存中的堆貌似是用链表实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于堆栈的基础知识此处不做赘述。主要写一下今天学习数据结构的堆栈时看到的一个问题：&lt;/p&gt;
&lt;h2 id=&quot;JVM的堆栈和数据结构的堆栈一样么&quot;&gt;&lt;a href=&quot;#JVM的堆栈和数据结构的堆栈一样么&quot; class=&quot;headerlink&quot; title=&quot;JVM的堆栈和数据结构的堆栈一样么&quot;&gt;&lt;/a&gt;JVM的堆栈和数据结构的堆栈一样么&lt;/h2&gt;&lt;p&gt;第一反应肯定还是不一样的，但是具体为什么不一样好像也不知道个所以然。。于是上网查了查，此处引用一篇资料，希望有所帮助。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆栈" scheme="http://yoursite.com/tags/%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之数组</title>
    <link href="http://yoursite.com/2018/10/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/10/09/数据结构之数组/</id>
    <published>2018-10-09T01:48:20.831Z</published>
    <updated>2018-10-14T08:27:49.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h2><p>数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><a id="more"></a> <ul><li><p>线性表</p><p>就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向，除了数组，链表、队列、栈等也是线性表结构（ 线性表是一种<strong>逻辑结构</strong>，而顺序表、链表等是<strong>存储结构</strong> ）。</p></li><li><p>非线性表</p><p>如二叉树、堆、图等，数据之间并不是简单的前后关系。</p></li></ul><hr><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><p>大多数会说链表适合插入、删除，时间复杂度为O(1)；数组适合查找，查找时间复杂度为O(1)。<strong>这是不准确的！</strong></p><p>数组适合查找，但是查找的时间复杂度并不是O(1)，即便是排序好的数组，用二分查找，时间复杂度也是O(log n)。所以正确的表述是，<strong>数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</strong></p><hr><h2 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h2><p>数组为了保持内存数据连续性，会导致插入、删除操作比较低效。</p><ul><li><p>插入</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第K个位置。<strong>在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为O(1)。</strong></p></li><li><p>删除</p><p>如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。我们可以<strong>将多次删除操作集中在一起执行</strong>。比如可以先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，从而可以大大减少删除操作导致的数据搬移。JVM标记清除垃圾回收算法就用了类似的思想。</p></li></ul><hr><h2 id="为什么大多数编程语言中，数组从0开始编号"><a href="#为什么大多数编程语言中，数组从0开始编号" class="headerlink" title="为什么大多数编程语言中，数组从0开始编号"></a>为什么大多数编程语言中，数组从0开始编号</h2><p>从数组的存储结构来看，<strong>下标</strong>准确说就是<strong>偏移</strong>。如果下标从0开始，那么</p><center>a[k]_address = base_address + k * type_size</center><p>若下标从1开始，则会变成</p><center>a[k]_address = base_address + (k-1) * type_size</center><p>那么每次随机访问数组元素时就多了一次减法运算，对于CPU来说，就是多了一次减法指令。</p><p>数组作为基础的数据结构，通过下标随机访问又是非常基础的操作，效率的优化就需要尽可能做到极致，所以选择了从0开始编号。另一方面，从历史角度来看，由于C语言设计用0作为数组下标，而后的java、javaScript等高级语言都是效仿了C语言，也为了减少C语言程序员学习java的学习成本。但比如Matlab就不是从0开始，Python支持负数下标。</p><hr><h2 id="使用容器还是数组"><a href="#使用容器还是数组" class="headerlink" title="使用容器还是数组"></a>使用容器还是数组</h2><p>比如C++的Vector或者Java的ArrayList等属于容器类，一般来说容器类相比数组会消耗一定的性能（比如动态扩容时往往是重新申请一个更大的空间，将数据拷贝进去，而拷贝操作十分耗时）。不过对于业务开发，直接用容器类就够了，比较省时省力，但如果是底层开发，性能需要尽量优化，则数组可能更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是数组&quot;&gt;&lt;a href=&quot;#什么是数组&quot; class=&quot;headerlink&quot; title=&quot;什么是数组&quot;&gt;&lt;/a&gt;什么是数组&lt;/h2&gt;&lt;p&gt;数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————1.两数之和</title>
    <link href="http://yoursite.com/2018/10/08/LeetCode%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2018/10/08/LeetCode——两数之和/</id>
    <published>2018-10-08T11:37:22.000Z</published>
    <updated>2018-12-06T09:12:34.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（简单）"><a href="#题目（简单）" class="headerlink" title="题目（简单）"></a>题目（简单）</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br><a id="more"></a><br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><pre><code>class Solution {public int[] twoSum(int[] nums, int target) {    for(int i=0;i&lt;nums.length;++i)    {        int T = target - nums[i];        for(int j=i+1;j&lt;nums.length;++j)        {            if(nums[j] == T)              return new int[]{i, j};  //不需要提前申请，直接可以返回        }    }    throw new IllegalArgumentException(&quot;No two sum solution&quot;); //抛出错误  }}</code></pre><h3 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1.暴力解法"></a>1.暴力解法</h3><p>暴力法很简单。遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。<br>​    <pre><code>public int[] twoSum(int[] nums, int target) {<br>​    for (int i = 0; i &lt; nums.length; i++) {<br>​        for (int j = i + 1; j &lt; nums.length; j++) {<br>​            if (nums[j] == target - nums[i]) {<br>​                return new int[] { i, j };<br>​            }<br>​        }<br>​    }<br>​    throw new IllegalArgumentException(“No two sum solution”);<br>}</code></pre></p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n<sup>2</sup>)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n)的时间。因此时间复杂度为 O(n<sup>2</sup>)。</li><li>空间复杂度：O(1)。</li></ul><h3 id="2-两遍哈希表"><a href="#2-两遍哈希表" class="headerlink" title="2.两遍哈希表"></a>2.两遍哈希表</h3><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。<br>通过以空间换取速度的方式，我们可以将查找时间从O(n)降低到O(1)。哈希表正是为此目的而构建的，它支持以<strong>近似</strong>恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。<br>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是nums[i]本身！<br>​    <pre><code>public int[] twoSum(int[] nums, int target) {<br>​    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br>​    for (int i = 0; i &lt; nums.length; i++) {<br>​        map.put(nums[i], i);<br>​    }<br>​    for (int i = 0; i &lt; nums.length; i++) {<br>​        int complement = target - nums[i];<br>​        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) {  //containsKey方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false<br>​            return new int[] { i, map.get(complement) };<br>​        }<br>​    }<br>​    throw new IllegalArgumentException(“No two sum solution”);<br>}</code></pre></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，我们把包含有n个元素的列表遍历两次。由于哈希表将查找时间缩短到O(1) ，所以时间复杂度为O(n)。</li><li>空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 </li></ul><h3 id="3-一遍哈希表"><a href="#3-一遍哈希表" class="headerlink" title="3.一遍哈希表"></a>3.一遍哈希表</h3><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。<br>​    <pre><code>public int[] twoSum(int[] nums, int target) {<br>​    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br>​    for (int i = 0; i &lt; nums.length; i++) {<br>​        int complement = target - nums[i];<br>​        if (map.containsKey(complement)) {<br>​            return new int[] { map.get(complement), i };<br>​        }<br>​        map.put(nums[i], i);<br>​    }<br>​    throw new IllegalArgumentException(“No two sum solution”);<br>}</code></pre></p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费O(1)的时间。</li><li>空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（简单）&quot;&gt;&lt;a href=&quot;#题目（简单）&quot; class=&quot;headerlink&quot; title=&quot;题目（简单）&quot;&gt;&lt;/a&gt;题目（简单）&lt;/h2&gt;&lt;p&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&lt;br&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
</feed>
