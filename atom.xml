<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JJ❤22</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-11T05:44:31.849Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JJZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ在windows配置安装</title>
    <link href="http://yoursite.com/2019/01/11/RocketMQ%E5%9C%A8windows%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/01/11/RocketMQ在windows配置安装/</id>
    <published>2019-01-11T05:37:22.000Z</published>
    <updated>2019-01-11T05:44:31.849Z</updated>
    
    <content type="html"><![CDATA[<p>配置过程不麻烦，就是有点小插曲</p><p>教程参考： <a href="https://yq.aliyun.com/articles/656078" target="_blank" rel="noopener">https://yq.aliyun.com/articles/656078</a>   </p><p>​           <a href="https://www.jianshu.com/p/4a275e779afa" target="_blank" rel="noopener">https://www.jianshu.com/p/4a275e779afa</a></p><p><strong>注意：</strong>过程中需要对JVM configuration 修改一下 内存 ： 修改<strong>runserver.sh</strong>和<strong>runbroker.sh</strong>，两个分别对应nameserver和broker的配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="string">"JAVA_OPT=%JAVA_OPT% -server -Xms2g -Xmx2g -Xmn1g"</span></span><br></pre></td></tr></table></figure><p>另外 如果启动broker出现找不到XXXXX主类的错误，把 %CLASSPATH% 加上双引号，修改为 “%CLASSPATH%” 就可以了</p><p><a href="https://blog.csdn.net/lvwenzhuye/article/details/81483479" target="_blank" rel="noopener">https://blog.csdn.net/lvwenzhuye/article/details/81483479</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;配置过程不麻烦，就是有点小插曲&lt;/p&gt;
&lt;p&gt;教程参考： &lt;a href=&quot;https://yq.aliyun.com/articles/656078&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://yq.aliyun.com/article
      
    
    </summary>
    
      <category term="RocketMQ" scheme="http://yoursite.com/categories/RocketMQ/"/>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>大数据——hashMap put函数 重复插入相同(key,value)的问题</title>
    <link href="http://yoursite.com/2018/12/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94hashMap%E7%9A%84put%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/12/28/大数据——hashMap的put重复插入问题/</id>
    <published>2018-12-27T16:31:26.088Z</published>
    <updated>2018-12-27T16:42:56.566Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">writer = SequenceFile.createWriter(fs, conf, path, key.getClass(), value.getClass());</span><br><span class="line"><span class="keyword">for</span>(File dir:dirs)&#123;</span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line"><span class="comment">//key：目录名+":"+文件名</span></span><br><span class="line">key.set(dir.getName() + <span class="string">":"</span> + file.getName());</span><br><span class="line"><span class="comment">//value：文件内容</span></span><br><span class="line">value.set(fileToString(file));</span><br><span class="line">fileContents.put(key, value); <span class="comment">//////////////////////////A</span></span><br><span class="line">fileContents.put(<span class="keyword">new</span> Text(dir.getName() + <span class="string">":"</span> + file.getName()), <span class="keyword">new</span> Text(fileToString(file))); <span class="comment">/////////////////////////////B</span></span><br><span class="line">writer.append(key, value);</span><br><span class="line"><span class="comment">//System.out.println(key + "\t" + value);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">IOUtils.closeStream(writer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天做基于hadoop的朴素贝叶斯文档分类时，遇到一个问题：注意代码块中的A和B，最开始使用A时我发现hashMap内存储的都是同一个(key，value)对，改成B就可以了，目测应该是key和value对数据引用后，修改key和value导致hash值变化了。</p><p>具体类比资料：hashmap出现重复key的情况 - qq_29909965的博客 - CSDN博客<br><a href="https://blog.csdn.net/qq_29909965/article/details/78358066" target="_blank" rel="noopener">https://blog.csdn.net/qq_29909965/article/details/78358066</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——类的访问权限</title>
    <link href="http://yoursite.com/2018/12/17/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2018/12/17/JAVA笔记—类的访问权限/</id>
    <published>2018-12-17T01:35:12.815Z</published>
    <updated>2018-12-17T01:38:50.758Z</updated>
    
    <content type="html"><![CDATA[<p><img src="\uploads\JAVA笔记\1.png" alt="1"></p><p>如果一个类的成员没有任何权限修饰，那么它门就是缺省包访问权限，用friendly来表示，注意friendly不是Java中的关键字，这里是个人喜欢的方式用它表示而已。同一个包内其它类可以访问，但包外就不可以。对于同一个文件夹下的、没有用package的classes，Java会自动将这些classes初见为隶属于该目录的default package，可以相互调用class中的friendly成员。</p><p>如以下两个class分别在同一个文件夹的两个文件中，虽然没有引入package，但隶属于相同的default package。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sundae</span></span>&#123;</span><br><span class="line">　　 <span class="comment">//以下两个方法缺省为friendly</span></span><br><span class="line">　　 Sundae()&#123;&#125;</span><br><span class="line">　　 <span class="function">Void <span class="title">f</span><span class="params">()</span> </span>&#123;System.out.println(“Sundae.f()”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span></span>&#123;</span><br><span class="line">　　 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　 Sundae x = <span class="keyword">new</span> Sundae();</span><br><span class="line">　　 x.f();</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类来说：同一个包中的类可以用。总之，类只可以声明为public或者friendly。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;\uploads\JAVA笔记\1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果一个类的成员没有任何权限修饰，那么它门就是缺省包访问权限，用friendly来表示，注意friendly不是Java中的关键字，这里是个人喜欢的方式用它表示而已。同一个包内
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————9.回文数</title>
    <link href="http://yoursite.com/2018/12/16/LeetCode%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://yoursite.com/2018/12/16/LeetCode——回文数/</id>
    <published>2018-12-16T06:50:22.000Z</published>
    <updated>2018-12-16T08:07:43.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（简单）"><a href="#题目（简单）" class="headerlink" title="题目（简单）"></a><strong>题目（简单）</strong></h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p>输入: 10</p><p>输出: false</p><p>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h4 id="方法：反转一半数字"><a href="#方法：反转一半数字" class="headerlink" title="方法：反转一半数字"></a>方法：反转一半数字</h4><p><strong>思路</strong></p><p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p><p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。 但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。</p><p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><p>例如，输入 <code>1221</code>，我们可以将数字“12<strong>21</strong>”的后半部分从“<strong>21</strong>”反转为“<strong>12</strong>”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 <code>1221</code> 是回文。</p><p>让我们看看如何将这个想法转化为一个算法。</p><p><strong>算法</strong></p><p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 <code>-</code> 不等于 <code>3</code>。所以我们可以对所有负数返回 false。</p><p>现在，让我们来考虑如何反转后半部分的数字。 对于数字 <code>1221</code>，如果执行 <code>1221 % 10</code>，我们将得到最后一位数字 <code>1</code>，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 <code>1221</code> 中移除，<code>1221 / 10 = 122</code>，再求出上一步结果除以10的余数，<code>122 % 10 = 2</code>，就可以得到倒数第二位数字。如果我们把最后一位数字乘以10，再加上倒数第二位数字，<code>1 * 10 + 2 = 12</code>，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。</p><p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> bool <span class="title">IsPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log<sub>10</sub>(n)， 对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(log<sub>10</sub>(n)。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目（简单）&quot;&gt;&lt;a href=&quot;#题目（简单）&quot; class=&quot;headerlink&quot; title=&quot;题目（简单）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（简单）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————7.整数反转</title>
    <link href="http://yoursite.com/2018/12/07/LeetCode%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/12/07/LeetCode——整数反转/</id>
    <published>2018-12-06T16:37:22.000Z</published>
    <updated>2018-12-06T17:42:55.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（简单）"><a href="#题目（简单）" class="headerlink" title="题目（简单）"></a><strong>题目（简单）</strong></h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，<strong>如果反转后整数溢出那么就返回 0。</strong><a id="more"></a></p><hr><p>题目很明确，很自然的想法就是通过除法和取余逐位取出，再依次乘10加余数达到反向效果，但是也有一点就是<strong>做乘法时可能会出现溢出的情况</strong>。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>反转整数的方法可以与反转字符串进行类比。</p><p>我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。</p><p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop operation:</span></span><br><span class="line">pop = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push operation:</span></span><br><span class="line">temp = rev * <span class="number">10</span> + pop;</span><br><span class="line">rev = temp;</span><br></pre></td></tr></table></figure><p>但是，这种方法很危险，因为当 temp=rev⋅10+pop 时会导致溢出。</p><p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p><p>为了便于解释，我们假设 rev 是正数。</p><p><img src="\uploads\LeetCode\2.png" alt="2"></p><p>这里要补充两点：</p><p>1.显然因为top只能是处于0~9的个位数字，所以若rev·10+top溢出，那么rev&gt;=INTMAX/10必然成立。</p><p>2.若rev==INTMAX/10，若pop&gt;7(假设为8)，那么反转前肯定是8xxxxxxxx，显然超出了Int的范围，所以top&lt;=7一定成立的。</p><p>当 rev 为负时可以应用类似的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> X =x;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">X = -x;</span><br><span class="line"><span class="keyword">int</span> rev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(X&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> end = X%<span class="number">10</span>;</span><br><span class="line">        X = X/<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(rev&gt;<span class="number">214748364</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rev = rev*<span class="number">10</span>+end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">        rev = -rev;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE/<span class="number">10</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE/<span class="number">10</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(log<sub>10</sub>(n))，因为每次都通过除以10取出尾数位。</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（简单）&quot;&gt;&lt;a href=&quot;#题目（简单）&quot; class=&quot;headerlink&quot; title=&quot;题目（简单）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（简单）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; &lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: -123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -321&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，&lt;strong&gt;如果反转后整数溢出那么就返回 0。&lt;/strong&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="简单题型" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————5.最长回文子串(常考)</title>
    <link href="http://yoursite.com/2018/12/06/LeetCode%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2018/12/06/LeetCode——最长回文子串/</id>
    <published>2018-12-06T09:37:22.000Z</published>
    <updated>2018-12-06T15:41:19.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（中等）"><a href="#题目（中等）" class="headerlink" title="题目（中等）"></a><strong>题目（中等）</strong></h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><a id="more"></a> <hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><h3 id="1-最大公共子串法"><a href="#1-最大公共子串法" class="headerlink" title="1.最大公共子串法"></a>1.最大公共子串法</h3><p>第一个比较容易的想法可能就是 把字符串S反转过来，记为S’，先使用<strong>动态规划方法</strong>找到S与S’之间的最长公共子串，即所求的最长回文子串。</p><p>例如，S = “caba” , S’ = “abac”, S 以及 S’ 之间的最长公共子串为 “aba”，恰恰是答案。</p><p>让我们尝试一下这个例子：S = “abacdfgdcaba” , S’ = “abacdgfdcaba”, S 以及 S’之间的最长公共子串为 “abacd”，显然，这不是回文。</p><p>我们可以看到，当 S 的其他部分中存在非回文子串的反向副本时(即例子中的abacd和dcaba)，最长公共子串法就会失败。为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要<strong>检查子串的索引是否与反向子串的原始索引相同</strong>。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。</p><p>这里要解释一下上面加粗的那句，即判断条件，比如”caba”这个串，反转找到的最长公共子串是”aba”，它在”cab<strong>a</strong>“的结束索引为<strong>3</strong>（不是1是因为最长公共子串找到的索引是<strong>结束索引</strong>）；在反向串”ab<strong>a</strong>c”中的<strong>结束索引</strong>为<strong>2</strong>，我们要找的<strong>原始索引</strong>就是在反向串中的<strong>反向索引</strong>，即”aba”的<strong>开始索引</strong>（串长 4-1-<strong>结束索引2</strong>=4-1-2=<strong>1</strong>）加上该最大公共子串长度3再减1（即<strong>1</strong>+3-1=<strong>3</strong>）因为反向索引<strong>3</strong>和原串的索引<strong>3</strong>相等，所以认定这是个回文串，而不是反向副本；再比如”abacdfgdcaba”，找到的公共子串”abacd”的<strong>结束索引</strong>为<strong>4</strong>，<strong>开始索引</strong>=12-1-4=7，又因为最大公共子串长为5，所以反向串中的<strong>原始索引</strong>就为7+5-1=11，这与原串的结束索引4不等，所以这是个反向副本，而不是回文数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line">   <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        String s1 = s;</span><br><span class="line">        String s2 = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">        String str=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l1 = s1.length();</span><br><span class="line"><span class="keyword">int</span> l2 = s2.length();</span><br><span class="line"><span class="keyword">int</span> max_index1[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">int</span> max_index2[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> array[][] = <span class="keyword">new</span> <span class="keyword">int</span>[l1][l2];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;s.length();++t)</span><br><span class="line">&#123;</span><br><span class="line">max_index1[t] = -<span class="number">1</span>;</span><br><span class="line">max_index2[t] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;l2;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">array[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">array[i][j] = array[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(array[i][j] &gt; max_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r_index2 = s.length()-j-<span class="number">1</span>;  <span class="comment">//判断是否是回文而不是反向副本</span></span><br><span class="line"><span class="keyword">if</span>(i == r_index2+array[i][j]-<span class="number">1</span>)  <span class="comment">//判断是否是回文而不是反向副本</span></span><br><span class="line">&#123;</span><br><span class="line">max_len = array[i][j];</span><br><span class="line">max_index1[<span class="number">0</span>] = i;</span><br><span class="line">max_index2[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;s.length();++t)</span><br><span class="line">&#123;</span><br><span class="line">max_index1[t] = -<span class="number">1</span>;</span><br><span class="line">max_index2[t] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">array[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(max_index1[<span class="number">0</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">str = (s1.substring(max_index1[<span class="number">0</span>]-max_len+<span class="number">1</span>,max_index1[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line">System.out.print(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：因为是动态规划，所以是O(n<sup>2</sup>)。</p><p>空间复杂度：因为用了空间换时间，所以是O(n<sup>2</sup>)。其实还可以通过<strong>把Array二维数组转换为一维</strong>，因为每次循环都是固定i，内部循环j，而第3行的数据其实只用到之前第2行的数据，不需要第1行的，所以每次用一维数组重复利用，做数据更新就可以了。这样空间复杂度就缩小到了O(n)。</p><h3 id="2-暴力法"><a href="#2-暴力法" class="headerlink" title="2.暴力法"></a>2.暴力法</h3><p>很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。但是暴力法面对比如”zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz”这样的超长回文串，就会因为时间开销太大而超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_index = -<span class="number">1</span>;</span><br><span class="line">String str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> start = i,end = j;</span><br><span class="line"><span class="keyword">while</span>(s.charAt(start) == s.charAt(end))</span><br><span class="line">&#123;</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line"><span class="keyword">if</span>(end&lt;<span class="number">0</span> || start&gt;s.length()-<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(start &gt;= end &amp;&amp; j-i+<span class="number">1</span> &gt; max_len)</span><br><span class="line">&#123;</span><br><span class="line">max_len = j-i+<span class="number">1</span>;</span><br><span class="line">max_index = j;</span><br><span class="line">str = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n<sup>3</sup>)，因为要进行N<em>N的循环，每次循环还要遍历根据初始位置start和结束位置end找出的子串判断是否是回文串，所以为N </em> N * N。</p><p>空间复杂度：O(1)</p><h3 id="3-动态规划法"><a href="#3-动态规划法" class="headerlink" title="3.动态规划法"></a>3.动态规划法</h3><p>为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，“ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。</p><p>我们给出 P(i,j) 的定义如下：</p><p><img src="\uploads\LeetCode\1.png" alt="1"></p><p>基本示例如下：</p><p>P(i, i) = true</p><p>P(i, i+1) = (Si==Si+1)</p><p>这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len[]=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">//记录是否为回文串，不是就记为0，是的就记录回文串长度</span></span><br><span class="line"><span class="keyword">int</span> max_len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max_index=<span class="number">0</span>;</span><br><span class="line">String str=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=s.length()-<span class="number">1</span>;j&gt;=i;--j)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(i == j)  <span class="comment">//边界（奇数）</span></span><br><span class="line">   len[j] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(Math.abs(i-j)==<span class="number">1</span>) <span class="comment">//边界（偶数）</span></span><br><span class="line">   &#123;</span><br><span class="line">   len[j] = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   len[j] = len[j-<span class="number">1</span>]==<span class="number">0</span>? <span class="number">0</span>:len[j-<span class="number">1</span>]+<span class="number">2</span>;  <span class="comment">//判断内部子串是不是回文串，不是为false，是的就记录回文串长度</span></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   len[j] = <span class="number">0</span>;  <span class="comment">//不是回文串</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(len[j]&gt;max_len)</span><br><span class="line">   &#123;</span><br><span class="line">   max_len = len[j];</span><br><span class="line">   max_index = j;</span><br><span class="line">   str = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n<sup>2</sup>)</p><p>空间复杂度：正常情况下是O(n<sup>2</sup>)， 因为动态规划方法使用 O(n<sup>2</sup>)的空间来存储表。同样的，这个空间复杂度可以优化到<strong>O(n)</strong>，<strong>空间复杂度：O(n^2)O(n2)， 该方法使用 O(n^2)O(n2) 的空间来存储表。</strong></p><h3 id="4-中心扩展法"><a href="#4-中心扩展法" class="headerlink" title="4.中心扩展法"></a>4.中心扩展法</h3><p>事实上，只需使用恒定的空间，我们就可以在 O(n<sup>2</sup>) 的时间内解决这个问题。</p><p>我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。</p><p>你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个 ‘b’ 之间）。所以找奇数长度的回文串时可以遍历n个中心（也就是n个字符均作为一次中心），找偶数长度回文串时可以遍历n-1个中心（也就是n个字符之间的空隙均作为一次中心），加起来就是n+n-1=2n-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">""</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len=<span class="number">0</span>,length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start=-<span class="number">1</span>,end=-<span class="number">1</span>;</span><br><span class="line">String str=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = expandAroundCenter(s,i,i);</span><br><span class="line"><span class="keyword">int</span> len2 = expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">length = (len1&gt;len2)?len1:len2;</span><br><span class="line"><span class="keyword">if</span>(length&gt;max_len)</span><br><span class="line">&#123;</span><br><span class="line">max_len = length;</span><br><span class="line">start = i-((length+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>);</span><br><span class="line">end = start+length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str = s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>  <span class="comment">//从left/right的中心开始扩展</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L=left,R=right;</span><br><span class="line"><span class="keyword">while</span>(L&gt;=<span class="number">0</span> &amp;&amp; R&lt;=s.length()-<span class="number">1</span> &amp;&amp; s.charAt(L)==s.charAt(R))</span><br><span class="line">&#123;</span><br><span class="line">L--;</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> R-L-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n<sup>2</sup>)， 由于围绕中心来扩展回文会耗去 O(n) 的时间，所以总的复杂度为 O(n<sup>2</sup>)。</li><li>空间复杂度：O(1)。 </li></ul><h3 id="5-Manacher-马拉车算法"><a href="#5-Manacher-马拉车算法" class="headerlink" title="5.Manacher 马拉车算法"></a>5.Manacher 马拉车算法</h3><p>这个算法比较复杂，可以把时间复杂度和空闲复杂度都缩减到O(n)，建议多查看一些资料，此处不做叙述。</p><p>参考资料：Longest Palindromic Substring Part II – LeetCode</p><p><a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="noopener">https://articles.leetcode.com/longest-palindromic-substring-part-ii/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（中等）&quot;&gt;&lt;a href=&quot;#题目（中等）&quot; class=&quot;headerlink&quot; title=&quot;题目（中等）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（中等）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入: “babad”&lt;br&gt;输出: “bab”&lt;br&gt;注意: “aba” 也是一个有效答案。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入: “cbbd”&lt;br&gt;输出: “bb”&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="中等题型" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大数据————淘宝双十一项目实战</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E6%B7%98%E5%AE%9D%E5%8F%8C%E5%8D%81%E4%B8%80%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2018/12/04/大数据——淘宝双十一项目实战/</id>
    <published>2018-12-04T14:30:55.498Z</published>
    <updated>2018-12-04T15:15:48.930Z</updated>
    
    <content type="html"><![CDATA[<p>今天完成了一个基于淘宝双十一交易数据的大数据分析实战项目，这里稍作记录。</p><p>教程：淘宝双11数据分析与预测课程案例：厦大数据库实验室博客  <a href="http://dblab.xmu.edu.cn/blog/1362-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/1362-2/</a></p><p>项目和文档：<a href="https://github.com/JayZeed/taobao11" target="_blank" rel="noopener">https://github.com/JayZeed/taobao11</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天完成了一个基于淘宝双十一交易数据的大数据分析实战项目，这里稍作记录。&lt;/p&gt;
&lt;p&gt;教程：淘宝双11数据分析与预测课程案例：厦大数据库实验室博客  &lt;a href=&quot;http://dblab.xmu.edu.cn/blog/1362-2/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据————Ubuntu14.04 Echarts图例设置后不显示</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20Echarts%E5%9B%BE%E4%BE%8B%E8%AE%BE%E7%BD%AE%E5%90%8E%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/12/04/大数据——Ubuntu14.04 Echarts图例设置后不显示/</id>
    <published>2018-12-04T14:12:42.035Z</published>
    <updated>2018-12-04T15:15:35.005Z</updated>
    
    <content type="html"><![CDATA[<p>Echarts是用于前端数据可视化的一个工具。可以把数据以各种图表方式显示出来。</p><p>最近做一个大数据项目时，通过Echarts做了一个柱状图，但是设置了的图例一直不能显示出来。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">        x: <span class="string">'center'</span>,</span><br><span class="line">        data:[<span class="string">'销量'</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>红框内就是图例：</p><p><img src="\uploads\大数据——Echarts图例\1.png" alt="图例"></p><p>查了一些资料才知道原来<strong>需要series中的name和legend的data一致</strong>，这样才能显示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">    x: <span class="string">'center'</span>,</span><br><span class="line">    data:[<span class="string">'销量'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">series : [</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">'销量'</span>,</span><br><span class="line">        type:<span class="string">'bar'</span>,</span><br><span class="line">        barWidth: <span class="string">'60%'</span>,</span><br><span class="line">        data:y</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果想设置图例颜色，可以在option里设置 color : […] 实现。</p><p>参考资料：echarts柱状图图例不显示的问题 - royal1235的博客 - CSDN博客<br><a href="https://blog.csdn.net/royal1235/article/details/80746278" target="_blank" rel="noopener">https://blog.csdn.net/royal1235/article/details/80746278</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Echarts是用于前端数据可视化的一个工具。可以把数据以各种图表方式显示出来。&lt;/p&gt;
&lt;p&gt;最近做一个大数据项目时，通过Echarts做了一个柱状图，但是设置了的图例一直不能显示出来。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据————Ubuntu14.04 JavaScript array保存object对象出错</title>
    <link href="http://yoursite.com/2018/12/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20JavaScript%20array%E4%BF%9D%E5%AD%98object%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/12/04/大数据——Ubuntu14.04 JavaScript array保存object对象/</id>
    <published>2018-12-04T12:46:46.249Z</published>
    <updated>2018-12-04T14:32:14.632Z</updated>
    
    <content type="html"><![CDATA[<p>用JSP开发WEB应用时用到了javascript语言，其中想在数组保存object对象时出了点小问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydata=[];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> obj =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = &lt;%=a[0]%&gt;;</span><br><span class="line">...</span><br><span class="line">mydata.push(obj);</span><br></pre></td></tr></table></figure><p>这里我想将obj用数组存起来，发现存储失败了，控制台调试发现报错：ReferenceError: 台湾 is not defined （这里台湾是&lt;%=a[0]%&gt;得到的值）大概意思是把台湾作为变量了，而不是一个值。<a id="more"></a></p><p>因为&lt;%=a[0]%&gt;表示取得a[0]的值，那么 obj.name = &lt;%=a[0]%&gt;; 就相当于 obj.name = 台湾; 确实会被理解成变量名，而我们需要的应该是 obj.name = “台湾” ; </p><p>所以只需要改成 obj.name = “&lt;%=a[0]%&gt;”; 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用JSP开发WEB应用时用到了javascript语言，其中想在数组保存object对象时出了点小问题。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mydata=[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.name = &amp;lt;%=a[0]%&amp;gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mydata.push(obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里我想将obj用数组存起来，发现存储失败了，控制台调试发现报错：ReferenceError: 台湾 is not defined （这里台湾是&amp;lt;%=a[0]%&amp;gt;得到的值）大概意思是把台湾作为变量了，而不是一个值。
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>大数据——Ubuntu14.04 使用Sqoop将数据从Hive导入MySQL出错</title>
    <link href="http://yoursite.com/2018/11/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20%E4%BD%BF%E7%94%A8Sqoop%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8EHive%E5%AF%BC%E5%85%A5Mysql%E5%87%BA%E9%94%99/"/>
    <id>http://yoursite.com/2018/11/29/大数据——Ubuntu14.04 使用Sqoop将数据从Hive导入Mysql出错/</id>
    <published>2018-11-29T13:24:27.585Z</published>
    <updated>2018-11-29T13:45:45.570Z</updated>
    
    <content type="html"><![CDATA[<p>在基于大数据双十一用户行为统计与分析实验中 进行导入数据操作时：</p><p>(4)导入数据(执行时间：20秒左右)<br>注意，刚才已经退出MySQL，回到了Shell命令提示符状态。下面就可以执行数据导入操作</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/sqoop</span><br><span class="line">bin/sqoop export --connect jdbc:mysql://localhost:3306/dbtaobao --username root --password root --table user_log --export-dir '/user/hive/warehouse/dbtaobao.db/inner_user_log' --fields-terminated-by ',';</span><br></pre></td></tr></table></figure><p>执行<strong>错误提示</strong>如下：</p><p>18/11/29 05:20:45 <strong>ERROR manager.SqlManager:</strong> <strong>Error executing statement: java.sql.SQLException: Access denied for user ‘root‘@’localhost’ (using password: YES)</strong><br>java.sql.SQLException: Access denied for user ‘root‘@’localhost’ (using password: YES)<br>​    at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:965)<br>​    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3978)<br>​    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3914)<br>​    at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:871)<br>​    at com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1714)<br>​    at com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1224)<br>​    at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2199)<br>​    at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2230)<br>​    at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2025)<br>​    at com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:778)<br>​    at com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:47)<br>​    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)<br>​    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)<br>​    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)<br>​    at java.lang.reflect.Constructor.newInstance(Constructor.java:526)<br>​    at com.mysql.jdbc.Util.handleNewInstance(Util.java:425)<br>​    at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:386)<br>​    at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:330)<br>​    at java.sql.DriverManager.getConnection(DriverManager.java:571)<br>​    at java.sql.DriverManager.getConnection(DriverManager.java:215)<br>​    at org.apache.sqoop.manager.SqlManager.makeConnection(SqlManager.java:904)<br>​    at org.apache.sqoop.manager.GenericJdbcManager.getConnection(GenericJdbcManager.java:59)<br>​    at org.apache.sqoop.manager.SqlManager.execute(SqlManager.java:763)<br>​    at org.apache.sqoop.manager.SqlManager.execute(SqlManager.java:786)<br>​    at org.apache.sqoop.manager.SqlManager.getColumnInfoForRawQuery(SqlManager.java:289)<br>​    at org.apache.sqoop.manager.SqlManager.getColumnTypesForRawQuery(SqlManager.java:260)<br>​    at org.apache.sqoop.manager.SqlManager.getColumnTypes(SqlManager.java:246)<br>​    at org.apache.sqoop.manager.ConnManager.getColumnTypes(ConnManager.java:327)<br>​    at org.apache.sqoop.orm.ClassWriter.getColumnTypes(ClassWriter.java:1872)<br>​    at org.apache.sqoop.orm.ClassWriter.generate(ClassWriter.java:1671)<br>​    at org.apache.sqoop.tool.CodeGenTool.generateORM(CodeGenTool.java:106)<br>​    at org.apache.sqoop.tool.ExportTool.exportTable(ExportTool.java:63)<br>​    at org.apache.sqoop.tool.ExportTool.run(ExportTool.java:99)<br>​    at org.apache.sqoop.Sqoop.run(Sqoop.java:147)<br>​    at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:70)<br>​    at org.apache.sqoop.Sqoop.runSqoop(Sqoop.java:183)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:234)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:243)<br>​    at org.apache.sqoop.Sqoop.main(Sqoop.java:252)<br>18/11/29 05:20:45 ERROR tool.ExportTool: Encountered IOException running export job:<br>java.io.IOException: No columns to generate for ClassWriter<br>​    at org.apache.sqoop.orm.ClassWriter.generate(ClassWriter.java:1677)<br>​    at org.apache.sqoop.tool.CodeGenTool.generateORM(CodeGenTool.java:106)<br>​    at org.apache.sqoop.tool.ExportTool.exportTable(ExportTool.java:63)<br>​    at org.apache.sqoop.tool.ExportTool.run(ExportTool.java:99)<br>​    at org.apache.sqoop.Sqoop.run(Sqoop.java:147)<br>​    at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:70)<br>​    at org.apache.sqoop.Sqoop.runSqoop(Sqoop.java:183)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:234)<br>​    at org.apache.sqoop.Sqoop.runTool(Sqoop.java:243)<br>​    at org.apache.sqoop.Sqoop.main(Sqoop.java:252)</init></init></p><p>出现这个错误，第一反应是当前用户对于Mysql的权限不够，于是第一反应去修改权限：</p><p>先进入mysql shell:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -u root -p</span></span><br></pre></td></tr></table></figure><p>然后修改权限(第一个root表示用户，第二个root表示密码)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> grant all privileges on *.* to root@localhost identified by <span class="string">'root'</span>;</span></span><br></pre></td></tr></table></figure><p>最好刷新一下权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> flush privileges;</span></span><br></pre></td></tr></table></figure><p>经过尝试之后我发现  并 没 有 卵 用</p><p>那么问题肯定不是这个，仔细看了一遍该export指令的参数:</p><p><strong>字段解释：</strong></p><p>./bin/sqoop export ##表示数据从 hive 复制到 mysql 中<br>–connect jdbc:mysql://localhost:3306/dbtaobao<br>–username root #mysql登陆用户名<br>–password root #登录密码<br>–table user_log #mysql 中的表，即将被导入的表名称<br>–export-dir ‘/user/hive/warehouse/dbtaobao.db/user_log ‘ #hive 中被导出的文件<br>–fields-terminated-by ‘,’ #Hive 中被导出的文件字段的分隔符</p><p>我发现：password错了。。。</p><p>修改之后就正常执行了。。。下次一定要注意参数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在基于大数据双十一用户行为统计与分析实验中 进行导入数据操作时：&lt;/p&gt;
&lt;p&gt;(4)导入数据(执行时间：20秒左右)&lt;br&gt;注意，刚才已经退出MySQL，回到了Shell命令提示符状态。下面就可以执行数据导入操作&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>大数据——Ubuntu14.04 安装mysql</title>
    <link href="http://yoursite.com/2018/11/27/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%E5%AE%89%E8%A3%85mysql/"/>
    <id>http://yoursite.com/2018/11/27/大数据——Ubuntu14.04安装mysql/</id>
    <published>2018-11-27T15:35:14.133Z</published>
    <updated>2018-11-28T02:13:13.039Z</updated>
    
    <content type="html"><![CDATA[<p>今天用Ubuntu安装mysql遇到了几个小坑，记录一下帮助更多的人避坑。</p><p><strong>安装教程：</strong>Ubuntu安装MySQL及常用操作_厦大数据库实验室博客  <a href="http://dblab.xmu.edu.cn/blog/install-mysql/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/install-mysql/</a></p><a id="more"></a><hr><p><strong>1.mysql安装后找不到</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server  #安装mysql</span><br></pre></td></tr></table></figure><p>上述语句执行后，执行 <strong>service mysql start</strong> 出现找不到mysql情况，使用 <strong>sudo netstat -tap | grep mysql</strong> 也不能找到mysql，后来添加了两条指令，总共三条完成了mysql安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt install mysql-client</span><br><span class="line">sudo apt install libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/itxiaolong3/article/details/77905923" target="_blank" rel="noopener">https://blog.csdn.net/itxiaolong3/article/details/77905923</a></p><p><strong>2.mysqld.cnf找不到</strong></p><p>想修改 <strong>/etc/mysql/mysql.conf.d/mysqld.cnf</strong> 配置文件结果找不到，这个和mysql的版本也有关，我这个5.5版本没有这个文件。</p><p>于是修改了 <strong>/etc/mysql/my.cnf</strong> 文件，该文件配置全局选项。</p><p>/etc/my.cnf    全局选项<br>/etc/mysql/my.cnf    全局选项<br>SYSCONFDIR/my.cnf    全局选项<br>$MYSQL_HOME/my.cnf    服务器特定选项（仅限服务器）<br>defaults-extra-file    指定的文件 –defaults-extra-file，如果有的话<br>~/.my.cnf    用户特定选项<br>~/.mylogin.cnf    用户特定的登录路径选项（仅限客户端）</p><p><strong>3.如果还是出现无法使用service mysql start命令的情况</strong></p><p>可能你的mysql版本有问题，（我按教程自动获取最新版本获取的是5.5的，而课题中需要的是5.7的）</p><p>可以参考该教程自己选择和下载对应版本：<br>请自行尝试，我是先按照下面第二个教程配置到3）、安装mysql－server时解包出错了，一番折腾没有解决，换了第一个，又按顺序解包一遍成功。<br>Ubuntu14.04 下安装离线安装Mysql5.7 - wst878882582的博客 - CSDN博客<br><a href="https://blog.csdn.net/wst878882582/article/details/78457531" target="_blank" rel="noopener">https://blog.csdn.net/wst878882582/article/details/78457531</a></p><p>Ubuntu14.04安装MySQL5.7.20（MySQL最新版本） - qq_34256348的博客 - CSDN博客<br><a href="https://blog.csdn.net/qq_34256348/article/details/78340333" target="_blank" rel="noopener">https://blog.csdn.net/qq_34256348/article/details/78340333</a></p><p><strong>4.ERROR 1146 (42S02): Table ‘performance_schema.session_variables’ doesn’t exist</strong></p><p>使用<strong>show variables like “char%”;</strong>指令时出现该错误</p><p>需要进行<strong>mysql_upgrade</strong>操作进行修复</p><p>1）首先退出mysql</p><p>2）在命令行界面输入：mysql_upgrade -uroot -p –force</p><p>3）然后重启mysql即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天用Ubuntu安装mysql遇到了几个小坑，记录一下帮助更多的人避坑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装教程：&lt;/strong&gt;Ubuntu安装MySQL及常用操作_厦大数据库实验室博客  &lt;a href=&quot;http://dblab.xmu.edu.cn/blog/install-mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dblab.xmu.edu.cn/blog/install-mysql/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode————2.两数相加</title>
    <link href="http://yoursite.com/2018/11/27/LeetCode%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2018/11/27/LeetCode——两数相加/</id>
    <published>2018-11-27T02:37:22.000Z</published>
    <updated>2018-12-06T09:12:39.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目（中等）"><a href="#题目（中等）" class="headerlink" title="题目（中等）"></a><strong>题目（中等）</strong></h2><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。</p><a id="more"></a> <p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>输入：</p><p>[2,4,3]</p><p>[5,6,4]</p><p>输出：</p><p>[7,0,8]</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>用了最直接暴力的解法，先把两个链表的各个位提出来，恢复成int类型的数，然后相加，再讲相加的和保存为String类型，通过下标遍历String各位，从而建立一个新的输出链表。</p><p>该方法最大的问题就是<strong>溢出</strong>！虽然我写的时候已经注意到会这样，不过还是尝试了一下，果然无法accept。因为<strong>两个数相加可能超出int表示范围</strong>，这时候就溢出了，尽管后面用String保存也没有什么用，显然不可取。</p><p>所以相应地我想到可以把相加的两个数用String表示，然后逐位相加，这其实就和官方解答类似了。</p><h3 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a><strong>官方解法</strong></h3><p>其实官方解法很容易想，链表是倒序从低位到高位表示的，这和做算术加法的顺序一致，先加低位，产生进位传给高位，高位继续相加，这样逐位相加，最后的结果就是所需的输出链表。</p><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1l1 和 l2l2 的表头开始相加。由于每位数字都应当处于 0 \ldots 90…9 的范围内，我们计算两个数字的和时可能会出现“溢出”。例如，5 + 7 = 125+7=12。在这种情况下，我们会将当前位的数值设置为 22，并将进位 carry = 1carry=1 带入下一次迭代。进位 carrycarry 必定是 00 或 11，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 199+9+1=19。</p><p>伪代码如下：</p><p>将当前结点初始化为返回列表的哑结点。<br>将进位 carrycarry 初始化为 00。<br>将 pp 和 qq 分别初始化为列表 l1l1 和 l2l2 的头部。<br>遍历列表 l1l1 和 l2l2 直至到达它们的尾端。<br>将 xx 设为结点 pp 的值。如果 pp 已经到达 l1l1 的末尾，则将其值设置为 00。<br>将 yy 设为结点 qq 的值。如果 qq 已经到达 l2l2 的末尾，则将其值设置为 00。<br>设定 sum = x + y + carrysum=x+y+carry。<br>更新进位的值，carry = sum / 10carry=sum/10。<br>创建一个数值为 (sum \bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。<br>同时，将 pp 和 qq 前进到下一个结点。<br>检查 carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 11 的新结点。<br>返回哑结点的下一个结点。<br>请注意，我们<strong>使用哑结点来简化代码</strong>。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</p><table><thead><tr><th>l1=[0,1] <br>l2=[0,1,2]</th><th>当一个列表比另一个列表长时.</th></tr></thead><tbody><tr><td><strong>l1=[]<br>l2=[0,1]</strong></td><td><strong>当一个列表为空时，即出现空列表。</strong></td></tr><tr><td><strong>l1=[9,9]<br>l2=[1]</strong></td><td><strong>求和运算最后可能出现额外的进位，这一点很容易被遗忘</strong></td></tr></tbody></table><p><strong>官方代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己实现的代码块：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">          ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//头结点，不存储数据，方便最后返回链表首部</span></span><br><span class="line">  ListNode curr = head;</span><br><span class="line">  <span class="keyword">int</span> carry = <span class="number">0</span>, rest = <span class="number">0</span>;</span><br><span class="line">  ListNode p = l1, q = l2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="keyword">null</span> || q!=<span class="keyword">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">int</span> v_l1 = (p!=<span class="keyword">null</span>)? p.val:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v_l2 = (q!=<span class="keyword">null</span>)? q.val:<span class="number">0</span>;</span><br><span class="line">rest = (v_l1+v_l2+carry)%<span class="number">10</span>;</span><br><span class="line">carry = (v_l1+v_l2+carry)/<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ListNode addNode = <span class="keyword">new</span> ListNode(rest);</span><br><span class="line">curr.next = addNode;</span><br><span class="line">curr = addNode;</span><br><span class="line"></span><br><span class="line">p = (p==<span class="keyword">null</span>)? <span class="keyword">null</span>:p.next;</span><br><span class="line">q = (q==<span class="keyword">null</span>)? <span class="keyword">null</span>:q.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry!=<span class="number">0</span>)  <span class="comment">//如果最高位也满10进位</span></span><br><span class="line">  &#123;</span><br><span class="line">  curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><p>时间复杂度：O(max(m,n))，假设 m 和 n 分别表示 l1和 l2的长度，上面的算法最多重复 max(m,n) 次。</p><p>空间复杂度：O(max(m,n))， 新列表的长度最多为max(m,n)+1。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目（中等）&quot;&gt;&lt;a href=&quot;#题目（中等）&quot; class=&quot;headerlink&quot; title=&quot;题目（中等）&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目（中等）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;给出两个&lt;strong&gt;非空&lt;/strong&gt;的链表用来表示两个非负的整数。其中，它们各自的位数是按照&lt;strong&gt;逆序&lt;/strong&gt;的方式存储的，并且它们的每个节点只能存储&lt;strong&gt;一位&lt;/strong&gt;数字。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="中等题型" scheme="http://yoursite.com/tags/%E4%B8%AD%E7%AD%89%E9%A2%98%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大数据——CentOS7 eclipse中的hadoop环节配置</title>
    <link href="http://yoursite.com/2018/11/15/%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94CentOS7%20eclipse%E4%B8%AD%E7%9A%84hadoop%E7%8E%AF%E8%8A%82%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/15/大数据——CentOS7 eclipse中的hadoop环节配置/</id>
    <published>2018-11-15T05:32:37.051Z</published>
    <updated>2018-11-16T15:36:50.438Z</updated>
    
    <content type="html"><![CDATA[<p>本来准备写个CentOS7下hadoop分布式集群的配置教程的，最近事情有点多，暂时搁置一下吧，先把遇到的小问题记录一下。</p><p>首先我用的是VMware虚拟机创建了三台虚拟机，都是CentOS7的，一台master（命名为hadoop1），两台slaver（命名为hadoop2和hadoop3），然后在master上配置了一些eclipse，准备跑MapReduce代码的，中间遇到了点小问题。</p><a id="more"></a><p>Eclipse版本： 4.5的Mars</p><p>Hadoop版本：2.7.3</p><p>所用教程：<a href="https://blog.csdn.net/xiaoyw71/article/details/53316390" target="_blank" rel="noopener">https://blog.csdn.net/xiaoyw71/article/details/53316390</a></p><hr><p>前面还算正常，到<strong>使用New Hadoop Location打开Hadoop Location配置窗口</strong>这一步时出错了，一直没有反应，然后打开Window -&gt; Show View -&gt; Error Log 查看错误日志，出错语句主要是两种：</p><p>Unhandled event loop exception</p><p>org.osgi.framework.BundleException: Exception in org.eclipse.equinox.internal</p><p>然后在网上一顿找，有的说应该是缺jar包，然后修改MANIFEST.MF文件的，比如这个老哥的情况：</p><p>2018-6-29 解决Eclipse使用Hadoop插件无法新建Location的问题 - 知乎</p><p><a href="https://zhuanlan.zhihu.com/p/38630695" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38630695</a></p><p>然后我下载了hadoop-eclipse-plugin-2.7.3.jar放入eclipse 安装目录下的plugins文件夹也还是解决不了，后来有人说是eclipse和hadoop-eclipse-plugin-x.x.x.jar<strong>版本不合适</strong>的，<strong>于是我把eclipse的版本改到了Neon 4.6 ，然后再重新在eclipse里面导入hadoop-eclipse-plugin-2.7.3.jar包就成功了，希望对大家有帮助。</strong></p><hr><p>三台集群配置完那天测试了一下jps指令感觉一切正常，于是就stop-all.sh关掉了，第二天重新start-all.sh发现作为namenode的hadoop1执行jps后少了resourcemanager，不过另外两个datanode执行jps是正常的，后来确认问题：</p><p><strong>namenode中的<u>yarn-site.xml</u>文件内容和datanode中的文件内容不一致</strong>，所以出现了resourcemanager启动失败的问题（似乎是启动后又关闭了），于是我把文件内容统一了一下，重新启动就正常了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">  you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License. See accompanying LICENSE file.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通知框架MR使用YARN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8033<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>192.168.211.140:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>昨天写了一个mapreduce函数一直有错误，找不到错误，今天找了一天终于解决了，原来是hadoop 的job.setOutputKeyClass和job.setOutputValueClas设置输出的问题。</p><p>job.<strong>setOutputKeyClass</strong>和job.<strong>setOutputValueClas</strong>在默认情况下是<strong>同时设置map阶段和reduce阶段的输出</strong>，也就是说只有map和reduce<strong>输出是一样的</strong>时候才不会出问题。</p><p>当map和reduce输出是不一样的时候就需要通过job.setMapOutputKeyClass和job.setMapOutputValueClas来设置map阶段的输出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来准备写个CentOS7下hadoop分布式集群的配置教程的，最近事情有点多，暂时搁置一下吧，先把遇到的小问题记录一下。&lt;/p&gt;
&lt;p&gt;首先我用的是VMware虚拟机创建了三台虚拟机，都是CentOS7的，一台master（命名为hadoop1），两台slaver（命名为hadoop2和hadoop3），然后在master上配置了一些eclipse，准备跑MapReduce代码的，中间遇到了点小问题。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="big data" scheme="http://yoursite.com/tags/big-data/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ主题模式传递消息</title>
    <link href="http://yoursite.com/2018/10/20/ActiveMQ%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/10/20/ActiveMQ主题模式传递消息/</id>
    <published>2018-10-20T11:37:22.000Z</published>
    <updated>2018-10-20T11:37:35.773Z</updated>
    
    <content type="html"><![CDATA[<p>订阅发布方式传递消息：Topic ，就类似微信公众号一样，可以多个订阅者接收一样的消息</p><p>补充：由于topic传递消息的特点是，一个生产者发送给多个消费者，生产者生产的消息在没有被消费者消费之前，并不会将消息持久化到activemq的服务端，发送的消息会自动消失。所以 测试的时候需要先创建消费者对象，然后再发送消息，防止消息丢失。</p><a id="more"></a><p><strong>生产者实现步骤：</strong></p><p>步骤和PTP的方式完全一样，不同的是在创建Destination对象的时候，需要创建topic对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">"topic-test"</span>; <span class="comment">//topic名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标（注意：此处变成了Topic）</span></span><br><span class="line">            Destination destination = session.createTopic(topicName);</span><br><span class="line">            <span class="comment">//6.创建一个生产者</span></span><br><span class="line">            MessageProducer producer = session.createProducer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">//7.创建消息</span></span><br><span class="line">                TextMessage textMessage = session.createTextMessage(<span class="string">"test"</span> + i);</span><br><span class="line">                <span class="comment">//8.发布消息</span></span><br><span class="line">                producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"发送消息"</span> + textMessage.getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9.关闭连接</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者实现的步骤：</strong></p><p>步骤和PTP消费者实现的步骤一样，唯一不同的是在创建Destination对象的时候，创建topic对象，同时要和发布订阅的生产者的topic一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicName=<span class="string">"topic-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标</span></span><br><span class="line">            Destination destination = session.createTopic(topicName);</span><br><span class="line">            <span class="comment">//6.创建一个消费者</span></span><br><span class="line">            MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line">            <span class="comment">//7.创建一个监听器</span></span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                    TextMessage textMessage = (TextMessage)message;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了）</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;订阅发布方式传递消息：Topic ，就类似微信公众号一样，可以多个订阅者接收一样的消息&lt;/p&gt;
&lt;p&gt;补充：由于topic传递消息的特点是，一个生产者发送给多个消费者，生产者生产的消息在没有被消费者消费之前，并不会将消息持久化到activemq的服务端，发送的消息会自动消失。所以 测试的时候需要先创建消费者对象，然后再发送消息，防止消息丢失。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ队列模式传递消息</title>
    <link href="http://yoursite.com/2018/10/20/ActiveMQ%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/"/>
    <id>http://yoursite.com/2018/10/20/ActiveMQ队列模式传递消息/</id>
    <published>2018-10-20T11:37:22.000Z</published>
    <updated>2018-10-20T11:37:22.954Z</updated>
    
    <content type="html"><![CDATA[<p>队列模式：点对点的方式（PTP）即：一个消息的生产者对应一个消费者，一个消息只能供一个消费者进行消费。</p><a id="more"></a><p><strong>生产者（Producer）实现步骤：</strong></p><p>第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递</p><p>第二步：通过第一步创建的工厂对象获得连接对象Connection</p><p>第三步：开启连接，直接调用connection对象的start方法即可</p><p>第四步：创建一个Session对象，通过connection对象创建</p><p>第五步：通过Session对象创建一个Destination对象（该对象有两种方式：topic和quene），这里使用quene</p><p>第六步：通过Session对象创建一个生产者Producer对象</p><p>第七步：创建Message对象，这里使用TextMessage对象，设置消息内容</p><p>第八步：使用创建的生产者对象Producer发送消息</p><p>第九步：关闭资源（Producer对象，Connection对象，Session对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>; <span class="comment">//127.0.0.1是回环地址，相当于localhost，61616是默认端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String queueName=<span class="string">"queue-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标</span></span><br><span class="line">            Destination destination = session.createQueue(queueName);</span><br><span class="line">            <span class="comment">//6.创建一个生产者</span></span><br><span class="line">            MessageProducer producer = session.createProducer(destination);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">//7.创建消息</span></span><br><span class="line">                TextMessage textMessage = session.createTextMessage(<span class="string">"test"</span> + i);</span><br><span class="line">                <span class="comment">//8.发布消息</span></span><br><span class="line">                producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"发送消息"</span> + textMessage.getText());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9.关闭连接</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者（Consumer）实现步骤：</strong></p><p>第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递</p><p>第二步：通过第一步创建的工厂对象获得连接对象Connection</p><p>第三步：开启连接，直接调用connection对象的start方法即可</p><p>第四步：创建一个Session对象，通过connection对象创建</p><p>第五步：创建一个Destination对象，使用quene，需要和生产者的quene一致</p><p>第六步：创建一个消费者对象</p><p>第七步：接收消息</p><p>第八步：打印接收的消息</p><p>第九步：关闭资源<strong>（此处关闭不要在监听后面直接关闭，因为监听是异步的，直接立刻关闭会导致监听没有结束就被关闭了，可以考虑在监听后面加入阻塞操作，让连接延迟中断）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String url = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String queueName=<span class="string">"queue-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建ConnectionFactory</span></span><br><span class="line">        ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建Connection</span></span><br><span class="line">            Connection connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//3.启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//4.创建会话</span></span><br><span class="line">            Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//5.创建一个目标</span></span><br><span class="line">            Destination destination = session.createQueue(queueName);</span><br><span class="line">            <span class="comment">//6.创建一个消费者</span></span><br><span class="line">            MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line">            <span class="comment">//7.创建一个监听器</span></span><br><span class="line">            consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                    TextMessage textMessage = (TextMessage)message;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了）</span></span><br><span class="line">            <span class="comment">//等待键盘输入,可用于阻塞连接断开操作</span></span><br><span class="line">            <span class="comment">//System.in.read();</span></span><br><span class="line">            <span class="comment">//connection.close();</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (JMSException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外消费者可以开启多个，共同消费生成者产生的消息，这样消息会被均匀分配给消费者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;队列模式：点对点的方式（PTP）即：一个消息的生产者对应一个消费者，一个消息只能供一个消费者进行消费。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——接口及其转换</title>
    <link href="http://yoursite.com/2018/10/20/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/10/20/JAVA笔记——接口及其转换/</id>
    <published>2018-10-20T07:45:56.819Z</published>
    <updated>2018-10-20T11:31:40.641Z</updated>
    
    <content type="html"><![CDATA[<p>仍然是这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.创建一个监听器</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage)message; <span class="comment">//强制转换，因为Producer发送的message已经确定是TextMessage类型的，</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>TextMessage textMessage = (TextMessage)message;这句让我感到疑惑。</p><a id="more"></a><ol><li><p><strong>TextMessage继承的Message，但是两者都是接口。怎么能直接用来生成对象呢？</strong></p><p>参考：Java接口可以有对象吗_百度知道  <a href="https://zhidao.baidu.com/question/579326704.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/579326704.html</a></p><p>其实这里相当于父类引用指向子类对象一样，就是用接口引用指向了一个实现了这个接口的对象，包括方法返回值是TextMessage也相当于是做了接口引用指向实现了这个接口的对象的转化。具体可以再看看参考。</p></li><li><p><strong>message是Message，即父接口，textMessage是TextMessage，即子接口，为啥这句代码把父类强制转换成了子类？</strong></p><p>这是因为在Producer时发送的消息就是TextMessage的（producer.send(textMessage);），这里相当于发送时把子类先转换成了父类引用，后来到这句代码又强制转换回来了，这样是没有影响的。</p><p><strong>PS：</strong>平时如果一个父类对象直接强制转换为子类一般是不允许的；反过来，若子类被强制转为父类，它的存储空间应该是没有变化的，只是属于自己子类特有的部分被锁起来了，可以用从父类继承过来的部分，如果强制转换回来可以解锁继续用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仍然是这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//7.创建一个监听器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;consumer.setMessageListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MessageListener() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message message)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TextMessage textMessage = (TextMessage)message; &lt;span class=&quot;comment&quot;&gt;//强制转换，因为Producer发送的message已经确定是TextMessage类型的，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;接受消息&quot;&lt;/span&gt;+textMessage.getText());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (JMSException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;TextMessage textMessage = (TextMessage)message;这句让我感到疑惑。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="接口" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>JAVA笔记——匿名内部类</title>
    <link href="http://yoursite.com/2018/10/20/JAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/20/JAVA笔记——匿名内部类/</id>
    <published>2018-10-20T07:04:47.239Z</published>
    <updated>2018-10-20T11:31:50.700Z</updated>
    
    <content type="html"><![CDATA[<p>今天写ActiveMQ代码时遇到一个不熟悉的东西，叫匿名内部类，于是查阅记录一下。首先代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.创建一个监听器</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage)message; <span class="comment">//强制转换，因为Producer发送的message已经确定是TextMessage类型的</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"接受消息"</span>+textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>于是我查看了一下setMessageListener方法的定义，它的参数是MessageListener：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMessageListener</span><span class="params">(MessageListener var1)</span> <span class="keyword">throws</span> JMSException</span>;</span><br></pre></td></tr></table></figure><p>然后又看了一下MessageListener的定义，发现它是个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我就懵逼了。。为什么代码里new了一个接口，查了查才知道这叫匿名内部类。</p><p>参考资料：<a href="https://zhidao.baidu.com/question/424144818620834092.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/424144818620834092.html</a></p><p>也就是说，new MessageListener()后面的大括号内相当于创建了一个类，它实现了这个MessageListener接口，所以里面实现了onMessage（）方法。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天写ActiveMQ代码时遇到一个不熟悉的东西，叫匿名内部类，于是查阅记录一下。首先代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//7.创建一个监听器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;consumer.setMessageListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MessageListener() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message message)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TextMessage textMessage = (TextMessage)message; &lt;span class=&quot;comment&quot;&gt;//强制转换，因为Producer发送的message已经确定是TextMessage类型的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;接受消息&quot;&lt;/span&gt;+textMessage.getText());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (JMSException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="匿名内部类" scheme="http://yoursite.com/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java IDE配置ActiveMQ</title>
    <link href="http://yoursite.com/2018/10/20/Java%20IDE%E9%85%8D%E7%BD%AEActiveMQ/"/>
    <id>http://yoursite.com/2018/10/20/Java IDE配置ActiveMQ/</id>
    <published>2018-10-20T02:38:22.339Z</published>
    <updated>2018-10-20T11:31:00.781Z</updated>
    
    <content type="html"><![CDATA[<p>在实际操作中，我们需要用java完成activeMQ的应用，此处我使用的IntelliJ IDEA的编译器，eclipse的还没有尝试，不过应该是类似的，此处稍微记录一下。</p><a id="more"></a><ol><li>打开IDEA，选择Maven项目，直接点击next，GroupId写com.ActiveMQ.test1，ArtifactId写的test1，当然这个不是很重要，可以自己随意写，最后Finish就行。</li><li>然后在src/main/java下添加package和class</li><li>想要使用ActiveMQ，我们还需要把jar包导入，点击左上角File——进入Project Structure——找到Libraries——添加——选择ActiveMQ根目录下的jar包(比如activemq-all-5.15.6.jar)，导入后就差不多了，如果有相关提示，处理一下就行了。</li><li>再使用ActiveMQ内的函数已经编译器已经会自动识别和提示了</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际操作中，我们需要用java完成activeMQ的应用，此处我使用的IntelliJ IDEA的编译器，eclipse的还没有尝试，不过应该是类似的，此处稍微记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之递归</title>
    <link href="http://yoursite.com/2018/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2018/10/14/数据结构之递归/</id>
    <published>2018-10-14T15:12:08.944Z</published>
    <updated>2018-10-14T15:48:50.060Z</updated>
    
    <content type="html"><![CDATA[<p>递归既会出现多次函数调用，会多占用空间也会消耗时间，空间复杂度和时间复杂度都会上升，其他基础知识不再此赘述，主要记录一下几个关键点。</p><a id="more"></a> <h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><h2 id="递归需要注意的问题"><a href="#递归需要注意的问题" class="headerlink" title="递归需要注意的问题"></a>递归需要注意的问题</h2><ol><li>递归代码要警惕堆栈溢出，因为系统栈或者虚拟机栈空间一般都不大。解决方案：可以限制递归调用的最大深度，但是这种方法不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，无法事先计算，所以当最大递归深度比较小，如10、50时，可以使用这种方法。</li><li>递归代码要警惕重复计算。比如f(n)=f(n-1)+f(n-2)，那么f(4)=f(3)+f(2)且f(5)=f(4)+f(3)，则f(3)就被重复计算了两次。此时可以通过散列表为已经求出的f(K)值建立索引K，这样当在后面的递归中用到f(K)时就不需要重复计算了，只需要map.get(n)获取相应值即可。</li><li>谨防脏数据，出现递归死循环。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;递归既会出现多次函数调用，会多占用空间也会消耗时间，空间复杂度和时间复杂度都会上升，其他基础知识不再此赘述，主要记录一下几个关键点。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之队列</title>
    <link href="http://yoursite.com/2018/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2018/10/14/数据结构之队列/</id>
    <published>2018-10-14T08:22:57.308Z</published>
    <updated>2018-10-14T15:45:34.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h2><p>就像栈有顺序栈和链式栈一样，队列也有顺序的和链式的。</p><a id="more"></a> <p>顺序队列使用head指针指向队头，使用tail指针指向队尾，初始队列的头指针和尾指针指向第0个位置，入队操作时尾指针向后移（相当于尾指针是指向队列尾元素的下一个位置的），出队操作时头指针向后移（相当于头指针是指向队列头元素的位置的），队满的判断条件为 tail == n，队空的判断条件为 head == tail。随着不停地进行入队、出队操作，head 和 tail 都会持续后移，当 tail 移动到最右边，<strong>即使数组中还有空闲空间，也无法往队列里继续添加数据了</strong>，此时可以使用<strong>数据搬移</strong>，一个解决方案就是每进行一次出队操作，就把出队前0位置后面的数据前移一位，但是这样出队操作的时间复杂度会从O(1)变成O(n)；更好的方案是不必要每次出队后都进行一次数据迁移，而是<strong>等到队列没有空闲空间时，再次需要入队时集中触发数据搬移操作即可。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作，将 item 放入队尾 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tail == n 表示队列末尾没有空间了</span></span><br><span class="line">  <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">    <span class="comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 数据搬移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">         items[i-head] = items[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搬移完之后重新更新 head 和 tail</span></span><br><span class="line">    tail -= head;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  items[tail] = item;</span><br><span class="line">  ++tail;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将head到tail之间的数据移动至0到tail-head的位置。此时均摊时间复杂度为O(1)，平均时间复杂度也为O(1)（此处存疑）。</p><p>链式队列类似，不再赘述。</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列<strong>一般都是数组形式的顺序队列</strong>，链式的叫循环链表。</p><p>循环队列队空的判断条件仍为 head == tail，队满的判断条件为(tail+1)%n == head，也正因为这样，当队列满时， tail 指向的位置实际是没有存储数据的，所以会浪费一个数组的存储空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span> &#123;</span></span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">      items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">      n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> boolean <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//出队</span></span><br><span class="line">  <span class="keyword">public</span> String dequeue &#123;</span><br><span class="line">    <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> null;</span><br><span class="line">    String ret = item[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h2><p>阻塞队列其实就是在队列基础上增加了阻塞操作。就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。其实就是一个“生产者 - 消费者模型”。</p><p>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue()上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;顺序队列和链式队列&quot;&gt;&lt;a href=&quot;#顺序队列和链式队列&quot; class=&quot;headerlink&quot; title=&quot;顺序队列和链式队列&quot;&gt;&lt;/a&gt;顺序队列和链式队列&lt;/h2&gt;&lt;p&gt;就像栈有顺序栈和链式栈一样，队列也有顺序的和链式的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
