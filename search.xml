<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2018%2F10%2F08%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目（简单）给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解决方案我的解法class Solution { public int[] twoSum(int[] nums, int target) { for(int i=0;i&lt;nums.length;++i) { int T = target - nums[i]; for(int j=i+1;j&lt;nums.length;++j) { if(nums[j] == T) return new int[]{i, j}; //不需要提前申请，直接可以返回 } } throw new IllegalArgumentException(&quot;No two sum solution&quot;); //抛出错误 } } 1.暴力解法暴力法很简单。遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。 public int[] twoSum(int[] nums, int target) { for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[j] == target - nums[i]) { return new int[] { i, j }; } } } throw new IllegalArgumentException(“No two sum solution”);} 复杂度分析 时间复杂度：O(n2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n)的时间。因此时间复杂度为 O(n2)。 空间复杂度：O(1)。 2.两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。通过以空间换取速度的方式，我们可以将查找时间从O(n)降低到O(1)。哈希表正是为此目的而构建的，它支持以近似恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是nums[i]本身！ public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { map.put(nums[i], i); } for (int i = 0; i &lt; nums.length; i++) { int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) { //containsKey方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false return new int[] { i, map.get(complement) }; } } throw new IllegalArgumentException(“No two sum solution”);} 复杂度分析 时间复杂度：O(n)，我们把包含有n个元素的列表遍历两次。由于哈希表将查找时间缩短到O(1) ，所以时间复杂度为O(n)。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 3.一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { int complement = target - nums[i]; if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i); } throw new IllegalArgumentException(“No two sum solution”);} 复杂度分析 时间复杂度：O(n)，我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费O(1)的时间。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题如何添加打赏功能]]></title>
    <url>%2F2018%2F10%2F03%2FHexo%20Next%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[最近搭建博客时想要添加个打赏功能，虽然好像一般也没人打赏= = 但是咱们是那种见钱眼开的人么？不是！所以————咱们还是添加一个吧！ 在网上查了些资料，有的方法试了发现没成功，可能因为主题不一样的原因，由于我使用的Next主题，所以先把Next主题下的添加打赏方法写出来。 基于Next主题1.准备支付宝和微信二维码&ensp;&ensp;首先得准备支付宝和微信的收款二维码（直接打开相应软件，到收款功能处保存二维码即可），然后将对应图片放在next\source\images路径下，并命名为wechatpay.jpg和alipay.jpg（文件名称随意，不过后面会用到，当然你用PNG格式也是可以的） 2.在_config.yml中添加图片路径&ensp;&ensp;注意此处_config.yml是主题配置文件，不要弄错了。打开后找到如下属性,并配置路径: **reward_comment:** 坚持原创技术分享，您的支持将鼓励我继续创作！ **wechatpay:** /images/wechatpay.jpg **alipay:** /images/alipay.jpg 3.修复闪动bug修改next/source/css/_common/components/post/post-reward.styl，注释wechat:hover和alipay:hover /* 注释文字闪动函数 #wechat:hover p{ animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear; } #alipay:hover p{ animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear; } */ 4.效果 基于其他主题其他主题的我没有尝试，此处转载一个链接，里面有关于打赏实现的方法，希望能有帮助：https://blog.csdn.net/l_201607/article/details/81097278]]></content>
      <categories>
        <category>Hexo静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构的广义定义和狭义定义]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B9%BF%E4%B9%89%E5%AE%9A%E4%B9%89%E5%92%8C%E7%8B%AD%E4%B9%89%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[最近看了关于数据结构的课程，打算重温一下数据结构的知识，正好又新搭建了个人博客，打算把学习过程中的一些知识点记录下来，方便以后温习。 广义定义指一组数据结构的存储结构。算法就是操作数据的一组方法。 狭义定义指某些著名的数据结构和算法，如队列、栈、堆、二分查找、动态规划等。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo配置文件 subtile和description内容如何换行]]></title>
    <url>%2F2018%2F10%2F01%2FHexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20subtile%E5%92%8Cdescription%E5%86%85%E5%AE%B9%E5%A6%82%E4%BD%95%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[配置Hexo个人博客时，站点配置文件_config.yml中个人信息可能需要换行，此时只需要在换行位置加上换行符即可。具体方法如下： 使用&lt;br>实现换行# Site title: JJ❤22 subtitle: description: QQ:339003672&lt;br&gt;WeChat:Zhang_junj #分行 keywords: author: JJZhang language: zh-Hans timezone: 直接在换行位置加入&lt;br>即可。]]></content>
      <categories>
        <category>Hexo静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
