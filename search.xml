<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[try-catch-finally的执行顺序[转]]]></title>
    <url>%2F2019%2F02%2F26%2Ftry-catch-finally%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[原文链接：https://www.cnblogs.com/superFish2016/p/6687549.html 在网上看到一些异常处理的面试题，试着总结一下，先看下面代码，把这个方法在main中进行调用打印返回结果，看看结果输出什么。 ;) 1234567891011121314public static int testBasic()&#123; int i = 1; try&#123; i++; System.out.println(&quot;try block, i = &quot;+i); &#125;catch(Exception e)&#123; i ++; System.out.println(&quot;catch block i = &quot;+i); &#125;finally&#123; i = 10; System.out.println(&quot;finally block i = &quot;+i); &#125; return i;&#125; ;) 没错，会按照顺序执行，先执行try内代码段，没有异常的话进入finally，最后返回，那么输出如下： try block, i = 2finally block i = 10main test i = 10 这个没有问题，如果我们把return语句放入try catch里又会怎么样呢 ;) 123456789101112131415public static int testBasic()&#123; int i = 1; try&#123; i++; System.out.println(&quot;try block, i = &quot;+i); return i; &#125;catch(Exception e)&#123; i ++; System.out.println(&quot;catch block i = &quot;+i); return i; &#125;finally&#123; i = 10; System.out.println(&quot;finally block i = &quot;+i); &#125;&#125; ;) 输出结果是： try block, i = 2finally block i = 10main test i = 2 代码顺序执行从try到finally，由于finally是无论如何都会执行的，所以try里的语句并不会直接返回。在try语句的return块中，return返回的引用变量并不是try语句外定义的引用变量i,而是系统重新定义了一个局部引用i’，这个引用指向了引用i对应的值，也就是2，即使在finally语句中把引用i指向了值10，因为return返回的引用已经不是i,而是i’,所以引用i的值和try语句中的返回值无关了。 但是，这只是一部分，如果把i换成包装类型而不是基本类型呢，来看看输出结果怎样，示例如下： ;) 123456789101112131415public static List&lt;Object&gt; testWrap()&#123; List&lt;Object&gt; list = new ArrayList&lt;&gt;(); try&#123; list.add(&quot;try&quot;); System.out.println(&quot;try block&quot;); return list; &#125;catch(Exception e)&#123; list.add(&quot;catch&quot;); System.out.println(&quot;catch block&quot;); return list; &#125;finally&#123; list.add(&quot;finally&quot;); System.out.println(&quot;finally block &quot;); &#125;&#125; ;) 打印结果如下： try blockfinally blockmain test i = [try, finally] 可以看到，finally里对list集合的操作生效了，这是为什么呢。我们知道基本类型在栈中存储，而对于非基本类型是存储在堆中的，返回的是堆中的地址，因此内容被改变了。 好了，现在我们在finally里加一个return，看看语句是从哪里返回的。 ;) 12345678910111213141516public static int testBasic()&#123; int i = 1; try&#123; i++; System.out.println(&quot;try block, i = &quot;+i); return i; &#125;catch(Exception e)&#123; i ++; System.out.println(&quot;catch block i = &quot;+i); return i; &#125;finally&#123; i = 10; System.out.println(&quot;finally block i = &quot;+i); return i; &#125;&#125; ;) 输出结果如下： try block, i = 2finally block i = 10main test i = 10 可以看到，是从finally语句块中返回的。可见，JVM是忽略了try中的return语句。但IDE中会对finally中加的return有黄色警告提示，这是为什么呢，在try里加入一行会执行异常的代码，如下： ;) 1234567891011121314151617public static int testBasic()&#123; int i = 1; try&#123; i++; int m = i / 0 ; System.out.println(&quot;try block, i = &quot;+i); return i; &#125;catch(Exception e)&#123; i ++; System.out.println(&quot;catch block i = &quot;+i); return i; &#125;finally&#123; i = 10; System.out.println(&quot;finally block i = &quot;+i); return i; &#125;&#125; ;) 打印结果如下： catch block i = 3finally block i = 10main test i = 10 可以看到，因为finally中有return语句，try、catch中的异常被消化掉了，屏蔽了异常的发生，这与初期使用try、catch的初衷是相违背的，因此编译器也会提示警告。 那如果在finally中有异常发生，会对try、catch中的异常有什么影响呢？ ;) 1234567891011121314151617public static int testBasic()&#123; int i = 1; try&#123; i++; Integer.parseInt(null); System.out.println(&quot;try block, i = &quot;+i); return i; &#125;catch(Exception e)&#123; String.valueOf(null); System.out.println(&quot;catch block i = &quot;+i); return i; &#125;finally&#123; i = 10; int m = i / 0; System.out.println(&quot;finally block i = &quot;+i); &#125;&#125; ;) 这里我们在try、catch里强行加上异常语句，打印结果如下： Exception in thread “main” java.lang.ArithmeticException: / by zeroat tryandcatch.TryAndCatch.testBasic(TryAndCatch.java:25)at tryandcatch.TryAndCatch.main(TryAndCatch.java:45) 这个提示表示的是finally里的异常信息，也就是说一旦finally里发生异常，try、catch里的异常信息即被消化掉了，也达不到异常信息处理的目的。 总结以上测试： 1、finally语句总会执行 2、如果try、catch中有return语句，finally中没有return，那么在finally中修改除包装类型和静态变量、全局变量以外的数据都不会对try、catch中返回的变量有任何的影响（包装类型、静态变量会改变、全局变量） 3、尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生 4、finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略 所以在实际项目中，finally常常是用来关闭流或者数据库资源的，并不额外做其他操作。 另外如果在一个catch块中出现的异常，不会在后面的catch块被捕捉，而是会向上抛出]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode————不用加减乘除做加法]]></title>
    <url>%2F2019%2F02%2F11%2FLeetCode%E2%80%94%E2%80%94%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解法一：投机取巧，用 += 运算符 解法二：用异或(^)表示加法，按位与(&amp;)表示进位，当进位为0时表示得到最后结果 例如： 5+7=12，三步走 第一步：相加各位的值，不算进位，得到2。 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 12345678910public class Solution &#123; public int Add(int num1,int num2) &#123; while(num2 != 0) &#123; //只有进位为0才能停止 int temp = num1 ^ num2; //求异或，得到无进位的和 num2 = (num1 &amp; num2) &lt;&lt; 1; //左移位，表示进位 num1 = temp; &#125; return num1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>简单题型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈HTTP协议中的短轮询、长轮询、长连接和短连接[转]]]></title>
    <url>%2F2019%2F02%2F03%2F%E8%B0%88%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%5B%E8%BD%AC%5D%2F</url>
    <content type="text"><![CDATA[引言 最近刚到公司不到一个月，正处于熟悉项目和源码的阶段，因此最近经常会看一些源码。在研究一个项目的时候，源码里面用到了HTTP的长轮询。由于之前没太接触过，因此LZ便趁着这个机会，好好了解了一下HTTP的长长短短。 了解的方式主要都是LZ在网络上获取的，这里只是谈一下LZ对于这四种叫法最直观的理解。如果你之前不懂的话，可以帮你普及一下，如果你之前就懂得话，可以互相对照一下。 以前的误解很久之前LZ就听说过长连接的说法，而且还知道HTTP1.0协议不支持长连接，从HTTP1.1协议以后，连接默认都是长连接。但LZ终究觉得对于长连接一直懵懵懂懂的，有种抓不到关键点的感觉。 今天LZ通过一番研究，终于明白了这其中的奥秘。而之前，LZ也看过长连接相关的内容，但一直都是云里雾里的。这次之所以能在这么短的时间里搞清楚，和LZ自己技术的沉淀密不可分。因此，这里LZ借着这个机会，再次强调一下，千万不要试图去研究你研究了很久都整不明白的东西，或许是你的层次不到，也或许是你从未在实际的应用场景接触过，这种情况下你去研究，只会事倍功半，徒劳一番罢了。 回到正题，既然说是误解，那么LZ的误解到底是什么？ 那就是LZ一直认为，HTTP连接分为长连接和短连接，而我们现在常用的都是HTTP1.1，因此我们用的都是长连接。 这句话其实只对了一半，我们现如今的HTTP协议，大部分都是1.1的，因此我们平时用的基本上都是长连接。但是前半句是不对的，HTTP协议根本没有长短连接这一说，也正因为误解了这个，导致LZ对于长连接一直不明不白，始终不得其要领，具体下面一段会说到。 网络上很多文章都是误人子弟，根本没有说明白这个概念。这里LZ要强调一下，HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了，或者更准确的说，是本次HTTP请求就结束了，根本没有长连接这一说。那么自然也就没有短连接这一说了。 之所以网络上说HTTP分为长连接和短连接，其实本质上是说的TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。 其实知道了以后，会觉得这很好理解。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。 一个形象的例子就是，拿你在网上购物来说，HTTP协议是指的那个快递单，你寄件的时候填的单子就像是发了一个HTTP请求，等货物运到地方了，快递员会根据你发的请求把货物送给相应的收货人。而TCP协议就是中间运货的那个大货车，也可能是火车或者飞机，但不管是什么，它是负责运输的，因此必须要有路，不管是地上还是天上。那么这个路就是所谓的TCP连接，也就是一个双向的数据通道。 因此，LZ现在甚至觉得，“HTTP连接”这个词就不应该出现，它只是一个应用层的协议，根本就没有所谓的连接这一说，就像FTP也是应用层的协议，但是你有听说过FTP连接吗？（恩，好像是听过，-_-，但你现在知道了，其实所谓的FTP连接，严格来说，依旧是TCP连接） 实际上，说HTTP请求和HTTP响应会更准确一些，而HTTP请求和HTTP响应，都是通过TCP连接这个通道来回传输的。 不管怎么说，一定要务必记住，长连接是指的TCP连接，而不是HTTP连接。 一个疑问之前LZ一直对一件事有些模糊不清，首先是怎么样就算是把HTTP变成长连接了，是不是只要设置Connection为keep-alive就算是了？ 如果是的话，那都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接，但是长连接不是一般用于交互比较频繁的应用吗？像我们这种普通的Web应用，比如博客园这种，或者我的个人博客这种，长连接有什么用？ 如果有用那用处到底是什么，我们又不是客户端与服务器交互频繁的那种应用（毕竟你打开网页肯定要半天才打开另外一个吧），如果没用的话，那到底应不应该把Connection为keep-alive这个header值给改掉，从而改成短连接？ 这个疑问，在LZ明白了长连接其实是指的TCP连接之后，基本上就明白了。而这个疑问，也正是LZ在“以前的误解”那一段所提到的，那个因为误解导致LZ一直搞不明白的问题。 为什么解决了上面那个误解之后，前面所说的这些疑问LZ都明白了？ 因为长连接意味着连接会被复用，毕竟一直保持着连接不就是为了重复使用嘛。但如果长连接是指的HTTP的话，那就是说HTTP连接可以被重复利用，这个话听起来就感觉很别扭。之所以觉得别扭，其实就是LZ的一种直觉，没什么理论依据。而这种别扭的根源就在于，之前一直没有融会贯通的感觉，所以总感觉缺少点什么。不过这点疑惑，并没有影响LZ的工作，因此也就没深究过。 但现在好了，明白了长连接实际上是指的TCP连接，LZ瞬间自己就想明白了上面的那些问题。 第一个问题是，是不是只要设置Connection为keep-alive就算是长连接了？ 当然是的，但要服务器和客户端都设置。 第二个问题是，我们平时用的是不是长连接？ 这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive） 第三个问题，也是LZ之前最想不明白的问题，那就是我们这种普通的Web应用（比如博客园，我的个人博客这种）用长连接有啥好处？需不需要关掉长连接而使用短连接？ 这个问题LZ现在终于明白了，问题的答案是好处还是有的。 好处是什么？ 首先，刚才已经说了，长连接是为了复用，这个在之前LZ就明白。那既然长连接是指的TCP连接，也就是说复用的是TCP连接。那这就很好解释了，也就是说，长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。 比如你请求了博客园的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源就不用LZ去说了吧。 但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。 这样一解释，就很明白了，不知道大家看了这些解释感觉如何，反正LZ在自己想明白以后，有种豁然开朗的感觉。 另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。 这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？ 长轮询和短轮询前面基本上LZ已经把长短连接说的差不多了，接下来说说长短轮询，今天也正是为了研究长短轮询，LZ才顺便研究了下长短连接这回事。 短轮询相信大家都不难理解，比如你现在要做一个电商中商品详情的页面，这个详情界面中有一个字段是库存量（相信这个大家都不陌生，随便打开淘宝或者京东都能找到这种页面）。而这个库存量需要实时的变化，保持和服务器里实际的库存一致。 这个时候，你会怎么做？ 最简单的一种方式，就是你用JS写个死循环，不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。 这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。 那怎么办呢？ 长轮询这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。 而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。 这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。 但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。 因此，从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。之所以举这个例子，只是因为大家肯定都会网购，所以这个例子比较通俗一点。 哪怕轮询解决不了获取库存这个问题，但只要大家明白了长短轮询的区别，这就足够了。实际上，据LZ自己平日里购物的观察，那个库存量应该是不会变的，这个例子纯属LZ个人的意淫，-_-。 长短轮询和长短连接的区别这里简单说一下它们的区别，LZ这里只说最根本的区别。 第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。 第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。 结语好了，本文就到此为止吧。LZ写这篇文章，主要也是为了避免自己遗忘。说实话，写到最后了，LZ感觉对于它们的理解又进了一步，这就是写博客的好处吧。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记——父子类的加载执行顺序]]></title>
    <url>%2F2019%2F02%2F03%2FJAVA%E7%AC%94%E8%AE%B0%E2%80%94%E7%88%B6%E5%AD%90%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[类的加载顺序 （1）父类静态代码块（包括静态初始化块，静态属性，但不包括静态方法） （2）子类静态代码块（包括静态初始化块，静态属性，但不包括静态方法） （3）父类非静态代码块（包括非静态初始化块，非静态属性） （4）父类构造函数 （5）子类非静态代码块（包括非静态初始化块，非静态属性） （6）子类构造函数 类的执行顺序 （1）父类静态变量和静态代码块（先声明的先执行） （2）子类静态变量和静态代码块（先声明的先执行） （3）父类的非静态属性（变量）和非静态代码块（先声明的先执行） （4）父类构造函数 （5）子类的非静态属性（变量）和非静态代码块（先声明的先执行） （6）子类构造函数]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记——JVM内存区域划分[转载]]]></title>
    <url>%2F2019%2F01%2F29%2FJAVA%E7%AC%94%E8%AE%B0%E2%80%94JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%5B%E8%BD%AC%5D%2F</url>
    <content type="text"><![CDATA[今天看到一个JVM的比较有意思的帖子，比较形象生动，此处记录一下。 JVM内存区域划分Eden Space、Survivor Space、Tenured Gen，Perm Gen解释 - kaixinmao1987 - 博客园https://www.cnblogs.com/kxm87/p/7205414.html [译]GC专家系列1：理解Java垃圾回收 - 牧曦之晨 - SegmentFault 思否https://segmentfault.com/a/1190000004233812 jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。 HotSpot虚拟机GC算法采用分代收集算法： 1、一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。 2、并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。 3、进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。 分区的目的：新生区由于对象产生的比较多并且大都是朝生夕灭的，所以直接采用标记-清理算法。而养老区生命力很强，则采用复制算法，针对不同情况使用不同算法。 非heap区域中Perm Gen中放着类、方法的定义，jvm Stack区域放着方法参数、局域变量等的引用，方法执行顺序按照栈的先入后出方式。 以上转自：http://lhc1986.iteye.com/blog/1421832 以下转自：http://www.cnblogs.com/xhr8334/archive/2011/12/01/2270994.html JVM在程序运行过程当中，会创建大量的对象，这些对象，大部分是短周期的对象，小部分是长周期的对象，对于短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉，对于长周期对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测。为解决这种矛盾，Sun JVM的内存管理采用分代的策略。 ​ 1）年轻代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）。当对象在堆创建时，将进入年轻代的Eden Space。垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制到Old Gen。同时，在扫描Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个持久化对象，则将其移到Old Gen。扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色（即下次垃圾回收时会扫描Eden Space和BSuvivor Space。这么做主要是为了减少内存碎片的产生。 ​ 我们可以看到：Young Gen垃圾回收时，采用将存活对象复制到到空的Suvivor Space的方式来确保尽量不存在内存碎片，采用空间换时间的方式来加速内存中不再被持有的对象尽快能够得到回收。​ 2）年老代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。​ 3）持久代(Perm Gen)：持久代主要存放类定义、字节码和常量等很少会变更的信息。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记——String中的intern()方法[转载]]]></title>
    <url>%2F2019%2F01%2F25%2FJAVA%E7%AC%94%E8%AE%B0%E2%80%94String%E4%B8%AD%E7%9A%84intern()%E6%96%B9%E6%B3%95%5B%E8%BD%AC%5D%2F</url>
    <content type="text"><![CDATA[文章是转载的网上一篇博客，感觉写的比较清楚 对String中intern()方法的认识 - 董_不懂的博客 - CSDN博客https://blog.csdn.net/believesoul/article/details/79588305 最近在看字符串相关知识的时候，又看到了关于字符串创建方式和是否相等的相关问题，回忆起之前碰到的一个String中的intern()方法，它是一个本地方法（由Java语言外的语言编写），因此在jdk1.8源码中没有其实现，不过有一段描述，讲述了它的作用。intern()方法的描述 123456789101112131415161718192021222324/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class &#123;@code String&#125;. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this &#123;@code String&#125; object as determined by * the &#123;@link #equals(Object)&#125; method, then the string from the pool is * returned. Otherwise, this &#123;@code String&#125; object is added to the * pool and a reference to this &#123;@code String&#125; object is returned. * &lt;p&gt; * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;, * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125; * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java™ Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */ public native String intern(); 归纳一下的话，它的作用在jdk1.7之后是查看常量池中是否存在和调用方法的字符串内容一样的字符串，如果有的话，就返回该常量池中的字符串，若没有的话，就在常量池中写入一个堆中该字符串对象的一个引用，指向堆中的该对象，并返回该引用。用代码说话吧，注释中有我对intern()方法的理解，过程中查阅了部分源码和相关博客，如果有谬误，请大家指出，互相交流学习，共同进步。 intern方法的测试 12345678910111213141516171819202122232425262728293031323334353637public class InternTest &#123; public static void main(String[] args) &#123; String a = new String("abc"); // 第一次，创建了两个对象，一个是堆中的string对象，一个是常量池中的"abc" String b = new String("abc"); // 第二次，创建一个对象，堆中的另外一个string对象 System.out.println(a.intern() == b.intern());// true System.out.println(a.intern() == b);// false System.out.println(a.intern() == a);// false /* * intern方法会到常量池中查找是否存在该对象，如果存在，返回该对象。不存在的话就创建该对象并返回该对象(jdk1.6),(jdk1.7) * 会在常量池中存一个指向堆中的那个对象的引用。 不存在往往是String s3 = new String("1") + new * String("1");这种形式，会在堆中有一个s3指向的11的对象和常量池中的1对象 * 在这里就是体现的堆中的内存地址不一样，但对应的同一个常量池中的string 第一个比较时常量池中的该对象和自身比较 * 下面两个比较则是常量池中的对象和堆中的两个对象进行比较 */ String poolstr = "abc"; // 直接从字符串常量池中获取 System.out.println(a.intern() == poolstr);// true System.out.println(b.intern() == poolstr);// true /* * 这里新声明并赋值了一个poolstr，值为常量池中的字符串"abc",将它和a.intern()和b.inten()比较就是和自身比较 */ String str = new String("a") + new String("b"); System.out.println(str.intern() == str);// true /* * str创建了3个对象，在堆中有一个"ab"，在常量池中有一个"a"和"b" 比较str.intern()和str会得到true * 在jdk1.7之后，会在常量池中存一个指向堆中的那个对象的引用。 * 调用str.intern()会在常量池中存储一个指向堆中"ab"的引用，也就是说它和堆中的对象实际是等价的，因此==时返回true */ String strtwo = "ab"; System.out.println(strtwo == str);// true /* * 常量池中已存在ab，所以会直接将strtwo指向常量池中的"ab",即堆中str对象的引用，因此相等 */ &#125;&#125; 其中有提到一个new String（“”）会创建几个对象，一般就是一个或两个，主要是看常量池中是否已经有了该字符串，在上述代码在也有所提及。对于每一个比较语句我都做了自己的理解的标注，比较通俗易懂，仔细看一下就能理解intern方法的作用，另外附上一篇博文，是一篇讲述intern方法的实现原理的博文，对我理解intern方法有很大帮助，感兴趣的朋友可以看一下。Java技术——你真的了解String类的intern()方法吗其中提到了jdk1.7将常量池从方法区中转移到堆中对intern()方法的影响，非常清晰的描述了差别，配合本博文实例更适宜使用，本博文更多的从实现角度来解析intern()方法，希望对您有所帮助如有谬误，敬请指正。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>常量池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ在windows配置安装]]></title>
    <url>%2F2019%2F01%2F11%2FRocketMQ%E5%9C%A8windows%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[配置过程不麻烦，就是有点小插曲 教程参考： https://yq.aliyun.com/articles/656078 ​ https://www.jianshu.com/p/4a275e779afa 注意：过程中需要对JVM configuration 修改一下 内存 ： 修改runserver.sh和runbroker.sh，两个分别对应nameserver和broker的配置： 1JAVA_OPT="$&#123;JAVA_OPT&#125; -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m" 1set "JAVA_OPT=%JAVA_OPT% -server -Xms2g -Xmx2g -Xmn1g" 另外 如果启动broker出现找不到XXXXX主类的错误，把 %CLASSPATH% 加上双引号，修改为 “%CLASSPATH%” 就可以了 https://blog.csdn.net/lvwenzhuye/article/details/81483479]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据——hashMap put函数 重复插入相同(key,value)的问题]]></title>
    <url>%2F2018%2F12%2F28%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94hashMap%E7%9A%84put%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718try&#123; writer = SequenceFile.createWriter(fs, conf, path, key.getClass(), value.getClass()); for(File dir:dirs)&#123; File[] files = dir.listFiles(); for(File file:files)&#123; //key：目录名+":"+文件名 key.set(dir.getName() + ":" + file.getName()); //value：文件内容 value.set(fileToString(file)); fileContents.put(key, value); //////////////////////////A fileContents.put(new Text(dir.getName() + ":" + file.getName()), new Text(fileToString(file))); /////////////////////////////B writer.append(key, value); //System.out.println(key + "\t" + value); &#125; &#125; &#125;finally&#123; IOUtils.closeStream(writer); &#125; 今天做基于hadoop的朴素贝叶斯文档分类时，遇到一个问题：注意代码块中的A和B，最开始使用A时我发现hashMap内存储的都是同一个(key，value)对，改成B就可以了，目测应该是key和value对数据引用后，修改key和value导致hash值变化了。 具体类比资料：hashmap出现重复key的情况 - qq_29909965的博客 - CSDN博客https://blog.csdn.net/qq_29909965/article/details/78358066]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记——类的访问权限]]></title>
    <url>%2F2018%2F12%2F17%2FJAVA%E7%AC%94%E8%AE%B0%E2%80%94%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[如果一个类的成员没有任何权限修饰，那么它门就是缺省包访问权限，用friendly来表示，注意friendly不是Java中的关键字，这里是个人喜欢的方式用它表示而已。同一个包内其它类可以访问，但包外就不可以。对于同一个文件夹下的、没有用package的classes，Java会自动将这些classes初见为隶属于该目录的default package，可以相互调用class中的friendly成员。 如以下两个class分别在同一个文件夹的两个文件中，虽然没有引入package，但隶属于相同的default package。 1234567891011class Sundae&#123; //以下两个方法缺省为friendly Sundae()&#123;&#125; Void f() &#123;System.out.println(“Sundae.f()”);&#125;public class IceCream&#123; public static void main(String[] args)&#123; Sundae x = new Sundae(); x.f(); &#125;&#125; 对于类来说：同一个包中的类可以用。总之，类只可以声明为public或者friendly。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode————9.回文数]]></title>
    <url>%2F2018%2F12%2F16%2FLeetCode%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目（简单）判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 解决方案方法：反转一半数字思路 映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。 第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。 但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。 按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。 例如，输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。 让我们看看如何将这个想法转化为一个算法。 算法 首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。 现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以10的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。 如果继续这个过程，我们将得到更多位数的反转数字。 现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？ 我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。 1234567891011121314151617181920212223public class Solution &#123; public bool IsPalindrome(int x) &#123; // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while(x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber/10; &#125;&#125; 复杂度分析 时间复杂度：O(log10(n)， 对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(log10(n)。 空间复杂度：O(1)。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>简单题型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode————7.整数反转]]></title>
    <url>%2F2018%2F12%2F07%2FLeetCode%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目（简单）给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 题目很明确，很自然的想法就是通过除法和取余逐位取出，再依次乘10加余数达到反向效果，但是也有一点就是做乘法时可能会出现溢出的情况。 解决方案反转整数的方法可以与反转字符串进行类比。 我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。 要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。 1234567//pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp; 但是，这种方法很危险，因为当 temp=rev⋅10+pop 时会导致溢出。 幸运的是，事先检查这个语句是否会导致溢出很容易。 为了便于解释，我们假设 rev 是正数。 这里要补充两点： 1.显然因为top只能是处于0~9的个位数字，所以若rev·10+top溢出，那么rev&gt;=INTMAX/10必然成立。 2.若rev==INTMAX/10，若pop&gt;7(假设为8)，那么反转前肯定是8xxxxxxxx，显然超出了Int的范围，所以top&lt;=7一定成立的。 当 rev 为负时可以应用类似的逻辑。 123456789101112131415161718192021class Solution &#123; public int reverse(int x) &#123; int X =x; if(x==0) return 0; if(x&lt;0) X = -x; int rev=0; while(X&gt;0) &#123; int end = X%10; X = X/10; if(rev&gt;214748364) return 0; rev = rev*10+end; &#125; if(x&lt;0) rev = -rev; return rev; &#125;&#125; 优化一下： 12345678910111213class Solution &#123; public int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; if (rev &gt; Integer.MAX_VALUE/10 ) return 0; if (rev &lt; Integer.MIN_VALUE/10 ) return 0; rev = rev * 10 + pop; &#125; return rev; &#125;&#125; 时间复杂度：O(log10(n))，因为每次都通过除以10取出尾数位。 空间复杂度：O(1)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>简单题型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode————5.最长回文子串(常考)]]></title>
    <url>%2F2018%2F12%2F06%2FLeetCode%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目（中等）给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解决方案1.最大公共子串法第一个比较容易的想法可能就是 把字符串S反转过来，记为S’，先使用动态规划方法找到S与S’之间的最长公共子串，即所求的最长回文子串。 例如，S = “caba” , S’ = “abac”, S 以及 S’ 之间的最长公共子串为 “aba”，恰恰是答案。 让我们尝试一下这个例子：S = “abacdfgdcaba” , S’ = “abacdgfdcaba”, S 以及 S’之间的最长公共子串为 “abacd”，显然，这不是回文。 我们可以看到，当 S 的其他部分中存在非回文子串的反向副本时(即例子中的abacd和dcaba)，最长公共子串法就会失败。为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要检查子串的索引是否与反向子串的原始索引相同。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。 这里要解释一下上面加粗的那句，即判断条件，比如”caba”这个串，反转找到的最长公共子串是”aba”，它在”caba“的结束索引为3（不是1是因为最长公共子串找到的索引是结束索引）；在反向串”abac”中的结束索引为2，我们要找的原始索引就是在反向串中的反向索引，即”aba”的开始索引（串长 4-1-结束索引2=4-1-2=1）加上该最大公共子串长度3再减1（即1+3-1=3）因为反向索引3和原串的索引3相等，所以认定这是个回文串，而不是反向副本；再比如”abacdfgdcaba”，找到的公共子串”abacd”的结束索引为4，开始索引=12-1-4=7，又因为最大公共子串长为5，所以反向串中的原始索引就为7+5-1=11，这与原串的结束索引4不等，所以这是个反向副本，而不是回文数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public String longestPalindrome(String s) &#123; if(s.equals("")) return ""; String s1 = s; String s2 = new StringBuilder(s).reverse().toString(); String str=""; int l1 = s1.length(); int l2 = s2.length(); int max_index1[] = new int[s.length()]; int max_index2[] = new int[s.length()]; int max_len = 0; int array[][] = new int[l1][l2]; for(int t=0;t&lt;s.length();++t) &#123; max_index1[t] = -1; max_index2[t] = -1; &#125; for(int i=0;i&lt;l1;++i) for(int j=0;j&lt;l2;++j) &#123; if(s1.charAt(i) == s2.charAt(j)) &#123; if(i==0 || j==0) &#123; array[i][j] = 1; &#125; else array[i][j] = array[i-1][j-1]+1; if(array[i][j] &gt; max_len) &#123; int r_index2 = s.length()-j-1; //判断是否是回文而不是反向副本 if(i == r_index2+array[i][j]-1) //判断是否是回文而不是反向副本 &#123; max_len = array[i][j]; max_index1[0] = i; max_index2[0] = j; for(int t=1;t&lt;s.length();++t) &#123; max_index1[t] = -1; max_index2[t] = -1; &#125; &#125; &#125; &#125; else array[i][j] = 0; &#125; if(max_index1[0]&gt;=0) str = (s1.substring(max_index1[0]-max_len+1,max_index1[0]+1)); System.out.print(str); return str; &#125;&#125; 时间复杂度：因为是动态规划，所以是O(n2)。 空间复杂度：因为用了空间换时间，所以是O(n2)。其实还可以通过把Array二维数组转换为一维，因为每次循环都是固定i，内部循环j，而第3行的数据其实只用到之前第2行的数据，不需要第1行的，所以每次用一维数组重复利用，做数据更新就可以了。这样空间复杂度就缩小到了O(n)。 2.暴力法很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。但是暴力法面对比如”zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz”这样的超长回文串，就会因为时间开销太大而超时。 123456789101112131415161718192021222324252627class Solution &#123; public String longestPalindrome(String s) &#123; int max_len = 0; int max_index = -1; String str = ""; for(int i=0;i&lt;s.length();++i) for(int j=i;j&lt;s.length();++j) &#123; int start = i,end = j; while(s.charAt(start) == s.charAt(end)) &#123; start++; end--; if(end&lt;0 || start&gt;s.length()-1) break; &#125; if(start &gt;= end &amp;&amp; j-i+1 &gt; max_len) &#123; max_len = j-i+1; max_index = j; str = s.substring(i,j+1); &#125; &#125; System.out.println(str); return str; &#125;&#125; 时间复杂度：O(n3)，因为要进行NN的循环，每次循环还要遍历根据初始位置start和结束位置end找出的子串判断是否是回文串，所以为N N * N。 空间复杂度：O(1) 3.动态规划法为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，“ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。 我们给出 P(i,j) 的定义如下： 基本示例如下： P(i, i) = true P(i, i+1) = (Si==Si+1) 这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推… 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public String longestPalindrome(String s) &#123; int len[]=new int[s.length()]; //记录是否为回文串，不是就记为0，是的就记录回文串长度 int max_len=0; int max_index=0; String str=""; for(int i=s.length()-1;i&gt;=0;--i) for(int j=s.length()-1;j&gt;=i;--j) &#123; if(s.charAt(i) == s.charAt(j)) &#123; if(i == j) //边界（奇数） len[j] = 1; else if(Math.abs(i-j)==1) //边界（偶数） &#123; len[j] = 2; &#125; else &#123; len[j] = len[j-1]==0? 0:len[j-1]+2; //判断内部子串是不是回文串，不是为false，是的就记录回文串长度 &#125; &#125; else len[j] = 0; //不是回文串 if(len[j]&gt;max_len) &#123; max_len = len[j]; max_index = j; str = s.substring(i,j+1); &#125; &#125; System.out.println(str); return str; &#125;&#125; 时间复杂度：O(n2) 空间复杂度：正常情况下是O(n2)， 因为动态规划方法使用 O(n2)的空间来存储表。同样的，这个空间复杂度可以优化到O(n)，空间复杂度：O(n^2)O(n2)， 该方法使用 O(n^2)O(n2) 的空间来存储表。 4.中心扩展法事实上，只需使用恒定的空间，我们就可以在 O(n2) 的时间内解决这个问题。 我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n−1 个这样的中心。 你可能会问，为什么会是 2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个 ‘b’ 之间）。所以找奇数长度的回文串时可以遍历n个中心（也就是n个字符均作为一次中心），找偶数长度回文串时可以遍历n-1个中心（也就是n个字符之间的空隙均作为一次中心），加起来就是n+n-1=2n-1。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String longestPalindrome(String s) &#123; if(s.equals("")) return ""; int max_len=0,length=0; int start=-1,end=-1; String str=""; for(int i=0;i&lt;s.length();++i) &#123; int len1 = expandAroundCenter(s,i,i); int len2 = expandAroundCenter(s,i,i+1); length = (len1&gt;len2)?len1:len2; if(length&gt;max_len) &#123; max_len = length; start = i-((length+1)/2-1); end = start+length-1; &#125; &#125; str = s.substring(start,end+1); System.out.println(str); return str; &#125; public static int expandAroundCenter(String s,int left,int right) //从left/right的中心开始扩展 &#123; int L=left,R=right; while(L&gt;=0 &amp;&amp; R&lt;=s.length()-1 &amp;&amp; s.charAt(L)==s.charAt(R)) &#123; L--; R++; &#125; return R-L-1; &#125;&#125; 时间复杂度：O(n2)， 由于围绕中心来扩展回文会耗去 O(n) 的时间，所以总的复杂度为 O(n2)。 空间复杂度：O(1)。 5.Manacher 马拉车算法这个算法比较复杂，可以把时间复杂度和空闲复杂度都缩减到O(n)，建议多查看一些资料，此处不做叙述。 参考资料：Longest Palindromic Substring Part II – LeetCode https://articles.leetcode.com/longest-palindromic-substring-part-ii/]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>中等题型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据————淘宝双十一项目实战]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94%E6%B7%98%E5%AE%9D%E5%8F%8C%E5%8D%81%E4%B8%80%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[今天完成了一个基于淘宝双十一交易数据的大数据分析实战项目，这里稍作记录。 教程：淘宝双11数据分析与预测课程案例：厦大数据库实验室博客 http://dblab.xmu.edu.cn/blog/1362-2/ 项目和文档：https://github.com/JayZeed/taobao11]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>big data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据————Ubuntu14.04 Echarts图例设置后不显示]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20Echarts%E5%9B%BE%E4%BE%8B%E8%AE%BE%E7%BD%AE%E5%90%8E%E4%B8%8D%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[Echarts是用于前端数据可视化的一个工具。可以把数据以各种图表方式显示出来。 最近做一个大数据项目时，通过Echarts做了一个柱状图，但是设置了的图例一直不能显示出来。 1234legend: &#123; x: 'center', data:['销量'] &#125;, 红框内就是图例： 查了一些资料才知道原来需要series中的name和legend的data一致，这样才能显示。 123456789101112legend: &#123; x: 'center', data:['销量']&#125;,series : [ &#123; name:'销量', type:'bar', barWidth: '60%', data:y &#125;] 如果想设置图例颜色，可以在option里设置 color : […] 实现。 参考资料：echarts柱状图图例不显示的问题 - royal1235的博客 - CSDN博客https://blog.csdn.net/royal1235/article/details/80746278]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>big data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据————Ubuntu14.04 JavaScript array保存object对象出错]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20JavaScript%20array%E4%BF%9D%E5%AD%98object%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[用JSP开发WEB应用时用到了javascript语言，其中想在数组保存object对象时出了点小问题。 123456var mydata=[];...var obj =new Object();obj.name = &lt;%=a[0]%&gt;;...mydata.push(obj); 这里我想将obj用数组存起来，发现存储失败了，控制台调试发现报错：ReferenceError: 台湾 is not defined （这里台湾是&lt;%=a[0]%&gt;得到的值）大概意思是把台湾作为变量了，而不是一个值。 因为&lt;%=a[0]%&gt;表示取得a[0]的值，那么 obj.name = &lt;%=a[0]%&gt;; 就相当于 obj.name = 台湾; 确实会被理解成变量名，而我们需要的应该是 obj.name = “台湾” ; 所以只需要改成 obj.name = “&lt;%=a[0]%&gt;”; 即可。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>big data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据——Ubuntu14.04 使用Sqoop将数据从Hive导入MySQL出错]]></title>
    <url>%2F2018%2F11%2F29%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%20%E4%BD%BF%E7%94%A8Sqoop%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8EHive%E5%AF%BC%E5%85%A5Mysql%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[在基于大数据双十一用户行为统计与分析实验中 进行导入数据操作时： (4)导入数据(执行时间：20秒左右)注意，刚才已经退出MySQL，回到了Shell命令提示符状态。下面就可以执行数据导入操作 12cd /usr/local/sqoopbin/sqoop export --connect jdbc:mysql://localhost:3306/dbtaobao --username root --password root --table user_log --export-dir '/user/hive/warehouse/dbtaobao.db/inner_user_log' --fields-terminated-by ','; 执行错误提示如下： 18/11/29 05:20:45 ERROR manager.SqlManager: Error executing statement: java.sql.SQLException: Access denied for user ‘root‘@’localhost’ (using password: YES)java.sql.SQLException: Access denied for user ‘root‘@’localhost’ (using password: YES)​ at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:965)​ at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3978)​ at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3914)​ at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:871)​ at com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1714)​ at com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1224)​ at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2199)​ at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2230)​ at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2025)​ at com.mysql.jdbc.ConnectionImpl.(ConnectionImpl.java:778)​ at com.mysql.jdbc.JDBC4Connection.(JDBC4Connection.java:47)​ at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)​ at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)​ at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)​ at java.lang.reflect.Constructor.newInstance(Constructor.java:526)​ at com.mysql.jdbc.Util.handleNewInstance(Util.java:425)​ at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:386)​ at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:330)​ at java.sql.DriverManager.getConnection(DriverManager.java:571)​ at java.sql.DriverManager.getConnection(DriverManager.java:215)​ at org.apache.sqoop.manager.SqlManager.makeConnection(SqlManager.java:904)​ at org.apache.sqoop.manager.GenericJdbcManager.getConnection(GenericJdbcManager.java:59)​ at org.apache.sqoop.manager.SqlManager.execute(SqlManager.java:763)​ at org.apache.sqoop.manager.SqlManager.execute(SqlManager.java:786)​ at org.apache.sqoop.manager.SqlManager.getColumnInfoForRawQuery(SqlManager.java:289)​ at org.apache.sqoop.manager.SqlManager.getColumnTypesForRawQuery(SqlManager.java:260)​ at org.apache.sqoop.manager.SqlManager.getColumnTypes(SqlManager.java:246)​ at org.apache.sqoop.manager.ConnManager.getColumnTypes(ConnManager.java:327)​ at org.apache.sqoop.orm.ClassWriter.getColumnTypes(ClassWriter.java:1872)​ at org.apache.sqoop.orm.ClassWriter.generate(ClassWriter.java:1671)​ at org.apache.sqoop.tool.CodeGenTool.generateORM(CodeGenTool.java:106)​ at org.apache.sqoop.tool.ExportTool.exportTable(ExportTool.java:63)​ at org.apache.sqoop.tool.ExportTool.run(ExportTool.java:99)​ at org.apache.sqoop.Sqoop.run(Sqoop.java:147)​ at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:70)​ at org.apache.sqoop.Sqoop.runSqoop(Sqoop.java:183)​ at org.apache.sqoop.Sqoop.runTool(Sqoop.java:234)​ at org.apache.sqoop.Sqoop.runTool(Sqoop.java:243)​ at org.apache.sqoop.Sqoop.main(Sqoop.java:252)18/11/29 05:20:45 ERROR tool.ExportTool: Encountered IOException running export job:java.io.IOException: No columns to generate for ClassWriter​ at org.apache.sqoop.orm.ClassWriter.generate(ClassWriter.java:1677)​ at org.apache.sqoop.tool.CodeGenTool.generateORM(CodeGenTool.java:106)​ at org.apache.sqoop.tool.ExportTool.exportTable(ExportTool.java:63)​ at org.apache.sqoop.tool.ExportTool.run(ExportTool.java:99)​ at org.apache.sqoop.Sqoop.run(Sqoop.java:147)​ at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:70)​ at org.apache.sqoop.Sqoop.runSqoop(Sqoop.java:183)​ at org.apache.sqoop.Sqoop.runTool(Sqoop.java:234)​ at org.apache.sqoop.Sqoop.runTool(Sqoop.java:243)​ at org.apache.sqoop.Sqoop.main(Sqoop.java:252) 出现这个错误，第一反应是当前用户对于Mysql的权限不够，于是第一反应去修改权限： 先进入mysql shell: 1$ mysql -u root -p 然后修改权限(第一个root表示用户，第二个root表示密码)： 1&gt; grant all privileges on *.* to root@localhost identified by 'root'; 最好刷新一下权限： 1&gt; flush privileges; 经过尝试之后我发现 并 没 有 卵 用 那么问题肯定不是这个，仔细看了一遍该export指令的参数: 字段解释： ./bin/sqoop export ##表示数据从 hive 复制到 mysql 中–connect jdbc:mysql://localhost:3306/dbtaobao–username root #mysql登陆用户名–password root #登录密码–table user_log #mysql 中的表，即将被导入的表名称–export-dir ‘/user/hive/warehouse/dbtaobao.db/user_log ‘ #hive 中被导出的文件–fields-terminated-by ‘,’ #Hive 中被导出的文件字段的分隔符 我发现：password错了。。。 修改之后就正常执行了。。。下次一定要注意参数]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据——Ubuntu14.04 安装mysql]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94Ubuntu14.04%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[今天用Ubuntu安装mysql遇到了几个小坑，记录一下帮助更多的人避坑。 安装教程：Ubuntu安装MySQL及常用操作_厦大数据库实验室博客 http://dblab.xmu.edu.cn/blog/install-mysql/ 1.mysql安装后找不到 1sudo apt-get install mysql-server #安装mysql 上述语句执行后，执行 service mysql start 出现找不到mysql情况，使用 sudo netstat -tap | grep mysql 也不能找到mysql，后来添加了两条指令，总共三条完成了mysql安装 123sudo apt-get install mysql-serversudo apt install mysql-clientsudo apt install libmysqlclient-dev 参考：https://blog.csdn.net/itxiaolong3/article/details/77905923 2.mysqld.cnf找不到 想修改 /etc/mysql/mysql.conf.d/mysqld.cnf 配置文件结果找不到，这个和mysql的版本也有关，我这个5.5版本没有这个文件。 于是修改了 /etc/mysql/my.cnf 文件，该文件配置全局选项。 /etc/my.cnf 全局选项/etc/mysql/my.cnf 全局选项SYSCONFDIR/my.cnf 全局选项$MYSQL_HOME/my.cnf 服务器特定选项（仅限服务器）defaults-extra-file 指定的文件 –defaults-extra-file，如果有的话~/.my.cnf 用户特定选项~/.mylogin.cnf 用户特定的登录路径选项（仅限客户端） 3.如果还是出现无法使用service mysql start命令的情况 可能你的mysql版本有问题，（我按教程自动获取最新版本获取的是5.5的，而课题中需要的是5.7的） 可以参考该教程自己选择和下载对应版本：请自行尝试，我是先按照下面第二个教程配置到3）、安装mysql－server时解包出错了，一番折腾没有解决，换了第一个，又按顺序解包一遍成功。Ubuntu14.04 下安装离线安装Mysql5.7 - wst878882582的博客 - CSDN博客https://blog.csdn.net/wst878882582/article/details/78457531 Ubuntu14.04安装MySQL5.7.20（MySQL最新版本） - qq_34256348的博客 - CSDN博客https://blog.csdn.net/qq_34256348/article/details/78340333 4.ERROR 1146 (42S02): Table ‘performance_schema.session_variables’ doesn’t exist 使用show variables like “char%”;指令时出现该错误 需要进行mysql_upgrade操作进行修复 1）首先退出mysql 2）在命令行界面输入：mysql_upgrade -uroot -p –force 3）然后重启mysql即可]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode————2.两数相加]]></title>
    <url>%2F2018%2F11%2F27%2FLeetCode%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目（中等）给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 输入： [2,4,3] [5,6,4] 输出： [7,0,8] 解决方案我的解法用了最直接暴力的解法，先把两个链表的各个位提出来，恢复成int类型的数，然后相加，再讲相加的和保存为String类型，通过下标遍历String各位，从而建立一个新的输出链表。 该方法最大的问题就是溢出！虽然我写的时候已经注意到会这样，不过还是尝试了一下，果然无法accept。因为两个数相加可能超出int表示范围，这时候就溢出了，尽管后面用String保存也没有什么用，显然不可取。 所以相应地我想到可以把相加的两个数用String表示，然后逐位相加，这其实就和官方解答类似了。 官方解法其实官方解法很容易想，链表是倒序从低位到高位表示的，这和做算术加法的顺序一致，先加低位，产生进位传给高位，高位继续相加，这样逐位相加，最后的结果就是所需的输出链表。 就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1l1 和 l2l2 的表头开始相加。由于每位数字都应当处于 0 \ldots 90…9 的范围内，我们计算两个数字的和时可能会出现“溢出”。例如，5 + 7 = 125+7=12。在这种情况下，我们会将当前位的数值设置为 22，并将进位 carry = 1carry=1 带入下一次迭代。进位 carrycarry 必定是 00 或 11，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 199+9+1=19。 伪代码如下： 将当前结点初始化为返回列表的哑结点。将进位 carrycarry 初始化为 00。将 pp 和 qq 分别初始化为列表 l1l1 和 l2l2 的头部。遍历列表 l1l1 和 l2l2 直至到达它们的尾端。将 xx 设为结点 pp 的值。如果 pp 已经到达 l1l1 的末尾，则将其值设置为 00。将 yy 设为结点 qq 的值。如果 qq 已经到达 l2l2 的末尾，则将其值设置为 00。设定 sum = x + y + carrysum=x+y+carry。更新进位的值，carry = sum / 10carry=sum/10。创建一个数值为 (sum \bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。同时，将 pp 和 qq 前进到下一个结点。检查 carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 11 的新结点。返回哑结点的下一个结点。请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。 l1=[0,1] l2=[0,1,2] 当一个列表比另一个列表长时. l1=[]l2=[0,1] 当一个列表为空时，即出现空列表。 l1=[9,9]l2=[1] 求和运算最后可能出现额外的进位，这一点很容易被遗忘 官方代码块： 12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 自己实现的代码块： 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); //头结点，不存储数据，方便最后返回链表首部 ListNode curr = head; int carry = 0, rest = 0; ListNode p = l1, q = l2; while(p!=null || q!=null) &#123; int v_l1 = (p!=null)? p.val:0; int v_l2 = (q!=null)? q.val:0; rest = (v_l1+v_l2+carry)%10; carry = (v_l1+v_l2+carry)/10; ListNode addNode = new ListNode(rest); curr.next = addNode; curr = addNode; p = (p==null)? null:p.next; q = (q==null)? null:q.next; &#125; if(carry!=0) //如果最高位也满10进位 &#123; curr.next = new ListNode(carry); &#125; return head.next; &#125;&#125; 复杂度分析时间复杂度：O(max(m,n))，假设 m 和 n 分别表示 l1和 l2的长度，上面的算法最多重复 max(m,n) 次。 空间复杂度：O(max(m,n))， 新列表的长度最多为max(m,n)+1。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>中等题型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据——CentOS7 eclipse中的hadoop环节配置]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94CentOS7%20eclipse%E4%B8%AD%E7%9A%84hadoop%E7%8E%AF%E8%8A%82%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本来准备写个CentOS7下hadoop分布式集群的配置教程的，最近事情有点多，暂时搁置一下吧，先把遇到的小问题记录一下。 首先我用的是VMware虚拟机创建了三台虚拟机，都是CentOS7的，一台master（命名为hadoop1），两台slaver（命名为hadoop2和hadoop3），然后在master上配置了一些eclipse，准备跑MapReduce代码的，中间遇到了点小问题。 Eclipse版本： 4.5的Mars Hadoop版本：2.7.3 所用教程：https://blog.csdn.net/xiaoyw71/article/details/53316390 前面还算正常，到使用New Hadoop Location打开Hadoop Location配置窗口这一步时出错了，一直没有反应，然后打开Window -&gt; Show View -&gt; Error Log 查看错误日志，出错语句主要是两种： Unhandled event loop exception org.osgi.framework.BundleException: Exception in org.eclipse.equinox.internal 然后在网上一顿找，有的说应该是缺jar包，然后修改MANIFEST.MF文件的，比如这个老哥的情况： 2018-6-29 解决Eclipse使用Hadoop插件无法新建Location的问题 - 知乎 https://zhuanlan.zhihu.com/p/38630695 然后我下载了hadoop-eclipse-plugin-2.7.3.jar放入eclipse 安装目录下的plugins文件夹也还是解决不了，后来有人说是eclipse和hadoop-eclipse-plugin-x.x.x.jar版本不合适的，于是我把eclipse的版本改到了Neon 4.6 ，然后再重新在eclipse里面导入hadoop-eclipse-plugin-2.7.3.jar包就成功了，希望对大家有帮助。 三台集群配置完那天测试了一下jps指令感觉一切正常，于是就stop-all.sh关掉了，第二天重新start-all.sh发现作为namenode的hadoop1执行jps后少了resourcemanager，不过另外两个datanode执行jps是正常的，后来确认问题： namenode中的yarn-site.xml文件内容和datanode中的文件内容不一致，所以出现了resourcemanager启动失败的问题（似乎是启动后又关闭了），于是我把文件内容统一了一下，重新启动就正常了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0"?&gt;&lt;!-- Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file.--&gt;&lt;configuration&gt; &lt;!-- 通知框架MR使用YARN --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;hadoop01&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8032&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8031&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8033&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8088&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 昨天写了一个mapreduce函数一直有错误，找不到错误，今天找了一天终于解决了，原来是hadoop 的job.setOutputKeyClass和job.setOutputValueClas设置输出的问题。 job.setOutputKeyClass和job.setOutputValueClas在默认情况下是同时设置map阶段和reduce阶段的输出，也就是说只有map和reduce输出是一样的时候才不会出问题。 当map和reduce输出是不一样的时候就需要通过job.setMapOutputKeyClass和job.setMapOutputValueClas来设置map阶段的输出。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ主题模式传递消息]]></title>
    <url>%2F2018%2F10%2F20%2FActiveMQ%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[订阅发布方式传递消息：Topic ，就类似微信公众号一样，可以多个订阅者接收一样的消息 补充：由于topic传递消息的特点是，一个生产者发送给多个消费者，生产者生产的消息在没有被消费者消费之前，并不会将消息持久化到activemq的服务端，发送的消息会自动消失。所以 测试的时候需要先创建消费者对象，然后再发送消息，防止消息丢失。 生产者实现步骤： 步骤和PTP的方式完全一样，不同的是在创建Destination对象的时候，需要创建topic对象 1234567891011121314151617181920212223242526272829303132333435public class AppProducer &#123; private static final String url = "tcp://127.0.0.1:61616"; private static final String topicName="topic-test"; //topic名称 public static void main(String[] args) &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(url); try &#123; //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标（注意：此处变成了Topic） Destination destination = session.createTopic(topicName); //6.创建一个生产者 MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; 100; ++i) &#123; //7.创建消息 TextMessage textMessage = session.createTextMessage("test" + i); //8.发布消息 producer.send(textMessage); System.out.println("发送消息" + textMessage.getText()); &#125; //9.关闭连接 connection.close(); &#125;catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 消费者实现的步骤： 步骤和PTP消费者实现的步骤一样，唯一不同的是在创建Destination对象的时候，创建topic对象，同时要和发布订阅的生产者的topic一致 12345678910111213141516171819202122232425262728293031323334353637public class AppConsumer &#123; private static final String url = "tcp://127.0.0.1:61616"; private static final String topicName="topic-test"; public static void main(String[] args) &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(url); try &#123; //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createTopic(topicName); //6.创建一个消费者 MessageConsumer consumer = session.createConsumer(destination); //7.创建一个监听器 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println("接受消息"+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); //8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了） //connection.close(); &#125;catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ队列模式传递消息]]></title>
    <url>%2F2018%2F10%2F20%2FActiveMQ%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[队列模式：点对点的方式（PTP）即：一个消息的生产者对应一个消费者，一个消息只能供一个消费者进行消费。 生产者（Producer）实现步骤： 第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递 第二步：通过第一步创建的工厂对象获得连接对象Connection 第三步：开启连接，直接调用connection对象的start方法即可 第四步：创建一个Session对象，通过connection对象创建 第五步：通过Session对象创建一个Destination对象（该对象有两种方式：topic和quene），这里使用quene 第六步：通过Session对象创建一个生产者Producer对象 第七步：创建Message对象，这里使用TextMessage对象，设置消息内容 第八步：使用创建的生产者对象Producer发送消息 第九步：关闭资源（Producer对象，Connection对象，Session对象） 12345678910111213141516171819202122232425262728293031323334353637import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class AppProducer &#123; private static final String url = "tcp://127.0.0.1:61616"; //127.0.0.1是回环地址，相当于localhost，61616是默认端口 private static final String queueName="queue-test"; public static void main(String[] args) &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(url); try &#123; //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createQueue(queueName); //6.创建一个生产者 MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; 100; ++i) &#123; //7.创建消息 TextMessage textMessage = session.createTextMessage("test" + i); //8.发布消息 producer.send(textMessage); System.out.println("发送消息" + textMessage.getText()); &#125; //9.关闭连接 connection.close(); &#125;catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 消费者（Consumer）实现步骤： 第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递 第二步：通过第一步创建的工厂对象获得连接对象Connection 第三步：开启连接，直接调用connection对象的start方法即可 第四步：创建一个Session对象，通过connection对象创建 第五步：创建一个Destination对象，使用quene，需要和生产者的quene一致 第六步：创建一个消费者对象 第七步：接收消息 第八步：打印接收的消息 第九步：关闭资源（此处关闭不要在监听后面直接关闭，因为监听是异步的，直接立刻关闭会导致监听没有结束就被关闭了，可以考虑在监听后面加入阻塞操作，让连接延迟中断） 123456789101112131415161718192021222324252627282930313233343536373839public class AppConsumer &#123; private static final String url = "tcp://127.0.0.1:61616"; private static final String queueName="queue-test"; public static void main(String[] args) &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(url); try &#123; //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createQueue(queueName); //6.创建一个消费者 MessageConsumer consumer = session.createConsumer(destination); //7.创建一个监听器 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println("接受消息"+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); //8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了） //等待键盘输入,可用于阻塞连接断开操作 //System.in.read(); //connection.close(); &#125;catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 另外消费者可以开启多个，共同消费生成者产生的消息，这样消息会被均匀分配给消费者。]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记——接口及其转换]]></title>
    <url>%2F2018%2F10%2F20%2FJAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[仍然是这段代码： 1234567891011//7.创建一个监听器consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; //强制转换，因为Producer发送的message已经确定是TextMessage类型的， try &#123; System.out.println("接受消息"+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); TextMessage textMessage = (TextMessage)message;这句让我感到疑惑。 TextMessage继承的Message，但是两者都是接口。怎么能直接用来生成对象呢？ 参考：Java接口可以有对象吗_百度知道 https://zhidao.baidu.com/question/579326704.html 其实这里相当于父类引用指向子类对象一样，就是用接口引用指向了一个实现了这个接口的对象，包括方法返回值是TextMessage也相当于是做了接口引用指向实现了这个接口的对象的转化。具体可以再看看参考。 message是Message，即父接口，textMessage是TextMessage，即子接口，为啥这句代码把父类强制转换成了子类？ 这是因为在Producer时发送的消息就是TextMessage的（producer.send(textMessage);），这里相当于发送时把子类先转换成了父类引用，后来到这句代码又强制转换回来了，这样是没有影响的。 PS：平时如果一个父类对象直接强制转换为子类一般是不允许的；反过来，若子类被强制转为父类，它的存储空间应该是没有变化的，只是属于自己子类特有的部分被锁起来了，可以用从父类继承过来的部分，如果强制转换回来可以解锁继续用。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记——匿名内部类]]></title>
    <url>%2F2018%2F10%2F20%2FJAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[今天写ActiveMQ代码时遇到一个不熟悉的东西，叫匿名内部类，于是查阅记录一下。首先代码如下： 1234567891011//7.创建一个监听器consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; //强制转换，因为Producer发送的message已经确定是TextMessage类型的 try &#123; System.out.println("接受消息"+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); 于是我查看了一下setMessageListener方法的定义，它的参数是MessageListener： 1void setMessageListener(MessageListener var1) throws JMSException; 然后又看了一下MessageListener的定义，发现它是个接口： 123public interface MessageListener &#123; void onMessage(Message var1);&#125; 于是我就懵逼了。。为什么代码里new了一个接口，查了查才知道这叫匿名内部类。 参考资料：https://zhidao.baidu.com/question/424144818620834092.html 也就是说，new MessageListener()后面的大括号内相当于创建了一个类，它实现了这个MessageListener接口，所以里面实现了onMessage（）方法。。。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IDE配置ActiveMQ]]></title>
    <url>%2F2018%2F10%2F20%2FJava%20IDE%E9%85%8D%E7%BD%AEActiveMQ%2F</url>
    <content type="text"><![CDATA[在实际操作中，我们需要用java完成activeMQ的应用，此处我使用的IntelliJ IDEA的编译器，eclipse的还没有尝试，不过应该是类似的，此处稍微记录一下。 打开IDEA，选择Maven项目，直接点击next，GroupId写com.ActiveMQ.test1，ArtifactId写的test1，当然这个不是很重要，可以自己随意写，最后Finish就行。 然后在src/main/java下添加package和class 想要使用ActiveMQ，我们还需要把jar包导入，点击左上角File——进入Project Structure——找到Libraries——添加——选择ActiveMQ根目录下的jar包(比如activemq-all-5.15.6.jar)，导入后就差不多了，如果有相关提示，处理一下就行了。 再使用ActiveMQ内的函数已经编译器已经会自动识别和提示了]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之递归]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归既会出现多次函数调用，会多占用空间也会消耗时间，空间复杂度和时间复杂度都会上升，其他基础知识不再此赘述，主要记录一下几个关键点。 递归需要满足的三个条件 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 递归需要注意的问题 递归代码要警惕堆栈溢出，因为系统栈或者虚拟机栈空间一般都不大。解决方案：可以限制递归调用的最大深度，但是这种方法不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，无法事先计算，所以当最大递归深度比较小，如10、50时，可以使用这种方法。 递归代码要警惕重复计算。比如f(n)=f(n-1)+f(n-2)，那么f(4)=f(3)+f(2)且f(5)=f(4)+f(3)，则f(3)就被重复计算了两次。此时可以通过散列表为已经求出的f(K)值建立索引K，这样当在后面的递归中用到f(K)时就不需要重复计算了，只需要map.get(n)获取相应值即可。 谨防脏数据，出现递归死循环。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之队列]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[顺序队列和链式队列就像栈有顺序栈和链式栈一样，队列也有顺序的和链式的。 顺序队列使用head指针指向队头，使用tail指针指向队尾，初始队列的头指针和尾指针指向第0个位置，入队操作时尾指针向后移（相当于尾指针是指向队列尾元素的下一个位置的），出队操作时头指针向后移（相当于头指针是指向队列头元素的位置的），队满的判断条件为 tail == n，队空的判断条件为 head == tail。随着不停地进行入队、出队操作，head 和 tail 都会持续后移，当 tail 移动到最右边，即使数组中还有空闲空间，也无法往队列里继续添加数据了，此时可以使用数据搬移，一个解决方案就是每进行一次出队操作，就把出队前0位置后面的数据前移一位，但是这样出队操作的时间复杂度会从O(1)变成O(n)；更好的方案是不必要每次出队后都进行一次数据迁移，而是等到队列没有空闲空间时，再次需要入队时集中触发数据搬移操作即可。 123456789101112131415161718// 入队操作，将 item 放入队尾 public boolean enqueue(String item) &#123; // tail == n 表示队列末尾没有空间了 if (tail == n) &#123; // tail ==n &amp;&amp; head==0，表示整个队列都占满了 if (head == 0) return false; // 数据搬移 for (int i = head; i &lt; tail; ++i) &#123; items[i-head] = items[i]; &#125; // 搬移完之后重新更新 head 和 tail tail -= head; head = 0; &#125; items[tail] = item; ++tail; return true;&#125; 也就是将head到tail之间的数据移动至0到tail-head的位置。此时均摊时间复杂度为O(1)，平均时间复杂度也为O(1)（此处存疑）。 链式队列类似，不再赘述。 循环队列循环队列一般都是数组形式的顺序队列，链式的叫循环链表。 循环队列队空的判断条件仍为 head == tail，队满的判断条件为(tail+1)%n == head，也正因为这样，当队列满时， tail 指向的位置实际是没有存储数据的，所以会浪费一个数组的存储空间。 1234567891011121314151617181920212223242526272829303132public class CircularQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; //入队 public boolean enqueue(String item) &#123; //队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; &#125; //出队 public String dequeue &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = item[head]; head = (head + 1) % n; return ret; &#125;&#125; 阻塞队列和并发队列阻塞队列其实就是在队列基础上增加了阻塞操作。就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。其实就是一个“生产者 - 消费者模型”。 线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue()上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ安装]]></title>
    <url>%2F2018%2F10%2F14%2FActiveMQ%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。MQ: message queue, 顾名思义就是消息队列的意思。因而这个主要是关于消息交互和消息队列的。 下载ActiveMQ去官方网站下载：http://activemq.apache.org/ 下载之前注意查看版本对应的JDK要求，并在本机配置好；可以在官网release底下找到要求的最低版本，此处放出部分版本号。 MQ版本号 Build-Jdk 依赖JDK apache-activemq-5.11.0 1.7.0_60 1.7+ apache-activemq-5.12.0 1.7.0_80 1.7+ apache-activemq-5.13.0 1.7.0_80 1.7+ apache-activemq-5.14.0 1.7.0_80 1.7+ apache-activemq-5.15.0 1.8.0_112 1.8+ 运行ActiveMQ解压文件夹后进入bin目录，双击activemq.bat就可以启动ActiveMQ了 此处我出现了一个问题，双击bat文件后出现控制台闪现后消失的现象，解决方案如下： windows系统，在bin文件夹下打开cmd命令行，输入 activemq-admin.bat start。 大约是JDK版本问题，引起了闪退。 后来偶然发现另一个方式，根目录的bin文件下有win32和win64两个文件夹，因为我的是64位，所以就打开win64文件夹，并且运行activemq.bat即可直接使用。(当然若运行InstallService.bat并打开activemq服务可以直接打开管理页面，不需要去console运行了) 我是使用了第一个方法解决的。 出错时显示如下： 解决后显示如下： 启动ActiveMQ以后，登陆：http://localhost:8161/admin/ ,账户和密码都是admin，正常显示如下： 至此安装结束，可以创建queue了。]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之堆栈]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%A0%88%2F</url>
    <content type="text"><![CDATA[关于堆栈的基础知识此处不做赘述。主要写一下今天学习数据结构的堆栈时看到的一个问题： JVM的堆栈和数据结构的堆栈一样么第一反应肯定还是不一样的，但是具体为什么不一样好像也不知道个所以然。。于是上网查了查，此处引用一篇资料，希望有所帮助。 JVM中的stack和heap与数据结构中所说的stack和heap是一个概念吗-CSDN论坛https://bbs.csdn.net/topics/330120842 https://blog.csdn.net/weixin_41856078/article/details/79725852 JVM中的stack和heap的实现方法与特性和普通的数据结构是一样，概念上应该是一致的。只是实现层次不同，实现方式上肯定比一般的实现要复杂点，只是对外的操作肯定一致。 数据结构中的堆栈：是两种特殊的数据结构，都是对数据项按序排列的数据结构，对管理数据的一种手段和方法。可以用来存放数据和地址，栈只能在一端（栈顶）对数据项进行插入和删除。 内存中的堆栈：是确切存在的物理结构，是用来存放不同数据的内存空间。内存中的栈，是由系统自动分配和释放的，是由高地址向低地址扩展的数据机构，是一段连续的内存区域，是对数据结构中的栈这种手段的实现。栈的顶地址和最大容量是系统预先设定好的，在程序编译时，它就是一个确定的常数，但注意并不是所有用到栈技术的区域都是栈区，虽然目前是这样，这是概念定义的准确性问题。 内存中堆，一般用来动态分配内存的，它的实现跟操作系统和编译器有关，一般内存中的堆貌似是用链表实现的。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之数组]]></title>
    <url>%2F2018%2F10%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[什么是数组数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 线性表 就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向，除了数组，链表、队列、栈等也是线性表结构（ 线性表是一种逻辑结构，而顺序表、链表等是存储结构 ）。 非线性表 如二叉树、堆、图等，数据之间并不是简单的前后关系。 误区数组和链表的区别大多数会说链表适合插入、删除，时间复杂度为O(1)；数组适合查找，查找时间复杂度为O(1)。这是不准确的！ 数组适合查找，但是查找的时间复杂度并不是O(1)，即便是排序好的数组，用二分查找，时间复杂度也是O(log n)。所以正确的表述是，数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。 低效的插入和删除数组为了保持内存数据连续性，会导致插入、删除操作比较低效。 插入 如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。 如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第K个位置。在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为O(1)。 删除 如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。我们可以将多次删除操作集中在一起执行。比如可以先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，从而可以大大减少删除操作导致的数据搬移。JVM标记清除垃圾回收算法就用了类似的思想。 为什么大多数编程语言中，数组从0开始编号从数组的存储结构来看，下标准确说就是偏移。如果下标从0开始，那么 a[k]_address = base_address + k * type_size 若下标从1开始，则会变成 a[k]_address = base_address + (k-1) * type_size 那么每次随机访问数组元素时就多了一次减法运算，对于CPU来说，就是多了一次减法指令。 数组作为基础的数据结构，通过下标随机访问又是非常基础的操作，效率的优化就需要尽可能做到极致，所以选择了从0开始编号。另一方面，从历史角度来看，由于C语言设计用0作为数组下标，而后的java、javaScript等高级语言都是效仿了C语言，也为了减少C语言程序员学习java的学习成本。但比如Matlab就不是从0开始，Python支持负数下标。 使用容器还是数组比如C++的Vector或者Java的ArrayList等属于容器类，一般来说容器类相比数组会消耗一定的性能（比如动态扩容时往往是重新申请一个更大的空间，将数据拷贝进去，而拷贝操作十分耗时）。不过对于业务开发，直接用容器类就够了，比较省时省力，但如果是底层开发，性能需要尽量优化，则数组可能更好。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode————1.两数之和]]></title>
    <url>%2F2018%2F10%2F08%2FLeetCode%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目（简单）给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解决方案我的解法class Solution { public int[] twoSum(int[] nums, int target) { for(int i=0;i&lt;nums.length;++i) { int T = target - nums[i]; for(int j=i+1;j&lt;nums.length;++j) { if(nums[j] == T) return new int[]{i, j}; //不需要提前申请，直接可以返回 } } throw new IllegalArgumentException(&quot;No two sum solution&quot;); //抛出错误 } } 1.暴力解法暴力法很简单。遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。​ public int[] twoSum(int[] nums, int target) {​ for (int i = 0; i &lt; nums.length; i++) {​ for (int j = i + 1; j &lt; nums.length; j++) {​ if (nums[j] == target - nums[i]) {​ return new int[] { i, j };​ }​ }​ }​ throw new IllegalArgumentException(“No two sum solution”);} 复杂度分析 时间复杂度：O(n2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n)的时间。因此时间复杂度为 O(n2)。 空间复杂度：O(1)。 2.两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。通过以空间换取速度的方式，我们可以将查找时间从O(n)降低到O(1)。哈希表正是为此目的而构建的，它支持以近似恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是nums[i]本身！​ public int[] twoSum(int[] nums, int target) {​ Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();​ for (int i = 0; i &lt; nums.length; i++) {​ map.put(nums[i], i);​ }​ for (int i = 0; i &lt; nums.length; i++) {​ int complement = target - nums[i];​ if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) { //containsKey方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false​ return new int[] { i, map.get(complement) };​ }​ }​ throw new IllegalArgumentException(“No two sum solution”);} 复杂度分析 时间复杂度：O(n)，我们把包含有n个元素的列表遍历两次。由于哈希表将查找时间缩短到O(1) ，所以时间复杂度为O(n)。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 3.一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。​ public int[] twoSum(int[] nums, int target) {​ Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();​ for (int i = 0; i &lt; nums.length; i++) {​ int complement = target - nums[i];​ if (map.containsKey(complement)) {​ return new int[] { map.get(complement), i };​ }​ map.put(nums[i], i);​ }​ throw new IllegalArgumentException(“No two sum solution”);} 复杂度分析 时间复杂度：O(n)，我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费O(1)的时间。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>简单题型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题如何添加打赏功能]]></title>
    <url>%2F2018%2F10%2F03%2FHexo%20Next%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[最近搭建博客时想要添加个打赏功能，虽然好像一般也没人打赏= = 但是咱们是那种见钱眼开的人么？不是！所以————咱们还是添加一个吧！ 在网上查了些资料，有的方法试了发现没成功，可能因为主题不一样的原因，由于我使用的Next主题，所以先把Next主题下的添加打赏方法写出来。 基于Next主题1.准备支付宝和微信二维码&ensp;&ensp;首先得准备支付宝和微信的收款二维码（直接打开相应软件，到收款功能处保存二维码即可），然后将对应图片放在next\source\images路径下，并命名为wechatpay.jpg和alipay.jpg（文件名称随意，不过后面会用到，当然你用PNG格式也是可以的） 2.在_config.yml中添加图片路径&ensp;&ensp;注意此处_config.yml是主题配置文件，不要弄错了。打开后找到如下属性,并配置路径: **reward_comment:** 坚持原创技术分享，您的支持将鼓励我继续创作！ **wechatpay:** /images/wechatpay.jpg **alipay:** /images/alipay.jpg 3.修复闪动bug修改next/source/css/_common/components/post/post-reward.styl，注释wechat:hover和alipay:hover /* 注释文字闪动函数 #wechat:hover p{ animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear; } #alipay:hover p{ animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear; } */ 4.效果 基于其他主题其他主题的我没有尝试，此处转载一个链接，里面有关于打赏实现的方法，希望能有帮助：https://blog.csdn.net/l_201607/article/details/81097278]]></content>
      <categories>
        <category>Hexo静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构的广义定义和狭义定义]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B9%BF%E4%B9%89%E5%AE%9A%E4%B9%89%E5%92%8C%E7%8B%AD%E4%B9%89%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[最近看了关于数据结构的课程，打算重温一下数据结构的知识，正好又新搭建了个人博客，打算把学习过程中的一些知识点记录下来，方便以后温习。部分内容是直接copy的课程内容，如有侵权，请联系博主删除。 广义定义指一组数据结构的存储结构。算法就是操作数据的一组方法。 狭义定义指某些著名的数据结构和算法，如队列、栈、堆、二分查找、动态规划等。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo配置文件 subtile和description内容如何换行]]></title>
    <url>%2F2018%2F10%2F01%2FHexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20subtile%E5%92%8Cdescription%E5%86%85%E5%AE%B9%E5%A6%82%E4%BD%95%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[配置Hexo个人博客时，站点配置文件_config.yml中个人信息可能需要换行，此时只需要在换行位置加上换行符即可。具体方法如下： 使用&lt;br>实现换行# Site title: JJ❤22 subtitle: description: QQ:339003672&lt;br&gt;WeChat:Zhang_junj #分行 keywords: author: JJZhang language: zh-Hans timezone: 直接在换行位置加入&lt;br>即可。]]></content>
      <categories>
        <category>Hexo静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
