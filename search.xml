<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大数据——CentOS7 eclipse中的hadoop环节配置]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E2%80%94%E2%80%94CentOS7%20eclipse%E4%B8%AD%E7%9A%84hadoop%E7%8E%AF%E8%8A%82%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本来准备写个CentOS7下hadoop分布式集群的配置教程的，最近事情有点多，暂时搁置一下吧，先把遇到的小问题记录一下。 首先我用的是VMware虚拟机创建了三台虚拟机，都是CentOS7的，一台master（命名为hadoop1），两台slaver（命名为hadoop2和hadoop3），然后在master上配置了一些eclipse，准备跑MapReduce代码的，中间遇到了点小问题。 Eclipse版本： 4.5的Mars Hadoop版本：2.7.3 所用教程：https://blog.csdn.net/xiaoyw71/article/details/53316390 前面还算正常，到使用New Hadoop Location打开Hadoop Location配置窗口这一步时出错了，一直没有反应，然后打开Window -&gt; Show View -&gt; Error Log 查看错误日志，出错语句主要是两种： Unhandled event loop exception org.osgi.framework.BundleException: Exception in org.eclipse.equinox.internal 然后在网上一顿找，有的说应该是缺jar包，然后修改MANIFEST.MF文件的，比如这个老哥的情况： 2018-6-29 解决Eclipse使用Hadoop插件无法新建Location的问题 - 知乎 https://zhuanlan.zhihu.com/p/38630695 然后我下载了hadoop-eclipse-plugin-2.7.3.jar放入eclipse 安装目录下的plugins文件夹也还是解决不了，后来有人说是eclipse和hadoop-eclipse-plugin-x.x.x.jar版本不合适的，于是我把eclipse的版本改到了Neon 4.6 ，然后再重新在eclipse里面导入hadoop-eclipse-plugin-2.7.3.jar包就成功了，希望对大家有帮助。 三台集群配置完那天测试了一下jps指令感觉一切正常，于是就stop-all.sh关掉了，第二天重新start-all.sh发现作为namenode的hadoop1执行jps后少了resourcemanager，不过另外两个datanode执行jps是正常的，后来确认问题： namenode中的yarn-site.xml文件内容和datanode中的文件内容不一致，所以出现了resourcemanager启动失败的问题（似乎是启动后又关闭了），于是我把文件内容统一了一下，重新启动就正常了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0"?&gt;&lt;!-- Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file.--&gt;&lt;configuration&gt; &lt;!-- 通知框架MR使用YARN --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;hadoop01&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8032&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8031&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8033&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;192.168.211.140:8088&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>big data</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ主题模式传递消息]]></title>
    <url>%2F2018%2F10%2F20%2FActiveMQ%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[订阅发布方式传递消息：Topic ，就类似微信公众号一样，可以多个订阅者接收一样的消息 补充：由于topic传递消息的特点是，一个生产者发送给多个消费者，生产者生产的消息在没有被消费者消费之前，并不会将消息持久化到activemq的服务端，发送的消息会自动消失。所以 测试的时候需要先创建消费者对象，然后再发送消息，防止消息丢失。 生产者实现步骤： 步骤和PTP的方式完全一样，不同的是在创建Destination对象的时候，需要创建topic对象 1234567891011121314151617181920212223242526272829303132333435public class AppProducer &#123; private static final String url = "tcp://127.0.0.1:61616"; private static final String topicName="topic-test"; //topic名称 public static void main(String[] args) &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(url); try &#123; //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标（注意：此处变成了Topic） Destination destination = session.createTopic(topicName); //6.创建一个生产者 MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; 100; ++i) &#123; //7.创建消息 TextMessage textMessage = session.createTextMessage("test" + i); //8.发布消息 producer.send(textMessage); System.out.println("发送消息" + textMessage.getText()); &#125; //9.关闭连接 connection.close(); &#125;catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 消费者实现的步骤： 步骤和PTP消费者实现的步骤一样，唯一不同的是在创建Destination对象的时候，创建topic对象，同时要和发布订阅的生产者的topic一致 12345678910111213141516171819202122232425262728293031323334353637public class AppConsumer &#123; private static final String url = "tcp://127.0.0.1:61616"; private static final String topicName="topic-test"; public static void main(String[] args) &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(url); try &#123; //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createTopic(topicName); //6.创建一个消费者 MessageConsumer consumer = session.createConsumer(destination); //7.创建一个监听器 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println("接受消息"+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); //8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了） //connection.close(); &#125;catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ队列模式传递消息]]></title>
    <url>%2F2018%2F10%2F20%2FActiveMQ%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[队列模式：点对点的方式（PTP）即：一个消息的生产者对应一个消费者，一个消息只能供一个消费者进行消费。 生产者（Producer）实现步骤： 第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递 第二步：通过第一步创建的工厂对象获得连接对象Connection 第三步：开启连接，直接调用connection对象的start方法即可 第四步：创建一个Session对象，通过connection对象创建 第五步：通过Session对象创建一个Destination对象（该对象有两种方式：topic和quene），这里使用quene 第六步：通过Session对象创建一个生产者Producer对象 第七步：创建Message对象，这里使用TextMessage对象，设置消息内容 第八步：使用创建的生产者对象Producer发送消息 第九步：关闭资源（Producer对象，Connection对象，Session对象） 12345678910111213141516171819202122232425262728293031323334353637import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class AppProducer &#123; private static final String url = "tcp://127.0.0.1:61616"; //127.0.0.1是回环地址，相当于localhost，61616是默认端口 private static final String queueName="queue-test"; public static void main(String[] args) &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(url); try &#123; //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createQueue(queueName); //6.创建一个生产者 MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; 100; ++i) &#123; //7.创建消息 TextMessage textMessage = session.createTextMessage("test" + i); //8.发布消息 producer.send(textMessage); System.out.println("发送消息" + textMessage.getText()); &#125; //9.关闭连接 connection.close(); &#125;catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 消费者（Consumer）实现步骤： 第一步：创建一个ConnectionFactory对象，将服务端activemq的 ip 和 port 作为构造参数传递 第二步：通过第一步创建的工厂对象获得连接对象Connection 第三步：开启连接，直接调用connection对象的start方法即可 第四步：创建一个Session对象，通过connection对象创建 第五步：创建一个Destination对象，使用quene，需要和生产者的quene一致 第六步：创建一个消费者对象 第七步：接收消息 第八步：打印接收的消息 第九步：关闭资源（此处关闭不要在监听后面直接关闭，因为监听是异步的，直接立刻关闭会导致监听没有结束就被关闭了，可以考虑在监听后面加入阻塞操作，让连接延迟中断） 123456789101112131415161718192021222324252627282930313233343536373839public class AppConsumer &#123; private static final String url = "tcp://127.0.0.1:61616"; private static final String queueName="queue-test"; public static void main(String[] args) &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(url); try &#123; //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createQueue(queueName); //6.创建一个消费者 MessageConsumer consumer = session.createConsumer(destination); //7.创建一个监听器 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println("接受消息"+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); //8.关闭连接（上面的监听是异步的，如果关闭则监听就停止了） //等待键盘输入,可用于阻塞连接断开操作 //System.in.read(); //connection.close(); &#125;catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 另外消费者可以开启多个，共同消费生成者产生的消息，这样消息会被均匀分配给消费者。]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记——接口及其转换]]></title>
    <url>%2F2018%2F10%2F20%2FJAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[仍然是这段代码： 1234567891011//7.创建一个监听器consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; //强制转换，因为Producer发送的message已经确定是TextMessage类型的， try &#123; System.out.println("接受消息"+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); TextMessage textMessage = (TextMessage)message;这句让我感到疑惑。 TextMessage继承的Message，但是两者都是接口。怎么能直接用来生成对象呢？ 参考：Java接口可以有对象吗_百度知道 https://zhidao.baidu.com/question/579326704.html 其实这里相当于父类引用指向子类对象一样，就是用接口引用指向了一个实现了这个接口的对象，包括方法返回值是TextMessage也相当于是做了接口引用指向实现了这个接口的对象的转化。具体可以再看看参考。 message是Message，即父接口，textMessage是TextMessage，即子接口，为啥这句代码把父类强制转换成了子类？ 这是因为在Producer时发送的消息就是TextMessage的（producer.send(textMessage);），这里相当于发送时把子类先转换成了父类引用，后来到这句代码又强制转换回来了，这样是没有影响的。 PS：平时如果一个父类对象直接强制转换为子类一般是不允许的；反过来，若子类被强制转为父类，它的存储空间应该是没有变化的，只是属于自己子类特有的部分被锁起来了，可以用从父类继承过来的部分，如果强制转换回来可以解锁继续用。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA笔记——匿名内部类]]></title>
    <url>%2F2018%2F10%2F20%2FJAVA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[今天写ActiveMQ代码时遇到一个不熟悉的东西，叫匿名内部类，于是查阅记录一下。首先代码如下： 1234567891011//7.创建一个监听器consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; //强制转换，因为Producer发送的message已经确定是TextMessage类型的 try &#123; System.out.println("接受消息"+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); 于是我查看了一下setMessageListener方法的定义，它的参数是MessageListener： 1void setMessageListener(MessageListener var1) throws JMSException; 然后又看了一下MessageListener的定义，发现它是个接口： 123public interface MessageListener &#123; void onMessage(Message var1);&#125; 于是我就懵逼了。。为什么代码里new了一个接口，查了查才知道这叫匿名内部类。 参考资料：https://zhidao.baidu.com/question/424144818620834092.html 也就是说，new MessageListener()后面的大括号内相当于创建了一个类，它实现了这个MessageListener接口，所以里面实现了onMessage（）方法。。。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IDE配置ActiveMQ]]></title>
    <url>%2F2018%2F10%2F20%2FJava%20IDE%E9%85%8D%E7%BD%AEActiveMQ%2F</url>
    <content type="text"><![CDATA[在实际操作中，我们需要用java完成activeMQ的应用，此处我使用的IntelliJ IDEA的编译器，eclipse的还没有尝试，不过应该是类似的，此处稍微记录一下。 打开IDEA，选择Maven项目，直接点击next，GroupId写com.ActiveMQ.test1，ArtifactId写的test1，当然这个不是很重要，可以自己随意写，最后Finish就行。 然后在src/main/java下添加package和class 想要使用ActiveMQ，我们还需要把jar包导入，点击左上角File——进入Project Structure——找到Libraries——添加——选择ActiveMQ根目录下的jar包(比如activemq-all-5.15.6.jar)，导入后就差不多了，如果有相关提示，处理一下就行了。 再使用ActiveMQ内的函数已经编译器已经会自动识别和提示了]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之递归]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归既会出现多次函数调用，会多占用空间也会消耗时间，空间复杂度和时间复杂度都会上升，其他基础知识不再此赘述，主要记录一下几个关键点。 递归需要满足的三个条件 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件 递归需要注意的问题 递归代码要警惕堆栈溢出，因为系统栈或者虚拟机栈空间一般都不大。解决方案：可以限制递归调用的最大深度，但是这种方法不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，无法事先计算，所以当最大递归深度比较小，如10、50时，可以使用这种方法。 递归代码要警惕重复计算。比如f(n)=f(n-1)+f(n-2)，那么f(4)=f(3)+f(2)且f(5)=f(4)+f(3)，则f(3)就被重复计算了两次。此时可以通过散列表为已经求出的f(K)值建立索引K，这样当在后面的递归中用到f(K)时就不需要重复计算了，只需要map.get(n)获取相应值即可。 谨防脏数据，出现递归死循环。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之队列]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[顺序队列和链式队列就像栈有顺序栈和链式栈一样，队列也有顺序的和链式的。 顺序队列使用head指针指向队头，使用tail指针指向队尾，初始队列的头指针和尾指针指向第0个位置，入队操作时尾指针向后移（相当于尾指针是指向队列尾元素的下一个位置的），出队操作时头指针向后移（相当于头指针是指向队列头元素的位置的），队满的判断条件为 tail == n，队空的判断条件为 head == tail。随着不停地进行入队、出队操作，head 和 tail 都会持续后移，当 tail 移动到最右边，即使数组中还有空闲空间，也无法往队列里继续添加数据了，此时可以使用数据搬移，一个解决方案就是每进行一次出队操作，就把出队前0位置后面的数据前移一位，但是这样出队操作的时间复杂度会从O(1)变成O(n)；更好的方案是不必要每次出队后都进行一次数据迁移，而是等到队列没有空闲空间时，再次需要入队时集中触发数据搬移操作即可。 123456789101112131415161718// 入队操作，将 item 放入队尾 public boolean enqueue(String item) &#123; // tail == n 表示队列末尾没有空间了 if (tail == n) &#123; // tail ==n &amp;&amp; head==0，表示整个队列都占满了 if (head == 0) return false; // 数据搬移 for (int i = head; i &lt; tail; ++i) &#123; items[i-head] = items[i]; &#125; // 搬移完之后重新更新 head 和 tail tail -= head; head = 0; &#125; items[tail] = item; ++tail; return true;&#125; 也就是将head到tail之间的数据移动至0到tail-head的位置。此时均摊时间复杂度为O(1)，平均时间复杂度也为O(1)（此处存疑）。 链式队列类似，不再赘述。 循环队列循环队列一般都是数组形式的顺序队列，链式的叫循环链表。 循环队列队空的判断条件仍为 head == tail，队满的判断条件为(tail+1)%n == head，也正因为这样，当队列满时， tail 指向的位置实际是没有存储数据的，所以会浪费一个数组的存储空间。 1234567891011121314151617181920212223242526272829303132public class CircularQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; //入队 public boolean enqueue(String item) &#123; //队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; &#125; //出队 public String dequeue &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = item[head]; head = (head + 1) % n; return ret; &#125;&#125; 阻塞队列和并发队列阻塞队列其实就是在队列基础上增加了阻塞操作。就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。其实就是一个“生产者 - 消费者模型”。 线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue()上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ安装]]></title>
    <url>%2F2018%2F10%2F14%2FActiveMQ%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。MQ: message queue, 顾名思义就是消息队列的意思。因而这个主要是关于消息交互和消息队列的。 下载ActiveMQ去官方网站下载：http://activemq.apache.org/ 下载之前注意查看版本对应的JDK要求，并在本机配置好；可以在官网release底下找到要求的最低版本，此处放出部分版本号。 MQ版本号 Build-Jdk 依赖JDK apache-activemq-5.11.0 1.7.0_60 1.7+ apache-activemq-5.12.0 1.7.0_80 1.7+ apache-activemq-5.13.0 1.7.0_80 1.7+ apache-activemq-5.14.0 1.7.0_80 1.7+ apache-activemq-5.15.0 1.8.0_112 1.8+ 运行ActiveMQ解压文件夹后进入bin目录，双击activemq.bat就可以启动ActiveMQ了 此处我出现了一个问题，双击bat文件后出现控制台闪现后消失的现象，解决方案如下： windows系统，在bin文件夹下打开cmd命令行，输入 activemq-admin.bat start。 大约是JDK版本问题，引起了闪退。 后来偶然发现另一个方式，根目录的bin文件下有win32和win64两个文件夹，因为我的是64位，所以就打开win64文件夹，并且运行activemq.bat即可直接使用。(当然若运行InstallService.bat并打开activemq服务可以直接打开管理页面，不需要去console运行了) 我是使用了第一个方法解决的。 出错时显示如下： 解决后显示如下： 启动ActiveMQ以后，登陆：http://localhost:8161/admin/ ,账户和密码都是admin，正常显示如下： 至此安装结束，可以创建queue了。]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之堆栈]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%E6%A0%88%2F</url>
    <content type="text"><![CDATA[关于堆栈的基础知识此处不做赘述。主要写一下今天学习数据结构的堆栈时看到的一个问题： JVM的堆栈和数据结构的堆栈一样么第一反应肯定还是不一样的，但是具体为什么不一样好像也不知道个所以然。。于是上网查了查，此处引用一篇资料，希望有所帮助。 JVM中的stack和heap与数据结构中所说的stack和heap是一个概念吗-CSDN论坛https://bbs.csdn.net/topics/330120842 https://blog.csdn.net/weixin_41856078/article/details/79725852 JVM中的stack和heap的实现方法与特性和普通的数据结构是一样，概念上应该是一致的。只是实现层次不同，实现方式上肯定比一般的实现要复杂点，只是对外的操作肯定一致。 数据结构中的堆栈：是两种特殊的数据结构，都是对数据项按序排列的数据结构，对管理数据的一种手段和方法。可以用来存放数据和地址，栈只能在一端（栈顶）对数据项进行插入和删除。 内存中的堆栈：是确切存在的物理结构，是用来存放不同数据的内存空间。内存中的栈，是由系统自动分配和释放的，是由高地址向低地址扩展的数据机构，是一段连续的内存区域，是对数据结构中的栈这种手段的实现。栈的顶地址和最大容量是系统预先设定好的，在程序编译时，它就是一个确定的常数，但注意并不是所有用到栈技术的区域都是栈区，虽然目前是这样，这是概念定义的准确性问题。 内存中堆，一般用来动态分配内存的，它的实现跟操作系统和编译器有关，一般内存中的堆貌似是用链表实现的。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之数组]]></title>
    <url>%2F2018%2F10%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[什么是数组数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 线性表 就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向，除了数组，链表、队列、栈等也是线性表结构（ 线性表是一种逻辑结构，而顺序表、链表等是存储结构 ）。 非线性表 如二叉树、堆、图等，数据之间并不是简单的前后关系。 误区数组和链表的区别大多数会说链表适合插入、删除，时间复杂度为O(1)；数组适合查找，查找时间复杂度为O(1)。这是不准确的！ 数组适合查找，但是查找的时间复杂度并不是O(1)，即便是排序好的数组，用二分查找，时间复杂度也是O(log n)。所以正确的表述是，数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。 低效的插入和删除数组为了保持内存数据连续性，会导致插入、删除操作比较低效。 插入 如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。 如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第K个位置。在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为O(1)。 删除 如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。我们可以将多次删除操作集中在一起执行。比如可以先记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，从而可以大大减少删除操作导致的数据搬移。JVM标记清除垃圾回收算法就用了类似的思想。 为什么大多数编程语言中，数组从0开始编号从数组的存储结构来看，下标准确说就是偏移。如果下标从0开始，那么 a[k]_address = base_address + k * type_size 若下标从1开始，则会变成 a[k]_address = base_address + (k-1) * type_size 那么每次随机访问数组元素时就多了一次减法运算，对于CPU来说，就是多了一次减法指令。 数组作为基础的数据结构，通过下标随机访问又是非常基础的操作，效率的优化就需要尽可能做到极致，所以选择了从0开始编号。另一方面，从历史角度来看，由于C语言设计用0作为数组下标，而后的java、javaScript等高级语言都是效仿了C语言，也为了减少C语言程序员学习java的学习成本。但比如Matlab就不是从0开始，Python支持负数下标。 使用容器还是数组比如C++的Vector或者Java的ArrayList等属于容器类，一般来说容器类相比数组会消耗一定的性能（比如动态扩容时往往是重新申请一个更大的空间，将数据拷贝进去，而拷贝操作十分耗时）。不过对于业务开发，直接用容器类就够了，比较省时省力，但如果是底层开发，性能需要尽量优化，则数组可能更好。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2018%2F10%2F08%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目（简单）给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解决方案我的解法class Solution { public int[] twoSum(int[] nums, int target) { for(int i=0;i&lt;nums.length;++i) { int T = target - nums[i]; for(int j=i+1;j&lt;nums.length;++j) { if(nums[j] == T) return new int[]{i, j}; //不需要提前申请，直接可以返回 } } throw new IllegalArgumentException(&quot;No two sum solution&quot;); //抛出错误 } } 1.暴力解法暴力法很简单。遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。​ public int[] twoSum(int[] nums, int target) {​ for (int i = 0; i &lt; nums.length; i++) {​ for (int j = i + 1; j &lt; nums.length; j++) {​ if (nums[j] == target - nums[i]) {​ return new int[] { i, j };​ }​ }​ }​ throw new IllegalArgumentException(“No two sum solution”);} 复杂度分析 时间复杂度：O(n2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费O(n)的时间。因此时间复杂度为 O(n2)。 空间复杂度：O(1)。 2.两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。通过以空间换取速度的方式，我们可以将查找时间从O(n)降低到O(1)。哈希表正是为此目的而构建的，它支持以近似恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为O(1)。一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是nums[i]本身！​ public int[] twoSum(int[] nums, int target) {​ Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();​ for (int i = 0; i &lt; nums.length; i++) {​ map.put(nums[i], i);​ }​ for (int i = 0; i &lt; nums.length; i++) {​ int complement = target - nums[i];​ if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) { //containsKey方法判断Map集合对象中是否包含指定的键名。如果Map集合中包含指定的键名，则返回true，否则返回false​ return new int[] { i, map.get(complement) };​ }​ }​ throw new IllegalArgumentException(“No two sum solution”);} 复杂度分析 时间复杂度：O(n)，我们把包含有n个元素的列表遍历两次。由于哈希表将查找时间缩短到O(1) ，所以时间复杂度为O(n)。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。 3.一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。​ public int[] twoSum(int[] nums, int target) {​ Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();​ for (int i = 0; i &lt; nums.length; i++) {​ int complement = target - nums[i];​ if (map.containsKey(complement)) {​ return new int[] { map.get(complement), i };​ }​ map.put(nums[i], i);​ }​ throw new IllegalArgumentException(“No two sum solution”);} 复杂度分析 时间复杂度：O(n)，我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费O(1)的时间。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储n个元素。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>简单题型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题如何添加打赏功能]]></title>
    <url>%2F2018%2F10%2F03%2FHexo%20Next%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[最近搭建博客时想要添加个打赏功能，虽然好像一般也没人打赏= = 但是咱们是那种见钱眼开的人么？不是！所以————咱们还是添加一个吧！ 在网上查了些资料，有的方法试了发现没成功，可能因为主题不一样的原因，由于我使用的Next主题，所以先把Next主题下的添加打赏方法写出来。 基于Next主题1.准备支付宝和微信二维码&ensp;&ensp;首先得准备支付宝和微信的收款二维码（直接打开相应软件，到收款功能处保存二维码即可），然后将对应图片放在next\source\images路径下，并命名为wechatpay.jpg和alipay.jpg（文件名称随意，不过后面会用到，当然你用PNG格式也是可以的） 2.在_config.yml中添加图片路径&ensp;&ensp;注意此处_config.yml是主题配置文件，不要弄错了。打开后找到如下属性,并配置路径: **reward_comment:** 坚持原创技术分享，您的支持将鼓励我继续创作！ **wechatpay:** /images/wechatpay.jpg **alipay:** /images/alipay.jpg 3.修复闪动bug修改next/source/css/_common/components/post/post-reward.styl，注释wechat:hover和alipay:hover /* 注释文字闪动函数 #wechat:hover p{ animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear; } #alipay:hover p{ animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear; } */ 4.效果 基于其他主题其他主题的我没有尝试，此处转载一个链接，里面有关于打赏实现的方法，希望能有帮助：https://blog.csdn.net/l_201607/article/details/81097278]]></content>
      <categories>
        <category>Hexo静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构的广义定义和狭义定义]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%B9%BF%E4%B9%89%E5%AE%9A%E4%B9%89%E5%92%8C%E7%8B%AD%E4%B9%89%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[最近看了关于数据结构的课程，打算重温一下数据结构的知识，正好又新搭建了个人博客，打算把学习过程中的一些知识点记录下来，方便以后温习。部分内容是直接copy的课程内容，如有侵权，请联系博主删除。 广义定义指一组数据结构的存储结构。算法就是操作数据的一组方法。 狭义定义指某些著名的数据结构和算法，如队列、栈、堆、二分查找、动态规划等。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo配置文件 subtile和description内容如何换行]]></title>
    <url>%2F2018%2F10%2F01%2FHexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20subtile%E5%92%8Cdescription%E5%86%85%E5%AE%B9%E5%A6%82%E4%BD%95%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[配置Hexo个人博客时，站点配置文件_config.yml中个人信息可能需要换行，此时只需要在换行位置加上换行符即可。具体方法如下： 使用&lt;br>实现换行# Site title: JJ❤22 subtitle: description: QQ:339003672&lt;br&gt;WeChat:Zhang_junj #分行 keywords: author: JJZhang language: zh-Hans timezone: 直接在换行位置加入&lt;br>即可。]]></content>
      <categories>
        <category>Hexo静态博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
